<!DOCTYPE html>
<!-- ҳ����С���� -->
<script type="text/javascript" src="/js/src/love.js"></script>



<!--<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>-->
<script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
















  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  
  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "bf6ac372"
    });
  daovoice('update');
  </script>

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">
<!--<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>-->
<!--<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">-->
<script src="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcdn.net/ajax/libs/pace/1.0.2/themes/black/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*��������ɫ*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*��Ӱ��ɫ*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*�ϱ߿���ɫ*/
        border-left-color: #1E92FB;    /*��߿���ɫ*/
    }
</style>











<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="所有题目来源为力扣 题解为原创，仅为个人当前阶段能想到/能接受的解法，不一定是优解 🟢简单 🟠中等 🔴困难 ⚪未完成 ⚫未更新  有回顾价值题集：  🟠 2021.08.25 (787. K 站中转内最便宜的航班) 🔴 2021.08.18 (552. 学生出勤记录 II) 🟠 2021.08.15 (576. 出界的路径数) 🟠 2021.08.09 (313. 超级丑数)">
<meta property="og:type" content="website">
<meta property="og:title" content="每日一题">
<meta property="og:url" content="http://Sunwish.coding.me/dailyProblem/index.html">
<meta property="og:site_name" content="猴开发 | 博客">
<meta property="og:description" content="所有题目来源为力扣 题解为原创，仅为个人当前阶段能想到/能接受的解法，不一定是优解 🟢简单 🟠中等 🔴困难 ⚪未完成 ⚫未更新  有回顾价值题集：  🟠 2021.08.25 (787. K 站中转内最便宜的航班) 🔴 2021.08.18 (552. 学生出勤记录 II) 🟠 2021.08.15 (576. 出界的路径数) 🟠 2021.08.09 (313. 超级丑数)">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211101/ac237.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211031/ac500.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211030/ac260.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211030/ac260-2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211028/ac869.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211027/ac301.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211026/ac496.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211026/ac496-2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211025/ac240.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211023/ac492.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211023/ac492-2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211022/ac229.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211021/ac66.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211019/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211018/ac.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211015/ac38.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211014/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211013/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211012/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211011/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211010/arrangecoins1-grid.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211010/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211008/tle.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211008/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211007/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211006/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211005/ac2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211004/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211003/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211002/ac0.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211002/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211001/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20211001/ac2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210930/rectangle-plane.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210930/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210929/image-20210929115247903.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210929/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210928/pathsum3-1-tree.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210927/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210925/ac.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210924/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210924/ac2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210923/ac.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210922/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210921/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210920/tle.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210920/2021-09-20%20163718.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210920/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210919/image-20210919110014978.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210919/image-20210919110109228.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210919/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210918/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210917/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210825/1.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210825/2.jpg">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210825/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210824/1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210824/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210823/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210822/1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210822/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210821/1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210821/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210820/1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210820/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210819/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210818/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210817/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210816/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210815/out_of_boundary_paths_1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210815/out_of_boundary_paths_2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210815/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210810/ac.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210809/1.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210809/2.png">
<meta property="og:image" content="http://sunwish.coding.me/dailyProblem/20210809/ac.png">
<meta property="og:updated_time" content="2022-08-02T02:07:22.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每日一题">
<meta name="twitter:description" content="所有题目来源为力扣 题解为原创，仅为个人当前阶段能想到/能接受的解法，不一定是优解 🟢简单 🟠中等 🔴困难 ⚪未完成 ⚫未更新  有回顾价值题集：  🟠 2021.08.25 (787. K 站中转内最便宜的航班) 🔴 2021.08.18 (552. 学生出勤记录 II) 🟠 2021.08.15 (576. 出界的路径数) 🟠 2021.08.09 (313. 超级丑数)">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg">






  <link rel="canonical" href="http://Sunwish.coding.me/dailyProblem/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>每日一题 | 猴开发 | 博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">猴开发 | 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>

    
      
        <h1 class="site-subtitle" itemprop="description">积极思考  活跃创造</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>

  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-札记">
    <a href="/series/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-book"></i> <br />札记</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-每日一题 menu-item-active">
    <a href="/dailyProblem/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-calendar-check-o"></i> <br />每日一题</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
          <div id="music" style="width: 100%; height: 110px; margin-top: -15px; margin-bottom: 5px;">
           <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=2851637030&auto=0&height=90"></iframe>
          </div>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/Sunwish" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

    
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
      
      
    
    

  


          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h2 class="post-title" itemprop="name headline">每日一题</h2>

<div class="post-meta">
  
  



</div>

</header>

      
      
      
      <div class="post-body">
        
        
          <blockquote>
<ol>
<li>所有题目来源为力扣</li>
<li>题解为原创，仅为个人当前阶段能想到/能接受的解法，不一定是优解</li>
<li><p>🟢简单 🟠中等 🔴困难 ⚪未完成 ⚫未更新</p>
</li>
<li><p>有回顾价值题集：</p>
<ul>
<li>🟠 2021.08.25 (<a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">787. K 站中转内最便宜的航班</a>)</li>
<li>🔴 2021.08.18 (<a href="https://leetcode-cn.com/problems/student-attendance-record-ii/" target="_blank" rel="noopener">552. 学生出勤记录 II</a>)</li>
<li>🟠 2021.08.15 (<a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">576. 出界的路径数</a>)</li>
<li>🟠 2021.08.09 (<a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a>)</li>
</ul>
</li>
<li><p>其它题解：<a href="/lcProblemSolved/">我的 LeetCode 题解</a></p>
</li>
</ol>
</blockquote>
<h1 id="🟢-2021-11-01-237-删除链表中的节点"><a href="#🟢-2021-11-01-237-删除链表中的节点" class="headerlink" title="🟢 2021.11.01 (237. 删除链表中的节点)"></a>🟢 2021.11.01 (<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">237. 删除链表中的节点</a>)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请编写一个函数，用于 <strong>删除单链表中某个特定节点</strong> 。在设计函数时需要注意，你无法访问链表的头节点 <code>head</code> ，只能直接访问 <strong>要被删除的节点</strong> 。</p>
<p>题目数据保证需要删除的节点 <strong>不是末尾节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/01/node1.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line">解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [0,1], node = 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[2, 1000]</code></li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li>链表中每个节点的值都是唯一的</li>
<li>需要删除的节点 <code>node</code> 是 <strong>链表中的一个有效节点</strong> ，且 <strong>不是末尾节点</strong></li>
</ul>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>额。这实在没什么可写的。因为要删除的必不是末尾节点，那么直接将当前要删除的节点“顶替”成下一个节点就成了。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211101/ac237.png" alt="ac"></p>
<h1 id="🟢-2021-10-31-500-键盘行"><a href="#🟢-2021-10-31-500-键盘行" class="headerlink" title="🟢 2021.10.31 (500. 键盘行)"></a>🟢 2021.10.31 (<a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener">500. 键盘行</a>)</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串数组 <code>words</code> ，只返回可以使用在 <strong>美式键盘</strong> 同一行的字母打印出来的单词。键盘如下图所示。</p>
<p><strong>美式键盘</strong> 中：</p>
<ul>
<li>第一行由字符 <code>&quot;qwertyuiop&quot;</code> 组成。</li>
<li>第二行由字符 <code>&quot;asdfghjkl&quot;</code> 组成。</li>
<li>第三行由字符 <code>&quot;zxcvbnm&quot;</code> 组成。</li>
</ul>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png" alt="American keyboard"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;Hello&quot;,&quot;Alaska&quot;,&quot;Dad&quot;,&quot;Peace&quot;]</span><br><span class="line">输出：[&quot;Alaska&quot;,&quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 20</code></li>
<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
<li><code>words[i]</code> 由英文字母（小写和大写字母）组成</li>
</ul>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>本题显然逃不掉的就是遍历 <code>words</code> 中每一个单词的每一个字母在键盘各行的出现情况，也就是说搜索是高频操作， 据此不妨预打三张 HashMap，存储键盘对应三行存在的字母，然后在遍历 <code>words</code> 的过程中，对每一个 <code>word</code> 的验证就可以依次在三张 HashMap 中 $O(1)$ 地查验每一个字母是否在该行存在。如果所有字母都在某行存在，那么就不必搜索后面地行，可是直接加入答案集，验证下一个单词。若存在字母不在当前搜索行，则该单词必然不满足全在当前行的要求，直接验证是否全在下一行。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Set&lt;Character&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Set&lt;Character&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> Set&lt;Character&gt; set3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 预打三张 HashMap，存储键盘对应三行存在的字母</span></span><br><span class="line">        set1.add(<span class="string">'q'</span>); set1.add(<span class="string">'w'</span>); set1.add(<span class="string">'e'</span>); set1.add(<span class="string">'r'</span>); set1.add(<span class="string">'t'</span>); set1.add(<span class="string">'y'</span>); set1.add(<span class="string">'u'</span>); set1.add(<span class="string">'i'</span>); set1.add(<span class="string">'o'</span>); set1.add(<span class="string">'p'</span>); </span><br><span class="line">        set2.add(<span class="string">'a'</span>); set2.add(<span class="string">'s'</span>); set2.add(<span class="string">'d'</span>); set2.add(<span class="string">'f'</span>); set2.add(<span class="string">'g'</span>); set2.add(<span class="string">'h'</span>); set2.add(<span class="string">'j'</span>); set2.add(<span class="string">'k'</span>); set2.add(<span class="string">'l'</span>); </span><br><span class="line">        set3.add(<span class="string">'z'</span>); set3.add(<span class="string">'x'</span>); set3.add(<span class="string">'c'</span>); set3.add(<span class="string">'v'</span>); set3.add(<span class="string">'b'</span>); set3.add(<span class="string">'n'</span>); set3.add(<span class="string">'m'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> legal = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 依次验证该单词的每一个字母是否全都在对应行存在</span></span><br><span class="line">            legal = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set1.contains(Character.toLowerCase(words[i].charAt(j))))&#123;</span><br><span class="line">                    <span class="comment">// 存在一个字母不在当前行存在，必然不满足全在当前行（第一行）的条件，直接 break 验证是否全在下一行</span></span><br><span class="line">                    legal = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(legal)&#123;</span><br><span class="line">                <span class="comment">// 全在当前行（第一行），加入结果集，验证下一个单词</span></span><br><span class="line">                res.add(words[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 逻辑同上，做第二、三行的验证</span></span><br><span class="line">            legal = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set2.contains(Character.toLowerCase(words[i].charAt(j))))&#123;</span><br><span class="line">                    legal = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(legal)&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            legal = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!set3.contains(Character.toLowerCase(words[i].charAt(j))))&#123;</span><br><span class="line">                    legal = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(legal)&#123;</span><br><span class="line">                res.add(words[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211031/ac500.png" alt="ac"></p>
<h1 id="🟠-2021-10-30-260-只出现一次的数字-III"><a href="#🟠-2021-10-30-260-只出现一次的数字-III" class="headerlink" title="🟠 2021.10.30 (260. 只出现一次的数字 III)"></a>🟠 2021.10.30 (<a href="https://leetcode-cn.com/problems/single-number-iii/" target="_blank" rel="noopener">260. 只出现一次的数字 III</a>)</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 3 * 10^4</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>
</ul>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先不难直观地想到通过一次遍历统计 <code>nums</code> 中所有数字的出现次数，然后再选出出现次数为 1 的数字作为答案返回。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(nums[i]) == <span class="number">1</span>) res[p++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211030/ac260.png" alt="ac"></p>
<p>不过这样使用了 $O(n)$ 的空间复杂度，不满足本题的进阶要求，即在时间复杂度为 $O(n)$ 的前提下只使用 $O(1)$ 的空间复杂度。</p>
<p>通过利用 <em>其余所有元素均出现两次</em> 这一条件，结合 <code>x^y^y = x</code>，即用同一个数字异或两次后原数值不变的运算特性可知，若将 <code>nums</code> 中的所有元素全部与 0 异或的话，最终的结果将只是那两个出现一次的数字的异或结果，而其余出现两次的数字在两次异或中被抵消了。借助 2 个目标数字的异或结果，可以得到的一个信息是：异或结果中为 1 的位置，即是目标数字之间的不同位。借助这一信息，选取其中任意一个不同位作为依据，就可以将这两个目标数字分开，使得分开后的最终异或结果即是两个目标数字分别与 0 异或的结果，也就得到了两个目标数字本身的值。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) sum ^= i;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span> &amp;&amp; k == -<span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((sum &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) k = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; k) &amp; <span class="number">1</span>) == <span class="number">1</span>) ans[<span class="number">1</span>] ^= i;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>] ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211030/ac260-2.png" alt="ac"></p>
<h1 id="⚪-2021-10-29-335-路径交叉"><a href="#⚪-2021-10-29-335-路径交叉" class="headerlink" title="⚪ 2021.10.29 (335. 路径交叉)"></a>⚪ 2021.10.29 (<a href="https://leetcode-cn.com/problems/self-crossing/" target="_blank" rel="noopener">335. 路径交叉</a>)</h1><p>🔴 未做</p>
<h1 id="🟠-2021-10-28-869-重新排序得到-2-的幂"><a href="#🟠-2021-10-28-869-重新排序得到-2-的幂" class="headerlink" title="🟠 2021.10.28 (869. 重新排序得到 2 的幂)"></a>🟠 2021.10.28 (<a href="https://leetcode-cn.com/problems/reordered-power-of-2/" target="_blank" rel="noopener">869. 重新排序得到 2 的幂</a>)</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定正整数 <code>N</code> ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>
<p>如果我们可以通过上述方式得到 2 的幂，返回 <code>true</code>；否则，返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：16</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：24</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：46</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>由于指数爆炸现象的存在，不难想到在题目 <code>1 &lt;= N &lt;= 10^9</code> 的数据限制下，所有可能的 2 的幂的数量是很少的，又输入 <code>n</code> 能够随意排序，进而不需要考虑数字的顺序问题，其实是降低了难度的。</p>
<p>具体操作上，只需先提前准备好所有可能的 2 的幂，然后将这些 2 的幂的值作为文本，将每一位数字按固定的规则排好序（如从小到大排序）存放在一个待查列表 <code>legalList</code> 中。这样一来，对于输入的 <code>n</code> 只要也按这个规则排好序，排序后的结果若在 <code>legalList</code> 中存在，则说明这组数字能够按其在 <code>legalList</code> 创建时的“打乱”（排序）操作逆向复原得到一个 2 的幂，若不存在于 <code>legalList</code> 中，自然也就不存在复原出 2 的幂的排列操作。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; legalList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">// 预载好所有可能的 2 的幂（一共也就 30 个）</span></span><br><span class="line">        <span class="keyword">long</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; temp &lt;= <span class="number">1e9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] charArray = String.valueOf(temp).toCharArray();</span><br><span class="line">            Arrays.sort(charArray);</span><br><span class="line">            legalList.add(<span class="keyword">new</span> String(charArray));</span><br><span class="line">            temp = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 按 legalList 同样的规则排序，查表，存在则可被复原为 2 的幂</span></span><br><span class="line">        <span class="keyword">char</span>[] charArray = String.valueOf(n).toCharArray();</span><br><span class="line">        Arrays.sort(charArray);</span><br><span class="line">        <span class="keyword">return</span> legalList.contains(<span class="keyword">new</span> String(charArray));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211028/ac869.png" alt="ac"></p>
<h1 id="🔴-2021-10-27-301-删除无效的括号"><a href="#🔴-2021-10-27-301-删除无效的括号" class="headerlink" title="🔴 2021.10.27 (301. 删除无效的括号)"></a>🔴 2021.10.27 (<a href="https://leetcode-cn.com/problems/remove-invalid-parentheses/" target="_blank" rel="noopener">301. 删除无效的括号</a>)</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()())()&quot;</span><br><span class="line">输出：[&quot;(())()&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(a)())()&quot;</span><br><span class="line">输出：[&quot;(a())()&quot;,&quot;(a)()()&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)(&quot;</span><br><span class="line">输出：[&quot;&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 25</code></li>
<li><code>s</code> 由小写英文字母以及括号 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 组成</li>
<li><code>s</code> 中至多含 <code>20</code> 个括号</li>
</ul>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>因为每一个半括号都有可能被删除，因此首先考虑用回溯遍历解决本题。在每一个下标处，如果对应字符是括号，那么就可以选择保留，也可以选择不保留，直到字符串的最后一个字符扫描完毕，检查其是否构成一个有效的串，</p>
<p>如何检查其括号是否有效呢？非常简单，只需设置一个偏移变量 <code>bias</code> 记录左括号的盈余状态</p>
<ul>
<li>若扫描并加入了一个左括号，则 <code>bias++</code></li>
<li>若扫描并加入了一个右括号，则 <code>bias--</code></li>
</ul>
<p>那么显然在扫描的途中，一旦出现 <code>bias &lt; 0</code> 则说明串已经出现非法状态，必然无效，不需要再往后扫描了，此时可以剪枝。而在整个串扫描完毕后，检查 <code>bias</code> 的值即可，若为 <code>0</code> 则说明没有左括号盈余，也就是有效，否则无效。</p>
<p>不过这样的遍历耗时还算非常严重的，经过分析思考不难发现仍有可剪枝的地方。由于题目要求删除最小数量的括号，这就给优化提供了一条思路，即在 DFS 的过程中记录前面已经删除的括号数量，若在递归过程中删除的括号数量已经大于了之前产生过的有效串所删除的括号数，那么就不必再往深处遍历了，就算再找到有效串，也必然不是删除最小数量括号的串，不能作为结果之一。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">int</span> minRemoved = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        minRemoved = Integer.MAX_VALUE;</span><br><span class="line">        buildRes(s, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxLength = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到删除括号最小的串的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.get(i).length() &gt; maxLength) maxLength = res.get(i).length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只保留与删除括号最小串长度相同的串作为答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.get(i).length() != maxLength) res.remove(res.get(i--));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRes</span><span class="params">(String s, <span class="keyword">int</span> index, StringBuilder sb, <span class="keyword">int</span> bias, <span class="keyword">int</span> removed)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 当前删除的括号数若已经超过了已有的有效串所删除的括号数，则剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(removed &gt; minRemoved) <span class="keyword">return</span>; </span><br><span class="line">        <span class="comment">// 遍历到末尾，检查串是否有效、串是否已存在结果集中</span></span><br><span class="line">        <span class="keyword">if</span>(index == s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(bias == <span class="number">0</span> &amp;&amp; !res.contains(sb.toString()))&#123; </span><br><span class="line">                res.add(<span class="number">0</span>, sb.toString());</span><br><span class="line">                <span class="comment">// 更新构成有效串可删除的最小括号数</span></span><br><span class="line">                <span class="keyword">if</span>(removed &lt; minRemoved) minRemoved = removed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> current = s.charAt(index);</span><br><span class="line">        <span class="comment">// 非括号元素不能删除，直接添加</span></span><br><span class="line">        <span class="keyword">if</span>(current != <span class="string">'('</span> &amp;&amp; current != <span class="string">')'</span>)&#123;</span><br><span class="line">            sb.append(current);</span><br><span class="line">            buildRes(s, index + <span class="number">1</span>, sb, bias, removed);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若中途 bias&lt;0 则说明必构成无效串，剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(bias + (current == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// bias 合法，录用该括号字符</span></span><br><span class="line">            sb.append(current);</span><br><span class="line">            buildRes(s, index + <span class="number">1</span>, sb, bias + (current == <span class="string">'('</span> ? <span class="number">1</span> : -<span class="number">1</span>), removed);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不录用(删除)该字符</span></span><br><span class="line">        buildRes(s, index + <span class="number">1</span>, sb, bias, removed + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211027/ac301.png" alt="ac"></p>
<h1 id="🟢-2021-10-26-496-下一个更大元素-I"><a href="#🟢-2021-10-26-496-下一个更大元素-I" class="headerlink" title="🟢 2021.10.26 (496. 下一个更大元素 I)"></a>🟢 2021.10.26 (<a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a>)</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>请你找出 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p>
<p><code>nums1</code> 中数字 <code>x</code> 的下一个更大元素是指 <code>x</code> 在 <code>nums2</code> 中对应位置的右边的第一个比 <code>x</code> 大的元素。如果不存在，对应位置输出 <code>-1</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10^4</code></li>
<li><code>nums1</code>和<code>nums2</code>中所有整数 <strong>互不相同</strong></li>
<li><code>nums1</code> 中的所有整数同样出现在 <code>nums2</code> 中</li>
</ul>
<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>首先最简单最直接的思路，就是遍历 <code>nums1</code> 中的元素，对于 <code>nums1</code> 中的元素，去 <code>nums2</code> 中从头遍历（因为 <code>nums2</code> 无序）寻找它的相应位置，在找到相应位置后，在其位置后方继续寻找到第一个比它大的元素，存放在结果数组中的相应位置即可。</p>
<p>可以注意到，<code>nums1</code> 和 <code>nums2</code> 的长度均小于 $10^3$ 数量级，因此通过 $O(n^2)$ 的暴搜算法时间也能控制在 $10^6$ 以内，故是够能顺利 AC 的。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 预设没找到的结果为 -1</span></span><br><span class="line">            <span class="keyword">int</span> greater = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 在 nums2 中定位 nums1[i]</span></span><br><span class="line">            <span class="keyword">for</span>(; j &lt; nums2.length; j++) <span class="keyword">if</span>(nums2[j] == nums1[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 在对应位置之后，开始寻找第一个比 nums1[i] 大的值</span></span><br><span class="line">            <span class="keyword">for</span>(j++; j &lt; nums2.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[j] &gt; nums1[i])&#123;</span><br><span class="line">                    greater = nums2[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = greater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211026/ac496.png" alt="ac"></p>
<p>不过这样显然是比较低效率的做法，在 <code>nums2</code> 中寻找 <code>nums1[i]</code> 的过程中，其实中途遍历了很多其它元素，而这些被遍历过的元素在后面作为 <code>nums1[i]</code> 的时候，又要重头来找，导致时间复杂度来到平方级别。为了避免重复搜索，可以牺牲 $O(n)$ 的空间复杂度，预先建立 <code>nums[2]</code> 中值和下标的对应关系，这样就省去了对于 <code>nums1</code> 中的每个元素都要重新遍历 $nums2$ 的冗余搜索。</p>
<p>优化版完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// &lt;value, index&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++) map.put(nums2[i], i);</span><br><span class="line">        <span class="comment">// 直接定位到 nums2 中的对应位置 startIndex 开始搜索下一个比 nums1[i] 大的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> greater = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 若 nums2 中不存在对应值，则置 nums2.length 可跳过整轮循环避免冗余搜索</span></span><br><span class="line">            <span class="keyword">int</span> startIndex = map.getOrDefault(nums1[i], nums2.length);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = startIndex; j &lt; nums2.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[j] &gt; nums1[i])&#123;</span><br><span class="line">                    greater = nums2[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = greater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211026/ac496-2.png" alt="ac"></p>
<h1 id="🟠-2021-10-25-240-搜索二维矩阵-II"><a href="#🟠-2021-10-25-240-搜索二维矩阵-II" class="headerlink" title="🟠 2021.10.25 (240. 搜索二维矩阵 II)"></a>🟠 2021.10.25 (<a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a>)</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= n, m &lt;= 300</code></li>
<li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code></li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li><code>-10^9 &lt;= target &lt;= 10^9</code></li>
</ul>
<h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>首先可以按照无序数组遍历，从左到右，从上到下的次序，但是相应的时间复杂度就为  $O(mn)$，为了充分利用 <code>matrix</code> 每行递增、每列递增的特性，不难发现只需以自右向左，自上向下的次序，就可以实现 $O(m+n)$ 的搜索。</p>
<p>在从左到右，从上到下的遍历情况下，若当前元素的值小于目标值，那么并不能够确定目标值就在当前列下，因为后一列的元素也可能小于目标值，也就是说按照检索可能列的方式，会出现多个可能列的情况，进而无法单向遍历，若该列没有找到目标值，就必然要回溯检查下一列，进而沦为了 $O(mn)$ 的情况。</p>
<p>但按照自右向左，自上向下的次序，若当前元素的值大于目标值，那么是可以绝对确定目标值一定不在当前列的，因此可以不回溯地将搜索列向左移动一列。同时，若当前元素值小于目标值，同样可以确定目标值一定不在当前行，因此可以不回溯地将搜索行向下移动一行，进而确保每一步检查移动都必然向着正确的方向在走，不存在回溯，做到 $O(m+n)$ 的时间复杂度。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target == matrix[i][j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; matrix[i][j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211025/ac240.png" alt="ac"></p>
<h1 id="⚪-2021-10-24-638-大礼包"><a href="#⚪-2021-10-24-638-大礼包" class="headerlink" title="⚪ 2021.10.24 (638. 大礼包)"></a>⚪ 2021.10.24 (<a href="https://leetcode-cn.com/problems/shopping-offers/" target="_blank" rel="noopener">638. 大礼包</a>)</h1><p>🟠 未解决</p>
<h1 id="🟢-2021-10-23-492-构造矩形"><a href="#🟢-2021-10-23-492-构造矩形" class="headerlink" title="🟢 2021.10.23 (492. 构造矩形)"></a>🟢 2021.10.23 (<a href="https://leetcode-cn.com/problems/construct-the-rectangle/" target="_blank" rel="noopener">492. 构造矩形</a>)</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 你设计的矩形页面必须等于给定的目标面积。</span><br><span class="line"></span><br><span class="line">2. 宽度 W 不应大于长度 L，换言之，要求 L &gt;= W 。</span><br><span class="line"></span><br><span class="line">3. 长度 L 和宽度 W 之间的差距应当尽可能小。</span><br></pre></td></tr></table></figure>
<p>你需要按顺序输出你设计的页面的长度 L 和宽度 W。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [2, 2]</span><br><span class="line">解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。</span><br><span class="line">但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>给定的面积不大于 10,000,000 且为正整数。</li>
<li>你设计的页面的长度和宽度必须都是正整数。</li>
</ol>
<h2 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h2><p>由要求1和2可知，矩形宽度最大不可能超过 $\sqrt{area}$，因此只需遍历区间 $[1,\;\lfloor\sqrt{area}\rfloor]$ 内可能的宽度，然后记录长宽差值最小的那一对长宽即可。所谓“可能的宽度，即宽度对应的长度也是整数，即使用面积对宽度求取的余数为零即可。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxW = (<span class="keyword">int</span>)Math.pow(area, <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">int</span> l = area, w = <span class="number">1</span>, minDelta = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxW; i++)&#123;</span><br><span class="line">            <span class="comment">// invalid width</span></span><br><span class="line">            <span class="keyword">if</span>(area % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// valid width</span></span><br><span class="line">            <span class="keyword">int</span> tempL = area / i;</span><br><span class="line">            <span class="keyword">if</span>(tempL - i &lt; minDelta) &#123;</span><br><span class="line">                <span class="comment">// closer pair</span></span><br><span class="line">                l = tempL;</span><br><span class="line">                w = i;</span><br><span class="line">                minDelta = l - w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211023/ac492.png" alt="ac"></p>
<p>但是不难发现，只有尽可能大的宽度才能对应尽可能小的长宽差值，那么最小的长宽差值必然是由最大的有效宽度确定。据此将遍历的方向调换，这样找到的第一对有效长宽就是对应本题的答案了，虽然空间复杂度也是 $O(n)$，但求解效率却显然要远高于之前的代码。</p>
<p>调换遍历策略后的完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructRectangle(<span class="keyword">int</span> area) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxW = (<span class="keyword">int</span>)Math.pow(area, <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">int</span> l = area, w = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w = maxW; w &gt;= <span class="number">0</span>; w--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(area % w != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            l = area / w;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;l, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211023/ac492-2.png" alt="ac"></p>
<h1 id="🟠-2021-10-22-229-求众数-II"><a href="#🟠-2021-10-22-229-求众数-II" class="headerlink" title="🟠 2021.10.22 (229. 求众数 II)"></a>🟠 2021.10.22 (<a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">229. 求众数 II</a>)</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 <code>⌊ n/3 ⌋</code> 次的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：[3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,3,3,2,2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h2 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h2><p>借助 HashMap 统计所有数字的出现次数，若出现次数大于 $\frac{1}{3}$ 则加入结果 List 中即可。</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threshold = nums.length/<span class="number">3</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> newCount = map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, newCount);</span><br><span class="line">            <span class="keyword">if</span>(newCount&gt;threshold &amp;&amp; !list.contains(num)) list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211022/ac229.png" alt="ac"></p>
<h1 id="🟢-2021-10-21-66-加一"><a href="#🟢-2021-10-21-66-加一" class="headerlink" title="🟢 2021.10.21 (66. 加一)"></a>🟢 2021.10.21 (<a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a>)</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= digits.length &lt;= 100</code></li>
<li><code>0 &lt;= digits[i] &lt;= 9</code></li>
</ul>
<h2 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h2><p>按照正常的加法思路，从低位加一，然后检查进位，若有进位就将低位置零，并检查高一位加一后是否溢出，以此类推。特别地，考虑到进位可能产生的整个数字位数增加的情况，将每位的处理结果先添加到 List 中，最后将 List 映射转换回整型数组返回，这样可以方便地在最高位产生进位时，容易地向数字最高位前增加一位新数字。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == digits.length - <span class="number">1</span>) digits[i] -=- <span class="number">1</span>;</span><br><span class="line">            digits[i] -=- c;</span><br><span class="line">            c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] &gt; <span class="number">9</span>)&#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                c = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="number">0</span>, digits[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c != <span class="number">0</span>) list.add(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; to int[]</span></span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211021/ac66.png" alt="ac"></p>
<h1 id="⚪-2021-10-20-453-最小操作次数使数组元素相等"><a href="#⚪-2021-10-20-453-最小操作次数使数组元素相等" class="headerlink" title="⚪ 2021.10.20 (453. 最小操作次数使数组元素相等)"></a>⚪ 2021.10.20 (<a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">453. 最小操作次数使数组元素相等</a>)</h1><p>🟢 未做</p>
<h1 id="🟠-2021-10-19-211-添加与搜索单词"><a href="#🟠-2021-10-19-211-添加与搜索单词" class="headerlink" title="🟠 2021.10.19 (211. 添加与搜索单词)"></a>🟠 2021.10.19 (<a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/" target="_blank" rel="noopener">211. 添加与搜索单词</a>)</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 <code>WordDictionary</code> ：</p>
<ul>
<li><code>WordDictionary()</code> 初始化词典对象</li>
<li><code>void addWord(word)</code> 将 <code>word</code> 添加到数据结构中，之后可以对它进行匹配</li>
<li>bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 ‘.’ ，每个 . 都可以表示任何一个字母。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;WordDictionary&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;addWord&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;,&quot;search&quot;]</span><br><span class="line">[[],[&quot;bad&quot;],[&quot;dad&quot;],[&quot;mad&quot;],[&quot;pad&quot;],[&quot;bad&quot;],[&quot;.ad&quot;],[&quot;b..&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,false,true,true,true]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">WordDictionary wordDictionary = new WordDictionary();</span><br><span class="line">wordDictionary.addWord(&quot;bad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;dad&quot;);</span><br><span class="line">wordDictionary.addWord(&quot;mad&quot;);</span><br><span class="line">wordDictionary.search(&quot;pad&quot;); // return False</span><br><span class="line">wordDictionary.search(&quot;bad&quot;); // return True</span><br><span class="line">wordDictionary.search(&quot;.ad&quot;); // return True</span><br><span class="line">wordDictionary.search(&quot;b..&quot;); // return True</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length &lt;= 500</code></li>
<li><code>addWord</code> 中的 <code>word</code> 由小写英文字母组成</li>
<li><code>search</code> 中的 <code>word</code> 由 ‘.’ 或小写英文字母组成</li>
<li>最多调用 <code>50000</code> 次 <code>addWord</code> 和 <code>search</code></li>
</ul>
<h2 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h2><p>首先容易想到最直接的遍历方法，直接用一个 <code>List</code> 存储添加的 <code>word</code>，在搜索时，首先检查搜索 <code>word</code> 和当前遍历的 <code>List</code> 中的单词的长度，若两者长度不同，则必然不匹配，可以直接跳过。若两者长度相同，则开始逐字母比较两个单词是否相匹配，特别地，对于搜索的 <code>word</code> 中为 <code>.</code> 的位，认为其匹配。</p>
<p>不过这样做在提交后会超时。为了减少遍历的数据量，可以通过以 <code>word</code> 的长度为依据，使用多个 <code>List</code> 存储的办法来实现。如待搜索的的单词长度为 <code>n</code>，那么只需要遍历长度为 <code>n</code> 的单词的 <code>List</code> 即可，而不需要在添加过的所有单词中遍历，进而优化了时间开销。为了实现 <code>List</code> 的按长度分类，使用 <code>HashMap&lt;Integer, List&lt;String&gt;&gt;</code> 即可。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查是否有该长度单词的 List，若没有则为该长度创建一个 List 并将该单词存入</span></span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(word.length(), <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span>)&#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            list.add(word);</span><br><span class="line">            map.put(word.length(), list);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = word.length();</span><br><span class="line">        <span class="comment">// 检查是否有该长度单词的 List，若没有则不可能匹配</span></span><br><span class="line">        List&lt;String&gt; list = map.getOrDefault(length, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 若有该长度的 List，则遍历对应 List，对遍历到的单词进行逐字母比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word.charAt(j) == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(list.get(i).charAt(j) != word.charAt(j))&#123;</span><br><span class="line">                    found = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若有匹配就不必再往后寻找，直接返回匹配成功的结果</span></span><br><span class="line">            <span class="keyword">if</span>(found) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// List 中所有单词没有匹配的，返回匹配失败的结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211019/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-18-476-数字的补数"><a href="#🟢-2021-10-18-476-数字的补数" class="headerlink" title="🟢 2021.10.18 (476. 数字的补数)"></a>🟢 2021.10.18 (<a href="https://leetcode-cn.com/problems/number-complement/" target="_blank" rel="noopener">476. 数字的补数</a>)</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>正</strong> 整数 <code>num</code> ，输出它的补数。补数是对该数的二进制表示取反。</p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定的整数 <code>num</code> 保证在 32 位带符号整数的范围内。</li>
<li><code>num &gt;= 1</code></li>
<li>你可以假定二进制数不包含前导零位。</li>
<li>本题与 1009 <a href="https://leetcode-cn.com/problems/complement-of-base-10-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</li>
</ul>
<h2 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h2><p>非常简单，很容易想到直接取反后会导致符号位的变化，由于题给 <code>num</code> 必是正数，因此取反后符号位必是 <code>1</code>，为了得到正确结果，只需在取反后将符号位置 <code>0</code> 即可。为了找到符号位的位置，显然可以构造一个高位 <code>1</code>，将高位 <code>1</code> 不断右移，从高位到低位找到所给 <code>num</code> 的最高位 1，那么其符号位就在对应最高位 1 的左移一位处。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">while</span>((num&amp;i)==<span class="number">0</span>) i&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ~num&amp;((i&lt;&lt;<span class="number">1</span>)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211018/ac.png" alt="ac"></p>
<h1 id="⚪-2021-10-17"><a href="#⚪-2021-10-17" class="headerlink" title="⚪ 2021.10.17"></a>⚪ 2021.10.17</h1><p>🔴 事务繁忙，无空做</p>
<h1 id="⚪-2021-10-16"><a href="#⚪-2021-10-16" class="headerlink" title="⚪ 2021.10.16"></a>⚪ 2021.10.16</h1><p>🔴 事务繁忙，无空做</p>
<h1 id="🟠-2021-10-15-38-外观数列"><a href="#🟠-2021-10-15-38-外观数列" class="headerlink" title="🟠 2021.10.15 (38. 外观数列)"></a>🟠 2021.10.15 (<a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 外观数列</a>)</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 <code>n</code> ，输出外观数列的第 <code>n</code> 项。</p>
<p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。</p>
<p>你可以将其视作是由递归公式定义的数字字符串序列：</p>
<ul>
<li><code>countAndSay(1) = &quot;1&quot;</code></li>
<li><code>countAndSay(n)</code> 是对 <code>countAndSay(n-1)</code> 的描述，然后转换成另一个数字字符串。</li>
</ul>
<p>前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">第一项是数字 1 </span><br><span class="line">描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 &quot;11&quot;</span><br><span class="line">描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 &quot;21&quot;</span><br><span class="line">描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 &quot;1211&quot;</span><br><span class="line">描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 &quot;111221&quot;</span><br></pre></td></tr></table></figure>
<p>要 <strong>描述</strong> 一个数字字符串，首先要将字符串分割为 <strong>最小</strong> 数量的组，每个组都由连续的最多 <strong>相同字符</strong> 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p>
<p>例如，数字字符串 <code>&quot;3322251&quot;</code> 的描述如下图：</p>
<p><img src="https://pic.leetcode-cn.com/1629874763-TGmKUh-image.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：&quot;1211&quot;</span><br><span class="line">解释：</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = 读 &quot;1&quot; = 一 个 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = 读 &quot;11&quot; = 二 个 1 = &quot;21&quot;</span><br><span class="line">countAndSay(4) = 读 &quot;21&quot; = 一 个 2 + 一 个 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 30</code></li>
</ul>
<h2 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h2><p>以字符串<code>String res = &quot;1&quot;</code> 为初始状态，按照题意以 <code>res = countString(res)</code> 规则递归地“读”出字符串即可。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res = countString(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">countString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> hold = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != hold) &#123;</span><br><span class="line">                sb.append(String.valueOf(count));</span><br><span class="line">                sb.append(hold);</span><br><span class="line">                hold = s.charAt(i);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> count++;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(String.valueOf(count));</span><br><span class="line">        sb.append(hold);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211015/ac38.png" alt="ac"></p>
<h1 id="🟢-2021-10-14-剑指-Offer-II-069-山峰数组的顶部"><a href="#🟢-2021-10-14-剑指-Offer-II-069-山峰数组的顶部" class="headerlink" title="🟢 2021.10.14 (剑指 Offer II 069. 山峰数组的顶部)"></a>🟢 2021.10.14 (<a href="https://leetcode-cn.com/problems/B1IidL/" target="_blank" rel="noopener">剑指 Offer II 069. 山峰数组的顶部</a>)</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>略</p>
<h2 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h2><p>从头开始按顺序找到第一个比后一个数大的数字下标，即是山峰位置。此办法需要遍历数组，故时间复杂度为 $O(n)$。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i] &gt; arr[i+<span class="number">1</span>]) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211014/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-13-412-Fizz-Buzz"><a href="#🟢-2021-10-13-412-Fizz-Buzz" class="headerlink" title="🟢 2021.10.13 (412. Fizz Buzz)"></a>🟢 2021.10.13 (<a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">412. Fizz Buzz</a>)</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>写一个程序，输出从 1 到 <em>n</em> 数字的字符串表示。</p>
<p>\1. 如果 <em>n</em> 是3的倍数，输出“Fizz”；</p>
<p>\2. 如果 <em>n</em> 是5的倍数，输出“Buzz”；</p>
<p>\3. 如果 <em>n</em> 同时是3和5的倍数，输出 “FizzBuzz”。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 15,</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h2><p>按要求写即可，完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res.add((i%<span class="number">3</span>==<span class="number">0</span>&amp;&amp;i%<span class="number">5</span>==<span class="number">0</span>)?<span class="string">"FizzBuzz"</span>:((i%<span class="number">3</span>==<span class="number">0</span>)?<span class="string">"Fizz"</span>:((i%<span class="number">5</span>==<span class="number">0</span>)?<span class="string">"Buzz"</span>:String.valueOf(i))));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211013/ac.png" alt="ac"></p>
<h1 id="🟠-2021-10-12-29-两数相除"><a href="#🟠-2021-10-12-29-两数相除" class="headerlink" title="🟠 2021.10.12 (29. 两数相除)"></a>🟠 2021.10.12 (<a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a>)</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 <code>mod</code> 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<p>整数除法的结果应当截去（<code>truncate</code>）其小数部分，例如：<code>truncate(8.345) = 8</code> 以及 <code>truncate(-2.7335) = -2</code></p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 10, divisor = 3</span><br><span class="line">输出: 3</span><br><span class="line">解释: 10/3 = truncate(3.33333..) = truncate(3) = 3</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。除数不为 0。</li>
</ul>
<h2 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h2><p>使用减法的定义，将被除数不断减去除数，看看够完整减去几次，除的商就是几。不过这题坑的地方是溢出的情况，如 $-2^{31}$ 作为除数，$-1$ 作为被除数，结果就溢出了，此外也存在计算中途的溢出情况，也都是 $-2^{31}$ 作为除数的时候的情况。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l_dividend = dividend;</span><br><span class="line">        <span class="keyword">long</span> l_divisor = divisor;</span><br><span class="line">        <span class="keyword">if</span>(dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isNegtive = (dividend&gt;<span class="number">0</span>&amp;&amp;divisor&lt;<span class="number">0</span>)||(dividend&lt;<span class="number">0</span>&amp;&amp;divisor&gt;<span class="number">0</span>);</span><br><span class="line">        l_dividend = Math.abs(l_dividend);</span><br><span class="line">        l_divisor = Math.abs(l_divisor);</span><br><span class="line">        <span class="keyword">if</span>(l_divisor == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">long</span> _res = isNegtive?-l_dividend:l_dividend;</span><br><span class="line">            <span class="keyword">return</span> (_res &lt; Integer.MIN_VALUE || _res &gt; Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>)_res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> remain = l_dividend;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(remain &gt;= l_divisor)&#123;</span><br><span class="line">            remain -= l_divisor;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegtive?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211012/ac.png" alt="ac"></p>
<h1 id="🔴-2021-10-11-273-整数转换英文表示"><a href="#🔴-2021-10-11-273-整数转换英文表示" class="headerlink" title="🔴 2021.10.11 (273. 整数转换英文表示)"></a>🔴 2021.10.11 (<a href="https://leetcode-cn.com/problems/integer-to-english-words/" target="_blank" rel="noopener">273. 整数转换英文表示</a>)</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>将非负整数 <code>num</code> 转换为其对应的英文表示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 123</span><br><span class="line">输出：&quot;One Hundred Twenty Three&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 12345</span><br><span class="line">输出：&quot;Twelve Thousand Three Hundred Forty Five&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 1234567</span><br><span class="line">输出：&quot;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 1234567891</span><br><span class="line">输出：&quot;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= num &lt;= 231 - 1</code></li>
</ul>
<h2 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h2><p>没有任何技巧，就遍历各种位数各种情况各种表示摁写，憨憨一样写的跟坨啥似的，反正 AC 了。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"Zero"</span>;</span><br><span class="line">        String[] suffix = &#123;<span class="string">""</span>, <span class="string">"Thousand"</span>, <span class="string">"Million"</span>, <span class="string">"Billion"</span>&#125;;</span><br><span class="line">        String[] one = &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>&#125;;</span><br><span class="line">        String[] ten = &#123;<span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">        String[] other = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>&#125;;</span><br><span class="line">        String str = Integer.toString(num);</span><br><span class="line">        StringBuilder resBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// full 3 num</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() / <span class="number">3</span>; i++)&#123;</span><br><span class="line">            String cur = str.substring(str.length()-(i+<span class="number">1</span>)*<span class="number">3</span>, str.length()-<span class="number">3</span>*i);</span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(cur) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">if</span>(cur.charAt(<span class="number">0</span>) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                buffer.append(one[Integer.parseInt(String.valueOf(cur.charAt(<span class="number">0</span>)))]);</span><br><span class="line">                buffer.append(<span class="string">" "</span>);</span><br><span class="line">                buffer.append(<span class="string">"Hundred"</span>);</span><br><span class="line">                buffer.append(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.charAt(<span class="number">1</span>) != <span class="string">'0'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.charAt(<span class="number">1</span>) == <span class="string">'1'</span>)&#123;</span><br><span class="line">                    buffer.append(ten[Integer.parseInt(String.valueOf(cur.charAt(<span class="number">2</span>)))]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; buffer.append(other[Integer.parseInt(String.valueOf(cur.charAt(<span class="number">1</span>)))]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.charAt(<span class="number">1</span>) != <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.charAt(<span class="number">1</span>) != <span class="string">'0'</span> &amp;&amp; cur.charAt(<span class="number">2</span>) != <span class="string">'0'</span>) buffer.append(<span class="string">" "</span>);</span><br><span class="line">                buffer.append(one[Integer.parseInt(String.valueOf(cur.charAt(<span class="number">2</span>)))]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) buffer.append(<span class="string">" "</span>);</span><br><span class="line">            buffer.append(suffix[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) buffer.append(<span class="string">" "</span>);</span><br><span class="line">            resBuilder.insert(<span class="number">0</span>, buffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// unfull 3 num</span></span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(str.length() % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 1 num unfull</span></span><br><span class="line">            buffer.append(one[Integer.parseInt(String.valueOf(str.charAt(<span class="number">0</span>)))]);</span><br><span class="line">            buffer.append(<span class="string">" "</span>);</span><br><span class="line">            buffer.append(suffix[str.length()/<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.length() % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">// 2 num unfull</span></span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">'1'</span>)&#123;</span><br><span class="line">                buffer.append(ten[Integer.parseInt(String.valueOf(str.charAt(<span class="number">1</span>)))]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.append(other[Integer.parseInt(String.valueOf(str.charAt(<span class="number">0</span>)))]);</span><br><span class="line">                <span class="comment">//buffer.append(" ");</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) != <span class="string">'1'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) != <span class="string">'0'</span> &amp;&amp; str.charAt(<span class="number">1</span>) != <span class="string">'0'</span>) buffer.append(<span class="string">" "</span>);</span><br><span class="line">                buffer.append(one[Integer.parseInt(String.valueOf(str.charAt(<span class="number">1</span>)))]);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.append(<span class="string">" "</span>);</span><br><span class="line">            buffer.append(suffix[str.length()/<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.length() % <span class="number">3</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            buffer.append(<span class="string">" "</span>);</span><br><span class="line">            resBuilder.insert(<span class="number">0</span>, buffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resBuilder.toString().replace(<span class="string">"  "</span>, <span class="string">" "</span>).trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211011/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-10-441-排列硬币"><a href="#🟢-2021-10-10-441-排列硬币" class="headerlink" title="🟢 2021.10.10 (441. 排列硬币)"></a>🟢 2021.10.10 (<a href="https://leetcode-cn.com/problems/arranging-coins/" target="_blank" rel="noopener">441. 排列硬币</a>)</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>你总共有 <code>n</code> 枚硬币，并计划将它们按阶梯状排列。对于一个由 <code>k</code> 行组成的阶梯，其第 <code>i</code> 行必须正好有 <code>i</code> 枚硬币。阶梯的最后一行 <strong>可能</strong> 是不完整的。</p>
<p>给你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p>
<p>你一个数字 <code>n</code> ，计算并返回可形成 <strong>完整阶梯行</strong> 的总行数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/dailyProblem/20211010/arrangecoins1-grid.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：因为第三行不完整，所以返回 2 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h2><p>一元二次方程送分题。令</p>
<script type="math/tex; mode=display">
\frac{(1+k)k}{2} = n</script><p>要使得 $k$ 的取值恰好为小于等于 $n$ 的整数，那么显然</p>
<script type="math/tex; mode=display">
k = \lfloor \frac{\sqrt{1+8n}-1}{2} \rfloor</script><p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrangeCoins</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.floor(Math.pow(<span class="number">1</span>+<span class="number">8</span>*(<span class="keyword">long</span>)n,<span class="number">0.5</span>)-<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211010/ac.png" alt="ac"></p>
<p>在编码的时候遇到了一个小插曲，测试的时候有些用例会溢出输出 0，原因是输入数据的取值范围为 $1 \leq n \leq 2^{31} - 1$，而 $n$ 是整型的，因此 $8\times n$ 的上限是 $2^{33} - 8$，依旧作为整型存储的话自然可能会溢出，只需在乘以 $8$ 之前将 $n$ 转为 <code>long</code> 型，使得乘出来的结果也是 <code>long</code> 就行了。</p>
<h1 id="⚪-2021-10-09-352-将数据流变为多个不相交区间"><a href="#⚪-2021-10-09-352-将数据流变为多个不相交区间" class="headerlink" title="⚪ 2021.10.09 (352. 将数据流变为多个不相交区间)"></a>⚪ 2021.10.09 (<a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">352. 将数据流变为多个不相交区间</a>)</h1><p>🔴 不会，也没看题解，没空</p>
<h1 id="🟠-2021-10-08-187-重复的DNA序列"><a href="#🟠-2021-10-08-187-重复的DNA序列" class="headerlink" title="🟠 2021.10.08 (187. 重复的DNA序列)"></a>🟠 2021.10.08 (<a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a>)</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>所有 DNA 都由一系列缩写为 <code>&#39;A&#39;</code>，<code>&#39;C&#39;</code>，<code>&#39;G&#39;</code> 和 <code>&#39;T&#39;</code> 的核苷酸组成，例如：<code>&quot;ACGAATTCCG&quot;</code>。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 <code>s</code> 中出现次数超过一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span><br><span class="line">输出：[&quot;AAAAACCCCC&quot;,&quot;CCCCCAAAAA&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AAAAAAAAAAAAA&quot;</span><br><span class="line">输出：[&quot;AAAAAAAAAA&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 为 <code>&#39;A&#39;</code>、<code>&#39;C&#39;</code>、<code>&#39;G&#39;</code> 或 <code>&#39;T&#39;</code></li>
</ul>
<h2 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h2><p>从头开始遍历所有以 <code>s[i]</code> 为起点长度为 10 的子串 <code>ss</code>，对遍历过程中的所有字串，向后嵌套遍历是否存在以 <code>s[i+j]</code> 为起点长度为 10 与 <code>ss</code> 相同的字串，即为答案，加入答案 List 中，一通操作猛如虎，然后 TLE。</p>
<p>朴素 $O(n^2)$ 超时解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - <span class="number">10</span>; i++)&#123;</span><br><span class="line">            String maybeRes = s.substring(i, i+<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(res.indexOf(maybeRes) != -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// Check whether maybeRes is a result;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= s.length() - <span class="number">10</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maybeRes.equals(s.substring(j, j+<span class="number">10</span>)))&#123;</span><br><span class="line">                    res.add(maybeRes);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211008/tle.png" alt="tle"></p>
<p>如果这题用 JavaScript 做的话很容易想到对象映射的方式实现 $O(n)$，但无奈对 Java 实在不熟。。不知道在 Java 中怎么实现自己的想法，经过了解学习后知道了 Java 中有个存储键值对的 <code>HashMap&lt;&gt;</code> 泛型类，看来是可以用这个实现的。</p>
<p>经过尝试和调试，成功 AC 了，算是通过这题对 Java 类库有点收获了。</p>
<p>完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - <span class="number">10</span>; i++)&#123;</span><br><span class="line">            String maybeRes = s.substring(i, i+<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> count = hashMap.getOrDefault(maybeRes, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">1</span>) res.add(maybeRes);</span><br><span class="line">            hashMap.put(maybeRes, count+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211008/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-07-434-字符串中的单词数"><a href="#🟢-2021-10-07-434-字符串中的单词数" class="headerlink" title="🟢 2021.10.07 (434. 字符串中的单词数)"></a>🟢 2021.10.07 (<a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">434. 字符串中的单词数</a>)</h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p>
<p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello, my name is John&quot;</span><br><span class="line">输出: 5</span><br><span class="line">解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</span><br></pre></td></tr></table></figure>
<h2 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h2><p>设置一个状态记录器 <code>start</code>，遍历字符串中的字符，当字符为非空格时，将状态 <code>start</code> 记录为 <code>true</code>，当字符为空格时，如果 <code>start</code> 为 <code>true</code>，则说明一个单词结束，将计数器自增，并把 <code>start</code> 置回 <code>false</code>，等待下一个单词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSegments</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> start= <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span> &amp;&amp; start) res -=- <span class="number">1</span>;</span><br><span class="line">            start = (c != <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + (start ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211007/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-06-414-第三大的数"><a href="#🟢-2021-10-06-414-第三大的数" class="headerlink" title="🟢 2021.10.06 (414. 第三大的数)"></a>🟢 2021.10.06 (<a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener">414. 第三大的数</a>)</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>给你一个非空数组，返回此数组中 <strong>第三大的数</strong> 。如果不存在，则返回数组中最大的数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[3, 2, 1]</span><br><span class="line">输出：1</span><br><span class="line">解释：第三大的数是 1 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1, 2]</span><br><span class="line">输出：2</span><br><span class="line">解释：第三大的数不存在, 所以返回最大的数 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 2, 3, 1]</span><br><span class="line">输出：1</span><br><span class="line">解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。</span><br><span class="line">此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li>
</ul>
<h2 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h2><p>使用插入排序来维护一个长度为 3 的排序数组即可，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。因为研一上半学期的 Java 课程有一项考核点是用 Java 做 20 道 LC，所以之后也写写 Java 了，完整代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The range of input data contain Integer.MIN_VALUE, so use long here</span></span><br><span class="line">        <span class="keyword">long</span>[] list = &#123;Long.MIN_VALUE, Long.MIN_VALUE, Long.MIN_VALUE&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">                <span class="comment">// Tick only once for same values</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] == list[j]) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// Move smaller num backward for inserting list[j]</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; list[j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &gt; j; k--) list[k] = list[k-<span class="number">1</span>];</span><br><span class="line">                    list[j] = nums[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Check whether there is a third big num</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(list[<span class="number">2</span>] == Long.MIN_VALUE ? list[<span class="number">0</span>] : list[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211006/ac.png" alt="ac"></p>
<h1 id="🟠-2021-10-05-284-窥探迭代器"><a href="#🟠-2021-10-05-284-窥探迭代器" class="headerlink" title="🟠 2021.10.05 (284. 窥探迭代器)"></a>🟠 2021.10.05 (<a href="https://leetcode-cn.com/problems/peeking-iterator/" target="_blank" rel="noopener">284. 窥探迭代器</a>)</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p>
<p>实现 <code>PeekingIterator</code> 类：</p>
<ul>
<li><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。</li>
<li><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。</li>
<li><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
<li><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</li>
</ul>
<h2 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h2><p>没什么好写的，完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the Iterator's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation.</span></span><br><span class="line"><span class="comment"> * function Iterator() &#123;</span></span><br><span class="line"><span class="comment"> *    @ return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> *    this.next = function() &#123; // return the next number of the iterator</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *    &#125;; </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> *    this.hasNext = function() &#123; // return true if it still has numbers</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> *    &#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;Iterator&#125; iterator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> PeekingIterator = <span class="function"><span class="keyword">function</span>(<span class="params">iterator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.iterator = iterator;</span><br><span class="line">    <span class="keyword">this</span>.nextElem = <span class="keyword">this</span>.iterator.next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PeekingIterator.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nextElem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PeekingIterator.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">this</span>.nextElem;</span><br><span class="line">    <span class="keyword">this</span>.nextElem = <span class="keyword">this</span>.iterator.hasNext() ? <span class="keyword">this</span>.iterator.next() : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PeekingIterator.prototype.hasNext = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nextElem != <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211005/ac2.png" alt="ac"></p>
<h1 id="🟢-2021-10-04-482-密钥格式化"><a href="#🟢-2021-10-04-482-密钥格式化" class="headerlink" title="🟢 2021.10.04 (482. 密钥格式化)"></a>🟢 2021.10.04 (<a href="https://leetcode-cn.com/problems/license-key-formatting/" target="_blank" rel="noopener">482. 密钥格式化</a>)</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;5F3Z-2e-9-w&quot;, K = 4</span><br><span class="line">输出：&quot;5F3Z-2E9W&quot;</span><br><span class="line">解释：字符串 S 被分成了两个部分，每部分 4 个字符；</span><br><span class="line">     注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;2-5g-3-J&quot;, K = 2</span><br><span class="line">输出：&quot;2-5G-3J&quot;</span><br><span class="line">解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。</span><br></pre></td></tr></table></figure>
<p><strong>提示:</strong></p>
<ol>
<li>S 的长度可能很长，请按需分配大小。K 为正整数。</li>
<li>S 只包含字母数字（a-z，A-Z，0-9）以及破折号’-‘</li>
<li>S 非空</li>
</ol>
<h2 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h2><p>显然，完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> licenseKeyFormatting = <span class="function"><span class="keyword">function</span>(<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    s = s.split(<span class="string">'-'</span>).join(<span class="string">''</span>).toUpperCase();</span><br><span class="line">    <span class="keyword">var</span> res = [], c = <span class="number">0</span>, rest = s.length % k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> s)&#123;</span><br><span class="line">        res.push(s[i]);</span><br><span class="line">        <span class="keyword">if</span>(((c-rest)%k == k<span class="number">-1</span> || c == rest<span class="number">-1</span>)&amp;&amp;c!=s.length<span class="number">-1</span>) res.push(<span class="string">'-'</span>);</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>).toUpperCase();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211004/ac.png" alt="ac"></p>
<h1 id="🟠-2021-10-03-166-分数到小数"><a href="#🟠-2021-10-03-166-分数到小数" class="headerlink" title="🟠 2021.10.03 (166. 分数到小数)"></a>🟠 2021.10.03 (<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="noopener">166. 分数到小数</a>)</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数，分别表示分数的分子 <code>numerator</code> 和分母 <code>denominator</code>，以 <strong>字符串形式返回小数</strong> 。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<p>如果存在多个答案，只需返回 <strong>任意一个</strong> 。</p>
<p>对于所有给定的输入，<strong>保证</strong> 答案字符串的长度小于 $10^4$ 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numerator = 1, denominator = 2</span><br><span class="line">输出：&quot;0.5&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numerator = 2, denominator = 1</span><br><span class="line">输出：&quot;2&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numerator = 2, denominator = 3</span><br><span class="line">输出：&quot;0.(6)&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-2^31 &lt;= numerator, denominator &lt;= 2^31 - 1</code></li>
<li><code>denominator != 0</code></li>
</ul>
<h2 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h2><p>按除法规则进行除，并记录历史余数，如果余数为 0，说明计算结束，如果余数已经出现过了，说明结果是无限循环小数，可以终止计算，且循环是从余数第一次产生位置的商的后一位开始（后一位是因为，余数是上一次商后的做差结果，是用来给下一次商的，故循环从下一次商开始）。</p>
<p>按照这个模型编码，完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; numerator</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; denominator</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> fractionToDecimal = <span class="function"><span class="keyword">function</span>(<span class="params">numerator, denominator</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// abs x and y, otherwise Math.floor(x/y) may get an unexpected result</span></span><br><span class="line">    <span class="keyword">var</span> negtive = (numerator / denominator) &lt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> res = [], x = <span class="built_in">Math</span>.abs(numerator), y = <span class="built_in">Math</span>.abs(denominator), dev = <span class="number">0</span>, rem = <span class="number">0</span>, remHistory = [], point = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        dev = <span class="built_in">Math</span>.floor(x / y);</span><br><span class="line">        res.push(dev);</span><br><span class="line">        rem = x - dev * y;</span><br><span class="line">        <span class="keyword">if</span>(rem == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!point) &#123; res.push(<span class="string">"."</span>); point = <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span>(remHistory.indexOf(rem) == <span class="number">-1</span>)&#123;</span><br><span class="line">            remHistory.push(rem);</span><br><span class="line">            x = rem * <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rem != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// handle xunhuan</span></span><br><span class="line">        <span class="comment">// next dev is for the position after the rem times 10, so +1, and +1 again for the dot.</span></span><br><span class="line">        res.splice(remHistory.indexOf(rem) + <span class="number">2</span>, <span class="number">0</span>, <span class="string">"("</span>);</span><br><span class="line">        res.push(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(negtive)&#123;</span><br><span class="line">        res.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211003/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-02-405-数字转换为十六进制数"><a href="#🟢-2021-10-02-405-数字转换为十六进制数" class="headerlink" title="🟢 2021.10.02 (405. 数字转换为十六进制数)"></a>🟢 2021.10.02 (<a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/" target="_blank" rel="noopener">405. 数字转换为十六进制数</a>)</h1><h2 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <a href="https://baike.baidu.com/item/补码/6854613?fr=aladdin" target="_blank" rel="noopener">补码运算</a> 方法。</p>
<p><strong>注意:</strong></p>
<ol>
<li>十六进制中所有字母(<code>a-f</code>)都必须是小写。</li>
<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符<code>&#39;0&#39;</code>来表示；对于其他情况，六进制字符串中的第一个字符将不会是0字符。 </li>
<li>给定的数确保在32位有符号整数范围内。</li>
<li><strong>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</strong></li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">26</span><br><span class="line">输出:</span><br><span class="line">&quot;1a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">-1</span><br><span class="line">输出:</span><br><span class="line">&quot;ffffffff&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h2><p>常规的解法是，若数字为负数，那么加上 $2^{32}$ 的偏移量（转为补码），然后不断对 16 取余数，小于 10 的转换为 <code>&#39;0&#39;</code> ~ <code>&#39;9&#39;</code>，大于 10 的转换为 <code>a</code> ~ <code>f</code> 即可。</p>
<p>另外，更加简洁的解法是利用位运算，因为位运算在计算机底层会自动解释为补码运算，因此使用位运算就完全不用管负数补码的事了，直接每四位转十六进制就完事，同时这也是 LC 给的官解。完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> toHex = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">var</span> hexList = [];</span><br><span class="line">    <span class="comment">// parse from high bits, ignore front zero by if(temp &gt; 0 || hexList.length &gt; 0)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp = num &gt;&gt; (i*<span class="number">4</span>) &amp; <span class="number">0xf</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; <span class="number">0</span> || hexList.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> hex = temp &lt; <span class="number">10</span> ? <span class="built_in">String</span>.fromCharCode(<span class="string">'0'</span>.charCodeAt() + temp)</span><br><span class="line">                                : <span class="built_in">String</span>.fromCharCode(<span class="string">'a'</span>.charCodeAt() + temp - <span class="number">10</span>);</span><br><span class="line">            hexList.push(hex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexList.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211002/ac0.png" alt="ac"></p>
<p>不过，既然有这个机会，就重新复习以下机组原码反码补码二进制十六进制转换这些内容。我们首先将数字转成二进制原码，再将原码转为补码，然后对补码按每四位编码为十六进制数，最后切掉前导零，以字符串形式返回即可，就是写起来有点麻烦。</p>
<p>完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; num</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> BIT2HEXLIST = [<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> toHex = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dec2Hex(num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @param &#123;num&#125; decimal number */</span></span><br><span class="line"><span class="keyword">var</span> dec2Hex = <span class="function">(<span class="params">num</span>) =&gt;</span> binary2Hex(complementCode(originalCode(num)));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @param &#123;num&#125; decimal number */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">originalCode</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    (res = []).length = <span class="number">32</span>, i = <span class="number">0</span>;</span><br><span class="line">    res.fill(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// record the symbol</span></span><br><span class="line">    negtive = num &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="literal">undefined</span>;</span><br><span class="line">    num = <span class="built_in">Math</span>.abs(num);</span><br><span class="line">    <span class="comment">// parse to binary code</span></span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        res[i++] = num % <span class="number">2</span>;</span><br><span class="line">        num = <span class="built_in">Math</span>.floor(num/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(negtive) res[<span class="number">31</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* @param &#123;oriCode&#125; bit array with length 32 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complementCode</span>(<span class="params">oriCode</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!oriCode) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// complement code of positive number is original code itself</span></span><br><span class="line">    <span class="keyword">if</span>(oriCode[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> oriCode;</span><br><span class="line">    <span class="comment">// get complement code by inverse bits before the last bit 1</span></span><br><span class="line">    <span class="keyword">var</span> res = [], startInverse = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = oriCode.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(startInverse) res[i] = <span class="number">1</span> - oriCode[i];</span><br><span class="line">        <span class="keyword">else</span> res[i] = oriCode[i];</span><br><span class="line">        <span class="keyword">if</span>(oriCode[i] == <span class="number">1</span>) startInverse = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// negtive number's symbol bit is 1</span></span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @param &#123;binCode&#125; bit array with length 32 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binary2Hex</span>(<span class="params">binCode</span>)</span>&#123;</span><br><span class="line">    res = [];</span><br><span class="line">    <span class="comment">// parse to hex every 4 bits</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binCode.length; i+=<span class="number">4</span>)&#123;</span><br><span class="line">        res[i/<span class="number">4</span>] = BIT2HEXLIST[binCode[i]*<span class="number">8</span> + binCode[i+<span class="number">1</span>]*<span class="number">4</span> + binCode[i+<span class="number">2</span>]*<span class="number">2</span> + binCode[i+<span class="number">3</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find the first bit that isn't zero</span></span><br><span class="line">    <span class="keyword">var</span> sliceIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> res) &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i] != <span class="string">"0"</span>)&#123;</span><br><span class="line">            sliceIndex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// all 0</span></span><br><span class="line">    <span class="keyword">if</span>(!sliceIndex) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="comment">// slice sliceIndex ~ res.length-1 to ignore front zeros</span></span><br><span class="line">    res = res.slice(sliceIndex);</span><br><span class="line">    <span class="comment">// to string</span></span><br><span class="line">    <span class="keyword">return</span> res.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211002/ac.png" alt="ac"></p>
<h1 id="🟢-2021-10-01-1436-旅行终点站"><a href="#🟢-2021-10-01-1436-旅行终点站" class="headerlink" title="🟢 2021.10.01 (1436. 旅行终点站)"></a>🟢 2021.10.01 (<a href="https://leetcode-cn.com/problems/destination-city/" target="_blank" rel="noopener">1436. 旅行终点站</a>)</h1><p><strong>国庆快乐！</strong>🎉🎉🎉</p>
<h2 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h2><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p>
<p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]</span><br><span class="line">输出：&quot;Sao Paulo&quot; </span><br><span class="line">解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[&quot;A&quot;,&quot;Z&quot;]]</span><br><span class="line">输出：&quot;Z&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= paths.length &lt;= 100</code></li>
<li><code>paths[i].length == 2</code></li>
<li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li>
<li><code>cityAi != cityBi</code></li>
<li>所有字符串均由大小写英文字母和空格字符组成。</li>
</ul>
<h2 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h2><p>首先是最直觉的递归，不断寻找下一站，最终找到终点站返回，递归版完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> destCity = <span class="function"><span class="keyword">function</span>(<span class="params">paths</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> destStation(paths[<span class="number">0</span>][<span class="number">0</span>], paths);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destStation</span>(<span class="params">currentStation, paths</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> pair <span class="keyword">of</span> paths)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pair[<span class="number">0</span>] == currentStation) <span class="keyword">return</span> destStation(pair[<span class="number">1</span>], paths);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentStation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211001/ac.png" alt="ac"></p>
<p>这样虽然能 AC，但是不够优雅，每次从头开始遍历 <code>paths</code> 导致 $O(n^2)$ 的时间复杂度，并且递归开栈也造成了 $O(n)$ 的空间复杂度。我们不妨首先遍历一次 <code>paths</code>，在遍历过程中将源地和目的地构造成一对键值对，这样就方便搜索了，虽然还是 $O(n)$ 的空间复杂度，但时间复杂度从 $O(n^2)$ 降到了 $O(n)$。</p>
<p>完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> destCity = <span class="function"><span class="keyword">function</span>(<span class="params">paths</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> mem = [], res = paths[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> pair <span class="keyword">of</span> paths) mem[pair[<span class="number">0</span>]] = pair[<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">while</span>(mem[res]) res = mem[res];</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20211001/ac2.png" alt="ac"></p>
<h1 id="🟠-2021-09-30-223-矩形面积"><a href="#🟠-2021-09-30-223-矩形面积" class="headerlink" title="🟠 2021.09.30 (223. 矩形面积)"></a>🟠 2021.09.30 (<a href="https://leetcode-cn.com/problems/rectangle-area/" target="_blank" rel="noopener">223. 矩形面积</a>)</h1><h2 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h2><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong> 矩形，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>
<ul>
<li>第一个矩形由其左下顶点 <code>(ax1, ay1)</code> 和右上顶点 <code>(ax2, ay2)</code> 定义。</li>
<li>第二个矩形由其左下顶点 <code>(bx1, by1)</code> 和右上顶点 <code>(bx2, by2)</code> 定义。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="/dailyProblem/20210930/rectangle-plane.png" alt="rectangle-plane"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2</span><br><span class="line">输出：45</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><p><code>-104 &lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 &lt;= 104</code></p>
<h2 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h2></li>
</ul>
<p>首先计算两个矩形的面积之和</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> all = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);</span><br></pre></td></tr></table></figure>
<p>然后考虑重合部分，特别地，当一个矩形的右边在另一个矩形的左侧等情况时，两个矩形是没有重合部分的，即：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ax2 &lt;= bx1 || ax1 &gt;= bx2 || ay1 &gt;= by2 || ay2 &lt;= by1) <span class="keyword">return</span> all;</span><br></pre></td></tr></table></figure>
<p>对于重合部分，只需要找到重合矩形的左上角和右下角即可，该坐标不难计算，详见完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computeArea = <span class="function"><span class="keyword">function</span>(<span class="params">ax1, ay1, ax2, ay2, bx1, by1, bx2, by2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> all = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);</span><br><span class="line">    <span class="keyword">if</span>(ax2 &lt;= bx1 || ax1 &gt;= bx2 || ay1 &gt;= by2 || ay2 &lt;= by1) <span class="keyword">return</span> all;</span><br><span class="line">    <span class="comment">// cal overlap area</span></span><br><span class="line">    <span class="keyword">var</span> cx1 = <span class="built_in">Math</span>.max(ax1, bx1);</span><br><span class="line">    <span class="keyword">var</span> cx2 = <span class="built_in">Math</span>.min(ax2, bx2);</span><br><span class="line">    <span class="keyword">var</span> cy1 = <span class="built_in">Math</span>.max(ay1, by1);</span><br><span class="line">    <span class="keyword">var</span> cy2 = <span class="built_in">Math</span>.min(ay2, by2);</span><br><span class="line">    <span class="keyword">var</span> overlap = (cx2 - cx1) * (cy2 - cy1);</span><br><span class="line">    <span class="keyword">return</span> all - overlap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210930/ac.png" alt="ac"></p>
<h1 id="🔴-2021-09-29-517-超级洗衣机"><a href="#🔴-2021-09-29-517-超级洗衣机" class="headerlink" title="🔴 2021.09.29 (517. 超级洗衣机)"></a>🔴 2021.09.29 (<a href="https://leetcode-cn.com/problems/super-washing-machines/" target="_blank" rel="noopener">517. 超级洗衣机</a>)</h1><h2 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h2><p>假设有 <code>n</code> 台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。</p>
<p>在每一步操作中，你可以选择任意 <code>m</code> (<code>1 &lt;= m &lt;= n</code>) 台洗衣机，与此同时将每台洗衣机的一件衣服送到相邻的一台洗衣机。</p>
<p>给定一个整数数组 <code>machines</code> 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 <strong>最少的操作步数</strong> 。如果不能使每台洗衣机中衣物的数量相等，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：machines = [1,0,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第一步:    1     0 &lt;-- 5    =&gt;    1     1     4</span><br><span class="line">第二步:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    </span><br><span class="line">第三步:    2     1 &lt;-- 3    =&gt;    2     2     2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：machines = [0,3,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">第一步:    0 &lt;-- 3     0    =&gt;    1     2     0    </span><br><span class="line">第二步:    1     2 --&gt; 0    =&gt;    1     1     1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == machines.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= machines[i] &lt;= 105</code></li>
</ul>
<h2 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h2><p>一天学完了 JS，接下来要两天速通 Vue 了，没空写题解辽。</p>
<p>$O(n^3)$ 暴力超时代码（困难题果然还是不能暴力的呢）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; machines</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinMoves = <span class="function"><span class="keyword">function</span>(<span class="params">machines</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clothesCount = <span class="number">0</span>;</span><br><span class="line">    machines.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;clothesCount+=value;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(clothesCount % machines.length != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// find a min move way</span></span><br><span class="line">    <span class="keyword">var</span> avrCount = clothesCount / machines.length;</span><br><span class="line">    <span class="keyword">var</span> minMoves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isBanlance(machines, avrCount))&#123;</span><br><span class="line">        <span class="comment">// check every machine's both side</span></span><br><span class="line">        <span class="comment">// if one side lack and self own clothes, then give clothes to the lacked side</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; machines.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(machines[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> lack = isBothSideLack(i, machines, avrCount);</span><br><span class="line">                <span class="keyword">if</span>(lack[<span class="number">0</span>] == <span class="number">1</span>) &#123; machines[i]--; machines[i<span class="number">-1</span>]++; &#125;</span><br><span class="line">                <span class="comment">// can only give clothes to one of sides, so use else syntax</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(lack[<span class="number">1</span>] == <span class="number">1</span>) &#123; machines[i]--; machines[i+<span class="number">1</span>]++; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minMoves++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minMoves;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBothSideLack</span>(<span class="params">index, machines, avrCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> leftBanlanceCount = index * avrCount;</span><br><span class="line">    <span class="keyword">var</span> rightBanlanceCount = (machines.length - index - <span class="number">1</span>) * avrCount;</span><br><span class="line">    <span class="keyword">var</span> leftCount = <span class="number">0</span>, rightCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> lack = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; index; i++) leftCount += machines[i];</span><br><span class="line">    <span class="keyword">if</span>(leftCount &lt; leftBanlanceCount) lack[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = index + <span class="number">1</span>; i &lt; machines.length; i++) rightCount += machines[i];</span><br><span class="line">    <span class="keyword">if</span>(rightCount &lt; rightBanlanceCount) lack[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> lack;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBanlance</span>(<span class="params">machines, avrCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> machines)&#123; <span class="keyword">if</span>(value != avrCount) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210929/image-20210929115247903.png" alt="image-20210929115247903"></p>
<p>$O(n)$ AC 完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; machines</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMinMoves = <span class="function"><span class="keyword">function</span>(<span class="params">machines</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clothesCount = <span class="number">0</span>;</span><br><span class="line">    machines.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;clothesCount+=value;&#125;);</span><br><span class="line">    <span class="keyword">if</span>(clothesCount % machines.length != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// find a min move way</span></span><br><span class="line">    <span class="keyword">var</span> avrCount = clothesCount / machines.length;</span><br><span class="line">    <span class="keyword">var</span> lackList = [];</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get delta list</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; machines.length; i++)&#123;</span><br><span class="line">        lackList[i] = machines[i] - avrCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; machines.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">Math</span>.abs(lackList[i]) &gt; res)) res = <span class="built_in">Math</span>.abs(lackList[i]);</span><br><span class="line">        <span class="keyword">if</span>(lackList[i+<span class="number">1</span>] &gt; res) res = lackList[i+<span class="number">1</span>];</span><br><span class="line">        lackList[i+<span class="number">1</span>] += lackList[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210929/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-28-437-路径总和-III"><a href="#🟠-2021-09-28-437-路径总和-III" class="headerlink" title="🟠 2021.09.28 (437. 路径总和 III)"></a>🟠 2021.09.28 (<a href="https://leetcode-cn.com/problems/path-sum-iii/submissions/" target="_blank" rel="noopener">437. 路径总和 III</a>)</h1><h2 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/dailyProblem/20210928/pathsum3-1-tree.jpg" alt="ac"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>
<h2 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h2><p>暴力解，双重遍历。遍历树的所有节点，并对每个节点遍历以该节点为 <code>root</code> 的树到所有节点的路径 <code>val</code> ，对于路径 <code>val</code> 为 <code>targetSum</code> 的情况，自增全局计数器 <code>res</code>。</p>
<p>完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> pathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，必须在入口函数初始化全局变量，因为 LC 多个用例执行只会初始化一次全局变量，</span></span><br><span class="line">    <span class="comment">// 也就是后续的全局变量初始值就不是 0 了，就是这个原因导致同一个用例在执行代码时通过，</span></span><br><span class="line">    <span class="comment">// 但在提交时执行不通过的诡异现象，被 WA 了两次呜呜呜</span></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    dfsNodes(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 遍历从每个节点起始的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsNodes</span>(<span class="params">root, targetSum</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    dfs(root, targetSum, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) dfsNodes(root.left, targetSum);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) dfsNodes(root.right, targetSum);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 遍历从dfsNodes传入节点到后续所有节点的累加和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">root, targetSum, lastSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> currentSum = lastSum + root.val;</span><br><span class="line">    <span class="keyword">if</span>(targetSum == currentSum) res++;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) dfs(root.left, targetSum, currentSum);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) dfs(root.right, targetSum, currentSum);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210927/ac.png" alt="ac"></p>
<h1 id="⚪-2021-09-27-639-解码方法-II"><a href="#⚪-2021-09-27-639-解码方法-II" class="headerlink" title="⚪ 2021.09.27 (639. 解码方法 II)"></a>⚪ 2021.09.27 (<a href="https://leetcode-cn.com/problems/decode-ways-ii/" target="_blank" rel="noopener">639. 解码方法 II</a>)</h1><p>🔴 速通 JavaScript 去了，未做</p>
<h1 id="⚫-2021-09-26-371-两整数之和"><a href="#⚫-2021-09-26-371-两整数之和" class="headerlink" title="⚫ 2021.09.26 (371. 两整数之和)"></a>⚫ 2021.09.26 (<a href="https://leetcode-cn.com/problems/sum-of-two-integers/" target="_blank" rel="noopener">371. 两整数之和</a>)</h1><p>🟠 未更新</p>
<h1 id="🟠-2021-09-25-583-两个字符串的删除操作"><a href="#🟠-2021-09-25-583-两个字符串的删除操作" class="headerlink" title="🟠 2021.09.25 (583. 两个字符串的删除操作)"></a>🟠 2021.09.25 (<a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a>)</h1><h2 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h2><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>给定单词的长度不超过500。</li>
<li>给定单词中的字符只含有小写字母。</li>
</ol>
<h2 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h2><p>本题不难想到转化为求解最长公共子序列长度问题。</p>
<p>最长公共子序列，可以用动态规划来解。定义 <code>dp[i, j]</code> 表示<code>word1</code> 前 <code>i</code> 个字符和 <code>word2</code> 前 <code>j</code> 个字符的最长公共子序列长度。那么则有如下状态转移：</p>
<ul>
<li>若 <code>word1[i] == word2[j]</code> 则显然 <code>dp[i, j] = dp[i-1, j-1] + 1</code>，表示将当前比较的位加入到前一次的最长公共子序列长度中；</li>
<li>若 <code>word1[i] == word2[j]</code> ，则继承两种上一状态中长度较长的那个长度作为最长长度，即 <code>dp[i, j] = Max(dp[i-1, j], dp[i, j-1])</code>。</li>
</ul>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinDistance</span>(<span class="params"><span class="keyword">string</span> word1, <span class="keyword">string</span> word2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.Length, n = word2.Length;</span><br><span class="line">        <span class="keyword">int</span>[,] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m, n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] == word2[j]) dp[i,j] = (i==<span class="number">0</span>||j==<span class="number">0</span>)?<span class="number">1</span>:dp[i<span class="number">-1</span>,j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(word1[i] != word2[j]) dp[i,j] = Math.Max(i&gt;<span class="number">0</span>?dp[i<span class="number">-1</span>,j]:<span class="number">0</span>, j&gt;<span class="number">0</span>?dp[i,j<span class="number">-1</span>]:<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m - dp[m<span class="number">-1</span>,n<span class="number">-1</span>] + n - dp[m<span class="number">-1</span>,n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210925/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-24-430-扁平化多级双向链表"><a href="#🟠-2021-09-24-430-扁平化多级双向链表" class="headerlink" title="🟠 2021.09.24 (430. 扁平化多级双向链表)"></a>🟠 2021.09.24 (<a href="https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/" target="_blank" rel="noopener">430. 扁平化多级双向链表</a>)</h1><h2 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h2><p>多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。</p>
<p>给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]<br>输出：[1,2,3,7,8,11,12,9,10,4,5,6]<br>解释：</p>
<p>输入的多级列表如下图所示：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlist.png" alt="img"></p>
<p>扁平化后的链表如下图：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/multilevellinkedlistflattened.png" alt="img"></p>
</blockquote>
<p>示例 2：</p>
<blockquote>
<p>输入：head = [1,2,null,3]<br>输出：[1,3,2]<br>解释：</p>
<p>输入的多级列表如下图所示：</p>
<p> 1—-2—-NULL<br> |<br> 3—-NULL</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>节点数目不超过 1000</li>
<li><code>1 &lt;= Node.val &lt;= 10^5</code></li>
</ul>
<h2 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h2><p>朴素的办法，遍历，遇到有子节点的，就找到子节点那层的最后一个节点，然后捏住首位将整个子节点这层插上来。缺点是每个子层会被遍历两次（找子层尾节点遍历一次，并入住层后继续遍历就被重复遍历了），所以复杂度是 $O(n^2)$，完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Flatten</span>(<span class="params">Node head</span>) </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// have child</span></span><br><span class="line">            <span class="keyword">if</span>(p.child != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// find the last node of the layer of child</span></span><br><span class="line">                Node lastNodeOfChild = GetTheLastNode(p.child);</span><br><span class="line">                <span class="comment">// merge child layer</span></span><br><span class="line">                <span class="keyword">if</span>(p.next != <span class="literal">null</span>) p.next.prev = lastNodeOfChild;</span><br><span class="line">                lastNodeOfChild.next = p.next;</span><br><span class="line">                p.next = p.child;</span><br><span class="line">                p.child.prev = p;</span><br><span class="line">                p.child = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">GetTheLastNode</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line">        Node p = node;</span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="literal">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210924/ac.png" alt="ac"></p>
<p>但更好的办法是递归，这样可以做到 $O(n)$ 的时间复杂度。完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Flatten</span>(<span class="params">Node head</span>) </span>&#123;</span><br><span class="line">        Merge(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Merge</span>(<span class="params">Node head</span>)</span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.child != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Node lastNodeOfChild = Merge(p.child);</span><br><span class="line">                <span class="comment">// merge child layer</span></span><br><span class="line">                <span class="keyword">if</span>(p.next != <span class="literal">null</span>) p.next.prev = lastNodeOfChild;</span><br><span class="line">                lastNodeOfChild.next = p.next;</span><br><span class="line">                p.next = p.child;</span><br><span class="line">                p.child.prev = p;</span><br><span class="line">                p.child = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> == p.next) <span class="keyword">return</span> p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210924/ac2.png" alt="ac"></p>
<h1 id="🟢-2021-09-23-326-3的幂"><a href="#🟢-2021-09-23-326-3的幂" class="headerlink" title="🟢 2021.09.23 (326. 3的幂)"></a>🟢 2021.09.23 (<a href="https://leetcode-cn.com/problems/power-of-three/submissions/" target="_blank" rel="noopener">326. 3的幂</a>)</h1><h2 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>整数 <code>n</code> 是 3 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 3x</code></p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 27</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h2 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h2><p>直接递归之。完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsPowerOfThree</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">3</span>!=<span class="number">0</span>?<span class="literal">false</span>:IsPowerOfThree(n/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210923/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-22-725-分隔链表"><a href="#🟠-2021-09-22-725-分隔链表" class="headerlink" title="🟠 2021.09.22 (725. 分隔链表)"></a>🟠 2021.09.22 (<a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/" target="_blank" rel="noopener">725. 分隔链表</a>)</h1><h2 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h2><p>给你一个头结点为 <code>head</code> 的单链表和一个整数 <code>k</code> ，请你设计一个算法将链表分隔为 <code>k</code> 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。</p>
<p>这 <code>k</code> 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。</p>
<p>返回一个由上述 <code>k</code> 部分组成的数组。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3], k = 5</span><br><span class="line">输出：[[1],[2],[3],[],[]]</span><br><span class="line">解释：</span><br><span class="line">第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。</span><br><span class="line">最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5,6,7,8,9,10], k = 3</span><br><span class="line">输出：[[1,2,3,4],[5,6,7],[8,9,10]]</span><br><span class="line">解释：</span><br><span class="line">输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 1000]</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
<h2 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h2><p>又是直觉题。显然计算 <code>链表长度</code> / <code>分割数量</code> 即是可被均分的每个 <code>section</code> 中的基础节点数量，而 <code>链表长度</code> % <code>分割数量</code> 即是均分后剩下来的节点数，由于要求 “任意两部分的长度差距不能超过 1”并且“排在前面的部分的长度应该大于或等于排在后面的长度”，因此将剩下的节点数往前面的 section 中加即可，每个 <code>section</code> 塞一个节点数。</p>
<p>如初始链表有 17 个节点，要均分成 <code>k = 3</code> 份（3 个 section），那么每个 <code>section</code> 就有 <code>17 / 3 = 5</code> 个基础节点个数，不过这样就会多出来 <code>17 % 3 = 2</code> 个节点，只要往前 2 个 <code>section</code> 中多放一个节点即可得到 <code>6 6 5</code> 的正确分割长度。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode[] <span class="title">SplitListToParts</span>(<span class="params">ListNode head, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// float pointer</span></span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="comment">// result list</span></span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        <span class="comment">// length of list</span></span><br><span class="line">        <span class="keyword">int</span> length = GetLengthOfLinkList(head);</span><br><span class="line">        <span class="keyword">if</span>(length &lt; k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = <span class="keyword">new</span> ListNode(p.val, <span class="literal">null</span>);</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> basicElementCountOfSection = length / k;</span><br><span class="line">            <span class="keyword">int</span> countOfSectionNeedExtra = length % k;</span><br><span class="line">            <span class="comment">// cut list to k sections</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// head of section</span></span><br><span class="line">                ListNode sectionP = p;</span><br><span class="line">                <span class="comment">// end of section</span></span><br><span class="line">                ListNode secitonE = sectionP;</span><br><span class="line">                res[i] = sectionP;</span><br><span class="line">                <span class="comment">// section i need to contain length/k nodes firstly</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; basicElementCountOfSection - <span class="number">1</span>; j++) secitonE = secitonE.next;</span><br><span class="line">                <span class="comment">// then contain 1 posible extra node to the front sections</span></span><br><span class="line">                <span class="keyword">if</span>(countOfSectionNeedExtra != <span class="number">0</span>) &#123; secitonE = secitonE.next; countOfSectionNeedExtra--; &#125;</span><br><span class="line">                <span class="comment">// swich p to next section head</span></span><br><span class="line">                p = secitonE.next;</span><br><span class="line">                <span class="comment">// cut to get the section</span></span><br><span class="line">                secitonE.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetLengthOfLinkList</span>(<span class="params">ListNode head</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210922/ac.png" alt="ac"></p>
<h1 id="🟢-2021-09-21-58-最后一个单词的长度"><a href="#🟢-2021-09-21-58-最后一个单词的长度" class="headerlink" title="🟢 2021.09.21 (58. 最后一个单词的长度)"></a>🟢 2021.09.21 (<a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a>)</h1><h2 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。</p>
<p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li>
<li><code>s</code> 中至少存在一个单词</li>
</ul>
<h2 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h2><p><strong>中秋快乐！🎑</strong></p>
<p>直接倒着找到最后一个单词的最后一个字母，然后触发一个 <code>start</code> 触发器开始记录长度，直至记录到最后一个单词前的第一个空格返回记录的长度即可。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LengthOfLastWord</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> started = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">' '</span>) &#123; started = <span class="literal">true</span>; res++; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(started) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以直接用库函数一行代码解决：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LengthOfLastWord</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>=&gt; s.Trim().Split(<span class="string">" "</span>).Last().Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210921/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-20-673-最长递增子序列的个数"><a href="#🟠-2021-09-20-673-最长递增子序列的个数" class="headerlink" title="🟠 2021.09.20 (673. 最长递增子序列的个数)"></a>🟠 2021.09.20 (<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a>)</h1><h2 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p>
<h2 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h2><p>因为还没有学动态规划，因此最先想到的还是暴力遍历。定义函数 <code>void FindNextNumber(int[] nums, int lastIndex, int currentIndex, int lastLength)</code> 表示从上一数字找下一个可接的递增数字，其中对于 <code>currentIndex</code> 数大于 <code>lastIndex</code> 数的时候，表明可以接，将 <code>lastLength</code> +1 后继续往后找。</p>
<p>不过无论是否满足上面说的情况，都应该走一遍跳过当前数字的路径，确保不漏数。</p>
<p>如示例 1 的 <code>[1,3,5,4,7]</code>，其中 <code>5</code> 可以接在 <code>3</code> 后面，但也应尝试跳过 <code>5</code>，才能捕获到 <code>[1,3,4,7]</code> 这一同样是最长递增的子序列。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> maxLengh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindNumberOfLIS</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// list start from nums[i]</span></span><br><span class="line">            FindNextNumber(nums, i, i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNextNumber</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> lastIndex, <span class="keyword">int</span> currentIndex, <span class="keyword">int</span> lastLength</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// scan to the end</span></span><br><span class="line">        <span class="keyword">if</span>(currentIndex == nums.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// find a longer list</span></span><br><span class="line">            <span class="keyword">if</span>(lastLength &gt; maxLengh)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLengh = lastLength;</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(lastLength == maxLengh) maxCount++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// skip current number no matter its bigger than the last number</span></span><br><span class="line">        FindNextNumber(nums, lastIndex, currentIndex + <span class="number">1</span>, lastLength);</span><br><span class="line">        <span class="keyword">if</span>(nums[currentIndex] &gt; nums[lastIndex])</span><br><span class="line">            FindNextNumber(nums, currentIndex, currentIndex + <span class="number">1</span>, lastLength + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说了这么多，但这个暴力解法在序列合适的情况下是会超时的。。。</p>
<p><img src="/dailyProblem/20210920/tle.png" alt=""></p>
<hr>
<p><strong>Update：</strong></p>
<p>喵了一眼 LC 的题解，大概看懂了本题动态规划的思路。首先我们可以设置两个数组：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f[i]: the max length end with nums[i]</span></span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line"><span class="comment">// g[i,k]: the count of lenth k end with nums[i]</span></span><br><span class="line"><span class="keyword">int</span>[,] g= <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length, nums.Length + <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>其中 <code>f[i]</code> 记录以 <code>nums[i]</code> 为结尾的上升子序列的最大长度，<code>g[i, k]</code> 记录以 <code>nums[i]</code> 为结尾的上升子序列长度为 <code>k</code> 的序列个数。</p>
<p>初始时，数组 <code>f</code> 的值应全为 1，表示可以独立构成长度为 1 的上升子序列，进而 <code>g[:,1]</code>  也全为 1。</p>
<p>设置指针 <code>i</code> 从头往尾扫描，指针 <code>j</code> 从头扫描至 <code>i-1</code>，判断 <code>nums[i]</code> 能否接在 <code>nums[j]</code> 的后面，构成一个上升子序列。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// self length is 1 and initialize max length with 1</span></span><br><span class="line">    g[i,<span class="number">1</span>] = f[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">        <span class="comment">// nums[i] can be connected behind nums[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若能构成上升子序列，那么说明以 <code>nums[i]</code> 结尾能够构成长度为 <code>f[j] + 1</code> 的递增子序列，并且构成的长度为 <code>f[j] + 1</code> 的子序列的个数是 <code>nums[i]</code> 同之前元素能构成长度为 <code>f[j] + 1</code> 的递增子序列的个数再加上被接上的 <code>nums[j]</code> 能构成长度为 <code>f[j]</code> 的子序列个数（如 <code>1 3 5</code>，5 能接在 3 后面，那么以 3 结尾能构成几个长度为 2 的序列，就也能以 5 结尾构成几个长度为 3 的序列）。同时，<code>f[i]</code> 应被更新为长度更长的 <code>f[j] + 1</code>，否则 <code>f[i]</code> 保持不变，确保存储的是能够构成的最长子序列长度。按照该逻辑，第 10 行处代码就为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g[i, f[j] + <span class="number">1</span>] += g[j, f[j]];</span><br><span class="line">f[i] = Math.Max(f[i], f[j] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>当整个扫描结束后，<code>f</code> 中就存储了分别以各个元素为结尾能构成的递增子序列的最长长度，<code>g</code> 中就存储了以各个元素为结尾能构成长度为 <code>1 ~ nums.Length</code> 的上升子序列的个数。</p>
<p>显然，要返回最长递增子序列的个数，只需要先用 <code>f</code> 找到最长的长度 <code>k</code>，然后从 <code>g</code> 中累加所有的 <code>g[:,k]</code> 即可。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindNumberOfLIS</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// f[i]: the max length end with nums[i]</span></span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length];</span><br><span class="line">        <span class="comment">// g[i,k]: the count of lenth k end with nums[i]</span></span><br><span class="line">        <span class="keyword">int</span>[,] g= <span class="keyword">new</span> <span class="keyword">int</span>[nums.Length, nums.Length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// self length is 1 and initialize max length with 1</span></span><br><span class="line">            g[i,<span class="number">1</span>] = f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])</span><br><span class="line">                <span class="comment">// nums[i] can be connected behind nums[j]</span></span><br><span class="line">                &#123;</span><br><span class="line">                    g[i, f[j] + <span class="number">1</span>] += g[j, f[j]];</span><br><span class="line">                    f[i] = Math.Max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find the max length</span></span><br><span class="line">        <span class="keyword">int</span> maxLength = f.Max();</span><br><span class="line">        <span class="comment">// sum max length count</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += g[i, maxLength];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以原始序列 <code>[1,3,5,4,7,4,8,9]</code> 为例，运行结束后各变量的状态如下图所示，大体上，变量 <code>g</code> 从上至下，从左至右迭代，可供辅助手推理解。</p>
<p><img src="/dailyProblem/20210920/2021-09-20 163718.png" alt=""></p>
<p><img src="/dailyProblem/20210920/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-19-650-只有两个键的键盘"><a href="#🟠-2021-09-19-650-只有两个键的键盘" class="headerlink" title="🟠 2021.09.19 (650. 只有两个键的键盘)"></a>🟠 2021.09.19 (<a href="https://leetcode-cn.com/problems/2-keys-keyboard/" target="_blank" rel="noopener">650. 只有两个键的键盘</a>)</h1><h2 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h2><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code> 。你每次可以对这个记事本进行两种操作：</p>
<ul>
<li><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。</li>
<li><code>Paste</code>（粘贴）：粘贴 <strong>上一次</strong> 复制的字符。</li>
</ul>
<p>给你一个数字 <code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong> <code>n</code> 个 <code>&#39;A&#39;</code> 。返回能够打印出 <code>n</code> 个 <code>&#39;A&#39;</code> 的最少操作次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">最初, 只有一个字符 &apos;A&apos;。</span><br><span class="line">第 1 步, 使用 Copy All 操作。</span><br><span class="line">第 2 步, 使用 Paste 操作来获得 &apos;AA&apos;。</span><br><span class="line">第 3 步, 使用 Paste 操作来获得 &apos;AAA&apos;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<h2 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h2><p>首先第一直觉尝试了遍历操作，DFS配合剪枝，不过发现59及更大的奇数用例大部分超时了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DFS + 剪枝（部分奇数用例超时） */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> minStep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSteps</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == n) <span class="keyword">return</span> minStep;</span><br><span class="line">        target = n;</span><br><span class="line">        Operate(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> minStep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// op: 0. Copy, 1. Paste</span></span><br><span class="line">    <span class="comment">// step: current step, not last step</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Operate</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">int</span> op, <span class="keyword">int</span> copied, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(minStep &gt; <span class="number">0</span> &amp;&amp; step &gt;= minStep) <span class="keyword">return</span>; <span class="comment">// cut</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// copy</span></span><br><span class="line">            copied = n;</span><br><span class="line">            <span class="keyword">if</span>(copied &gt;= target) <span class="keyword">return</span>; <span class="comment">// cut</span></span><br><span class="line">            <span class="comment">// next operate paste</span></span><br><span class="line">            Operate(n, <span class="number">1</span>, copied, step+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// or copy</span></span><br><span class="line">            Operate(n, <span class="number">0</span>, copied, step+<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// paste</span></span><br><span class="line">            n += copied;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; target) <span class="keyword">return</span>; <span class="comment">// cut</span></span><br><span class="line">            <span class="keyword">if</span>(n == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minStep == <span class="number">0</span> || step &lt; minStep) </span><br><span class="line">                &#123;</span><br><span class="line">                    minStep = step;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// next operate paste</span></span><br><span class="line">            Operate(n, <span class="number">1</span>, copied, step+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// or copy</span></span><br><span class="line">            Operate(n, <span class="number">0</span>, copied, step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210919/image-20210919110014978.png" alt="image-20210919110014978"></p>
<center>用例 1000</center>

<p><img src="/dailyProblem/20210919/image-20210919110109228.png" alt="image-20210919110109228"></p>
<center>用例 59 超时</center>

<p>有可能是剪枝不到位，或者数据量太大，此法不可行？总之在这个方向上没做出来。后看了提示之后想到了分解因式完全可以解决此题。</p>
<blockquote>
<p>How many characters may be there in the clipboard at the last step if n = 3? n = 7? n = 10? n = 24?</p>
</blockquote>
<p>以提示中的 <code>n = 24</code> 为例，由于 2、4、6、8、12 都是 24 的因数，而要使得操作步数最少，必然粘贴的字符数应该尽可能多，那么显然当取 12 个字符粘贴时能够实现更少的复制粘贴次数。因此，只需要寻找 n 的最大因数，然后不断进一步寻找其最大因数的最大的因数，直至最大因数（1除外）是自身时，说明此数是从最开始的一个 A 连续复制得到的。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MinSteps</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>, rest = n;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">from</span> = FindMaxFactor(rest);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">from</span> != rest)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// current rest is generated from pasting `from` (rest/from) times</span></span><br><span class="line">                step += rest/<span class="keyword">from</span>;</span><br><span class="line">                rest = <span class="keyword">from</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step += rest;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindMaxFactor</span>(<span class="params"><span class="keyword">int</span> n</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// ignore the case i == 1 and return n can make the code in MinSteps neater</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">1</span>; i--) <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210919/ac.png" alt="image-20210919113907617"></p>
<h1 id="🟢-2021-09-18-292-Nim-游戏"><a href="#🟢-2021-09-18-292-Nim-游戏" class="headerlink" title="🟢 2021.09.18 (292. Nim 游戏)"></a>🟢 2021.09.18 (<a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">292. Nim 游戏</a>)</h1><h2 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h2><p>你和你的朋友，两个人一起玩 <a href="https://baike.baidu.com/item/Nim游戏/6737105" target="_blank" rel="noopener">Nim 游戏</a>：</p>
<ul>
<li>桌子上有一堆石头。</li>
<li>你们轮流进行自己的回合，你作为先手。</li>
<li>每一回合，轮到的人拿掉 1 - 3 块石头。</li>
<li>拿掉最后一块石头的人就是获胜者。</li>
</ul>
<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 <code>n</code> 的情况下赢得游戏。如果可以赢，返回 <code>true</code>；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：false</span><br><span class="line">解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h2 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h2><p>由题目描述“你们每一步都是最优解”可以发现，示例1的必败情况就是本题的突破口。即双方都只需要将对手引导至剩余4块石头的局面，那么就是最优的取法。那么如何使对手剩下4块呢？其实只需将石头块数对4取余，即将4的倍数多余出来的石头拿走，这样对手就永远处于从4的倍数中取石头的境况中，而随着石头越取越少，倍数越来越小，最终对手必然剩下4的1倍，即4块石头。可见，胜负从开局石头数就已经定了。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CanWinNim</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210918/ac.png" alt="ac"></p>
<h1 id="🟠-2021-09-17-36-有效的数独"><a href="#🟠-2021-09-17-36-有效的数独" class="headerlink" title="🟠 2021.09.17 (36. 有效的数独)"></a>🟠 2021.09.17 (<a href="https://leetcode-cn.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. 有效的数独</a>)</h1><h2 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h2><p>请你判断一个 <code>9x9</code> 的数独是否有效。只需要 <strong>根据以下规则</strong> ，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：board =<br>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”]<br>,[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”]<br>,[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”]<br>,[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”]<br>,[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”]<br>,[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”]<br>,[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”]<br>,[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”]<br>,[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：true</p>
</blockquote>
<h2 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h2><p>根据数独有效性的三条规则，可以分别定义三个记忆变量，记录在某行处某数字是否出现过、在某列处某数字是否出现过、在某区域（九个粗格）内某数字是否出现过。遍历数独数字，若任三条中任一条出现过则数独无效，若遍历完所有格都没有出现过，则数独有效。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidSudoku</span>(<span class="params"><span class="keyword">char</span>[][] board</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// existedInArea[a,b] 在区域 a 内数字 b 是否出现过</span></span><br><span class="line">        <span class="keyword">bool</span>[,] existedInArea = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">9</span>,<span class="number">9</span>];</span><br><span class="line">        <span class="comment">// existedInColumn[a,b] 在第 a 列数字 b 是否出现过</span></span><br><span class="line">        <span class="keyword">bool</span>[,] existedInColumn = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">9</span>,<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// existedInRow[a] 在第 i 行数字 a 是否出现过</span></span><br><span class="line">            <span class="keyword">bool</span>[] existedInRow = <span class="keyword">new</span> <span class="keyword">bool</span>[<span class="number">9</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// skip blank and cal params</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j].Equals(<span class="string">'.'</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// -1 将数独 1~9 位移到 0~8 和数组下标从零开始保持一致</span></span><br><span class="line">                <span class="keyword">int</span> num = <span class="keyword">int</span>.Parse(board[i][j].ToString()) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> area = (j/<span class="number">3</span>)*<span class="number">3</span> + i/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check row</span></span><br><span class="line">                <span class="keyword">if</span>(existedInRow[num]</span><br><span class="line">                || existedInColumn[j, num]</span><br><span class="line">                || existedInArea[area,num]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                existedInRow[num] = <span class="literal">true</span>;</span><br><span class="line">                existedInColumn[j, num] = <span class="literal">true</span>;</span><br><span class="line">                existedInArea[area,num] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210917/ac.png" alt="ac"></p>
<h1 id="🟠-2021-08-25-797-所有可能的路径"><a href="#🟠-2021-08-25-797-所有可能的路径" class="headerlink" title="🟠 2021.08.25 (797. 所有可能的路径)"></a>🟠 2021.08.25 (<a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">797. 所有可能的路径</a>)</h1><h2 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h2><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p>二维数组的第 <code>i</code> 个数组中的单元都表示有向图中 <code>i</code> 号节点所能到达的下一些节点，空就是没有下一个结点了。</p>
<p>译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/dailyProblem/20210825/1.jpg" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="/dailyProblem/20210825/2.jpg" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1],[]]</span><br><span class="line">输出：[[0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == graph.length</code></li>
<li><code>2 &lt;= n &lt;= 15</code></li>
<li><code>0 &lt;= graph[i][j] &lt; n</code></li>
<li><code>graph[i][j] != i</code>（即，不存在自环）</li>
<li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li>
<li>保证输入为 <strong>有向无环图（DAG）</strong></li>
</ul>
<h2 id="题解（回溯搜索）"><a href="#题解（回溯搜索）" class="headerlink" title="题解（回溯搜索）"></a>题解（回溯搜索）</h2><p>此题数据量较小，且直接给了邻接表，直接进行深度优先遍历即可解决。完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="keyword">int</span>&gt;&gt; res = <span class="keyword">new</span> List&lt;IList&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> IList&lt;IList&lt;<span class="keyword">int</span>&gt;&gt; AllPathsSourceTarget(<span class="keyword">int</span>[][] graph) &#123;</span><br><span class="line">        dfs(graph, <span class="number">0</span>, <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;()&#123;<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="params"><span class="keyword">int</span>[][] graph, <span class="keyword">int</span> current, List&lt;<span class="keyword">int</span>&gt; list</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 已达目标点，因为List为引用传参，且在回溯后会被修改，故搜索到有效路径后需构建新List加入结果集合</span></span><br><span class="line">        <span class="keyword">if</span>(current == graph.Length - <span class="number">1</span>) res.Add(<span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(list));</span><br><span class="line">        <span class="comment">// 遍历当前节点的当所有可达节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph[current].Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> next = graph[current][i];</span><br><span class="line">            list.Add(next);</span><br><span class="line">            dfs(graph, next, list);</span><br><span class="line">            list.Remove(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210825/ac.png" alt="ac"></p>
<h1 id="🟠-2021-08-24-787-K-站中转内最便宜的航班"><a href="#🟠-2021-08-24-787-K-站中转内最便宜的航班" class="headerlink" title="🟠 2021.08.24 (787. K 站中转内最便宜的航班)"></a>🟠 2021.08.24 (<a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">787. K 站中转内最便宜的航班</a>)</h1><h2 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h2><p>有 <code>n</code> 个城市通过一些航班连接。给你一个数组 <code>flights</code> ，其中 <code>flights[i] = [from_i, to_i, price_i]</code> ，表示该航班都从城市 <code>from_i</code> 开始，以价格 <code>price_i</code> 抵达 <code>to_i</code>。</p>
<p>现在给定所有的城市和航班，以及出发城市 <code>src</code> 和目的地 <code>dst</code>，你的任务是找到出一条最多经过 <code>k</code> 站中转的路线，使得从 <code>src</code> 到 <code>dst</code> 的 <strong>价格最便宜</strong> ，并返回该价格。 如果不存在这样的路线，则输出 <code>-1</code>。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 1<br><strong>输出：</strong>200<br><strong>解释：</strong><br>城市航班图如下</p>
<p><img src="/dailyProblem/20210824/1.png" alt="1"></p>
<p>从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong><br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 0</p>
<p><strong>输出：</strong>500<br><strong>解释：</strong><br>城市航班图同上。从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= flights.length &lt;= (n * (n - 1) / 2)</code></li>
<li><code>flights[i].length == 3</code></li>
<li><code>0 &lt;= from_i, to_i &lt; n</code></li>
<li><code>from_i != to_i</code></li>
<li><code>1 &lt;= price_i &lt;= 104</code></li>
<li>航班没有重复，且不存在自环</li>
<li><code>0 &lt;= src, dst, k &lt; n</code></li>
<li><code>src != dst</code></li>
</ul>
<h2 id="题解（BFS-剪枝）"><a href="#题解（BFS-剪枝）" class="headerlink" title="题解（BFS+剪枝）"></a>题解（BFS+剪枝）</h2><p>待更新。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindCheapestPrice</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 构建邻接表</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] flightFrom = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>[]&gt;[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) flightFrom[i] = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">int</span>[] flight <span class="keyword">in</span> flights) flightFrom[flight[<span class="number">0</span>]].Add(flight);</span><br><span class="line">        <span class="comment">// 构建 BFS 队列</span></span><br><span class="line">        <span class="comment">// waiting 记录的是 BFS 过程中入队的等待下一层被遍历的城市编号。关于该 queue 为什么有两维：</span></span><br><span class="line">        <span class="comment">// 队列中加入候遍历元素时必须同时记录其src到i的开销快照，否则直接使用costFromSrc的话其开销可能被修改</span></span><br><span class="line">        <span class="comment">// 如 BFS 深度为 1 时计算的 src 到 i 节点开销为 x，即 costFromSrc[i] = x; 节点 i 入队</span></span><br><span class="line">        <span class="comment">// 入队时该开销 x 是特指深度为 1 时的最小开销，在进入深度为 2 的层次后，在 i 出队之前，</span></span><br><span class="line">        <span class="comment">// 可能找到了到达 i 的更小开销，那么 costFromSrc[i] 就将被覆盖，待 i 在深度为 2 出队时，使用的</span></span><br><span class="line">        <span class="comment">// costFromSrc[i] 已经不是原来的 x 了，那么对应的 costFromSrc[i] + flight[2] 也就不是深度为 2 时</span></span><br><span class="line">        <span class="comment">// i 到 flight[1] 的最小开销了，而是深度为 3 时的最小开销，深度为 2 时到 flight[1] 的正确开销是应是</span></span><br><span class="line">        <span class="comment">// 深度为 1 时的 x 加上 flight[2]，而因为无法保证 costFromSrc[i] 在下一层深度出队前不会被修改，</span></span><br><span class="line">        <span class="comment">// 因此在入队时就需要记录其当前时刻的 costFromSrc[i]，相当于打个快照，记录在数组的第二维。</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; waiting = <span class="keyword">new</span> Queue&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        waiting.Enqueue(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;src,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">// 初始化最小代价数组</span></span><br><span class="line">        <span class="keyword">int</span>[] costFromSrc = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) costFromSrc[i] = <span class="keyword">int</span>.MaxValue; costFromSrc[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始 BFS</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k+<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> lastTermEnqueueCount = waiting.Count;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lastTermEnqueueCount; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span>[] source = waiting.Dequeue();</span><br><span class="line">                <span class="keyword">foreach</span>(<span class="keyword">int</span>[] flight <span class="keyword">in</span> flightFrom[source[<span class="number">0</span>]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> newCost = source[<span class="number">1</span>] + flight[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 剪枝</span></span><br><span class="line">                    <span class="keyword">if</span>(newCost &lt; costFromSrc[flight[<span class="number">1</span>]] &amp;&amp; newCost &lt; costFromSrc[dst])</span><br><span class="line">                    &#123;</span><br><span class="line">                        costFromSrc[flight[<span class="number">1</span>]] = newCost;</span><br><span class="line">                        <span class="keyword">if</span>(flight[<span class="number">1</span>] != dst) waiting.Enqueue(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;flight[<span class="number">1</span>],newCost&#125;); <span class="comment">// 剪枝</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> costFromSrc[dst] == <span class="keyword">int</span>.MaxValue ? <span class="number">-1</span> : costFromSrc[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210824/ac.png" alt="ac"></p>
<h1 id="🟢-2021-08-23-1646-获取生成数组中的最大值"><a href="#🟢-2021-08-23-1646-获取生成数组中的最大值" class="headerlink" title="🟢 2021.08.23 (1646. 获取生成数组中的最大值)"></a>🟢 2021.08.23 (<a href="https://leetcode-cn.com/problems/get-maximum-in-generated-array/submissions/" target="_blank" rel="noopener">1646. 获取生成数组中的最大值</a>)</h1><h2 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code> 。按下述规则生成一个长度为 <code>n + 1</code> 的数组 <code>nums</code> ：</p>
<ul>
<li><code>nums[0] = 0</code></li>
<li><code>nums[1] = 1</code></li>
<li>当 <code>2 &lt;= 2 * i &lt;= n</code> 时，<code>nums[2 * i] = nums[i]</code></li>
<li>当 <code>2 &lt;= 2 * i + 1 &lt;= n</code> 时，<code>nums[2 * i + 1] = nums[i] + nums[i + 1]</code></li>
</ul>
<p>返回生成数组 <code>nums</code> 中的 <strong>最大</strong> 值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：根据规则：</span><br><span class="line">  nums[0] = 0</span><br><span class="line">  nums[1] = 1</span><br><span class="line">  nums[(1 * 2) = 2] = nums[1] = 1</span><br><span class="line">  nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2</span><br><span class="line">  nums[(2 * 2) = 4] = nums[2] = 1</span><br><span class="line">  nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3</span><br><span class="line">  nums[(3 * 2) = 6] = nums[3] = 2</span><br><span class="line">  nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3</span><br><span class="line">因此，nums = [0,1,1,2,1,3,2,3]，最大值 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
<h2 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h2><p>没什么好写的，按题目要求计算 <code>nums</code> 数组，然后返回最大值就行了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetMaximumGenerated</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = <span class="number">0</span>; nums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, m = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[<span class="number">2</span>*i] = nums[i];</span><br><span class="line">                m = nums[<span class="number">2</span>*i] &gt; m ? nums[<span class="number">2</span>*i] : m; <span class="comment">// 更新最大值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*i+<span class="number">1</span>&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[<span class="number">2</span>*i+<span class="number">1</span>] = nums[i] + nums[i+<span class="number">1</span>];</span><br><span class="line">                m = nums[<span class="number">2</span>*i+<span class="number">1</span>] &gt; m ? nums[<span class="number">2</span>*i+<span class="number">1</span>] : m; <span class="comment">// 更新最大值</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210823/ac.png" alt="AC"></p>
<h1 id="🟠-2021-08-22-789-逃脱阻碍者"><a href="#🟠-2021-08-22-789-逃脱阻碍者" class="headerlink" title="🟠 2021.08.22 (789. 逃脱阻碍者)"></a>🟠 2021.08.22 (<a href="https://leetcode-cn.com/problems/escape-the-ghosts/" target="_blank" rel="noopener">789. 逃脱阻碍者</a>)</h1><h2 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h2><p>你在进行一个简化版的吃豆人游戏。你从 <code>[0, 0]</code> 点开始出发，你的目的地是 <code>target = [xtarget, ytarget]</code> 。地图上有一些阻碍者，以数组 <code>ghosts</code> 给出，第 <code>i</code> 个阻碍者从 <code>ghosts[i] = [xi, yi]</code> 出发。所有输入均为 <strong>整数坐标</strong> 。</p>
<p>每一回合，你和阻碍者们可以同时向东，西，南，北四个方向移动，每次可以移动到距离原位置 <strong>1 个单位</strong> 的新位置。当然，也可以选择 <strong>不动</strong> 。所有动作 <strong>同时</strong> 发生。</p>
<p>如果你可以在任何阻碍者抓住你 <strong>之前</strong> 到达目的地（阻碍者可以采取任意行动方式），则被视为逃脱成功。如果你和阻碍者同时到达了一个位置（包括目的地）都不算是逃脱成功。</p>
<p>只有在你有可能成功逃脱时，输出 <code>true</code> ；否则，输出 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ghosts = [[1,0],[0,3]], target = [0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以直接一步到达目的地 (0,1) ，在 (1, 0) 或者 (0, 3) 位置的阻碍者都不可能抓住你。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ghosts = [[1,0]], target = [2,0]</span><br><span class="line">输出：false</span><br><span class="line">解释：你需要走到位于 (2, 0) 的目的地，但是在 (1, 0) 的阻碍者位于你和目的地之间。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ghosts = [[2,0]], target = [1,0]</span><br><span class="line">输出：false</span><br><span class="line">解释：阻碍者可以和你同时达到目的地。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ghosts = [[5,0],[-10,-2],[0,-5],[-2,-2],[-7,1]], target = [7,7]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：ghosts = [[-1,0],[0,1],[-1,0],[0,1],[-1,0]], target = [0,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= ghosts.length &lt;= 100</code></li>
<li><code>ghosts[i].length == 2</code></li>
<li><code>-104 &lt;= xi, yi &lt;= 104</code></li>
<li>同一位置可能有 <strong>多个阻碍者</strong> 。</li>
<li><code>target.length == 2</code></li>
<li><code>-104 &lt;= xtarget, ytarget &lt;= 104</code></li>
</ul>
<h2 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h2><p>在写题解之前，首先实在忍不住要吐槽，此题的歧义太大了！。。竟然还是谷歌的面试题，无语。</p>
<p>题目说 <code>ghosts</code>  是抓捕玩家的，且只要有可能成功逃脱，就应当返回 <code>true</code>，然而以 <strong>示例2</strong> 为例，若 <code>player_and_ghost = [[0,0],ghost[0]]</code> 按照 <code>[[0,-1],[0,0]]</code> → <code>[[1,-1],[0,-1]]</code> → <code>[[2,-1],[1,-1]]</code> → <code>[[2,0],[2,-1]]</code> 移动，玩家是完全能够成功逃脱的，且在这个过程中 <code>ghost</code> 同样在全力抓捕玩家（题目说了阻碍者可以采取任何行动方式），但该示例的输出却是 <code>false</code>，实在令人费解。</p>
<p><img src="/dailyProblem/20210822/1.png" alt="1"></p>
<p>一开始以为是翻译的锅，结果看了看原题，表述同样是”有可能逃脱“：</p>
<blockquote>
<p>Return <code>true</code> <em>if it is possible to escape, otherwise return</em> <code>false</code><em>.</em></p>
</blockquote>
<p>我猜想此题出题人是以 <code>ghosts</code> 和玩家谁能先到终点为出题点，然后为了考察面试者的问题转化能力，于是将谁先到终点这一表述改成了看上去相当复杂的玩家有没有可能逃脱 <code>ghosts</code> 追捕这一表述，然而这两者完全不等价，结果便是弄巧成拙，令人哑语，<strong>此题可谓烂出了高度，烂出了境界，烂得登峰造极！</strong></p>
<p>吐槽结束。该题目的正确表述应当是：”只有在你一定能成功逃脱时，输出 <code>true</code>“ 而不应是 “只有在你可能成功逃脱时，输出 <code>true</code>“，照这样来，问题才被转换为比较 <code>ghosts</code> 和玩家谁能够最先跑到终点，因为只要任一 <code>ghost</code> 先到终点并保持不动，玩家才会完全不存在逃脱的可能性，这同时这也是本题的最优解法。</p>
<p>由于移动只能上下左右，且移动速度是一致的，故谁先到达终点连距离都不需算，直接比较玩家与 ghost 们各自同终点为对角线构成矩形的一半周长即可。完整代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">EscapeGhosts</span>(<span class="params"><span class="keyword">int</span>[][] ghosts, <span class="keyword">int</span>[] target</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> distance = Math.Abs(target[<span class="number">0</span>])+ Math.Abs(target[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">int</span>[] ghost <span class="keyword">in</span> ghosts)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.Abs(target[<span class="number">0</span>]-ghost[<span class="number">0</span>])+Math.Abs(target[<span class="number">1</span>]-ghost[<span class="number">1</span>])&lt;=distance) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210822/ac.png" alt="AC"></p>
<h1 id="🟠-2021-08-21-443-压缩字符串"><a href="#🟠-2021-08-21-443-压缩字符串" class="headerlink" title="🟠 2021.08.21 (443. 压缩字符串)"></a>🟠 2021.08.21 (<a href="https://leetcode-cn.com/problems/string-compression/" target="_blank" rel="noopener">443. 压缩字符串</a>)</h1><h2 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符数组 <code>chars</code> ，请使用下述算法压缩：</p>
<p>从一个空字符串 <code>s</code> 开始。对于 <code>chars</code> 中的每组 <strong>连续重复字符</strong> ：</p>
<ul>
<li>如果这一组长度为 <code>1</code> ，则将字符追加到 <code>s</code> 中。</li>
<li>否则，需要向 <code>s</code> 追加字符，后跟这一组的长度。</li>
</ul>
<p>压缩后得到的字符串 <code>s</code> <strong>不应该直接返回</strong> ，需要转储到字符数组 <code>chars</code> 中。需要注意的是，如果组长度为 <code>10</code> 或 <code>10</code> 以上，则在 <code>chars</code> 数组中会被拆分为多个字符。</p>
<p>请在 <strong>修改完输入数组后</strong> ，返回该数组的新长度。</p>
<p>你必须设计并实现一个只使用常量额外空间的算法来解决此问题。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>chars = [“a”,”a”,”b”,”b”,”c”,”c”,”c”]<br><strong>输出：</strong>返回 6 ，输入数组的前 6 个字符应该是：[“a”,”2”,”b”,”2”,”c”,”3”]<br><strong>解释：</strong><br>“aa” 被 “a2” 替代。”bb” 被 “b2” 替代。”ccc” 被 “c3” 替代。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>chars = [“a”]<br><strong>输出：</strong>返回 1 ，输入数组的前 1 个字符应该是：[“a”]<br><strong>解释：</strong><br>没有任何字符串被替代。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong>chars = [“a”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”,”b”]<br><strong>输出：</strong>返回 4 ，输入数组的前 4 个字符应该是：[“a”,”b”,”1”,”2”]。<br><strong>解释：</strong><br>由于字符 “a” 不重复，所以不会被压缩。”bbbbbbbbbbbb” 被 “b12” 替代。<br>注意每个数字在数组中都有它自己的位置。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= chars.length &lt;= 2000</code></li>
<li><code>chars[i]</code> 可以是小写英文字母、大写英文字母、数字或符号</li>
</ul>
<h2 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h2><p>此题不难，且容易发现并不需要额外设置 <code>s</code> 串再转储回 <code>chars</code> 中，完全可以在遍历原字符数组 <code>chars</code> 的过程中就地修改 <code>chars</code> 完成要求。</p>
<p>首先设置一个 <code>hold</code> 字符变量，用于存储重复首字符，再设置一个 <code>contiCount</code> 整形变量，用于存储连续重复的 <code>hold</code> 字符数。利用一个初值为 0 的整形 <code>pointer</code> 变量作为覆写 <code>chars</code> 的位置指针，时刻指向下一次要写入的位置，这样 <code>pointer</code> 的值也就同时代表了题目要求返回的数组长度。</p>
<p>在最开始时，<code>hold</code> 是空字符，直接将第一个字符设置为 <code>hold</code>，覆写自己，移动 <code>pointer</code> 并将 <code>contiCount</code> 设置为1，代表重复字符数为1，即字符本身。</p>
<p>此后，当遍历到的字符与 <code>hold</code> 相同时，说明出现的是重复字符，将 <code>contiCount</code> 自增以更新重复字符数；当遍历到的字符与 <code>hold</code> 不同时，说明出现了新字符，此时将之前重复字符的 <code>contiCount</code> 拆分写入 <code>chars</code>后，即可更新 <code>hold</code> 记录为新字符，并将新字符覆写入 <code>chars</code> ，<code>contiCount</code> 重置为1，以此类推。由于期间都是使用移动的 <code>pointer</code> 来指向要覆写的 <code>chars</code> 位，因此每次写入操作都要将 <code>pointer</code> 移动一位。</p>
<p>这里我以压缩字符数组 <code>[&#39;a&#39;,&#39;b&#39;,&#39;b&#39;,&#39;b&#39;,&#39;c&#39;]</code> 为例，画了一个压缩过程图解，辅助理解。</p>
<p><img src="/dailyProblem/20210821/1.png" alt="1"></p>
<p>显然，该方法需要遍历一次原数组，且只使用了两个 <code>int</code> 和一个 <code>char</code> 变量，故时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Compress</span>(<span class="params"><span class="keyword">char</span>[] chars</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> hold = <span class="string">'\0'</span>; <span class="comment">// 当前暂存的重复首字符</span></span><br><span class="line">        <span class="keyword">int</span> contiCount = <span class="number">0</span>; <span class="comment">// 连续重复的字符数</span></span><br><span class="line">        <span class="keyword">int</span> pointer = <span class="number">0</span>; <span class="comment">// 覆写chars的位置指针(亦题要返回的s长度)</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">char</span> c <span class="keyword">in</span> chars)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.Equals(hold)) contiCount++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 结算上一种char的重复字符数</span></span><br><span class="line">                <span class="keyword">if</span>(contiCount&gt;<span class="number">1</span>) <span class="comment">// 为0为首次进入，为1不需要追加数字</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 将数字拆分覆写入chars</span></span><br><span class="line">                    <span class="keyword">string</span> temp = contiCount.ToString();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.Length; i++) chars[pointer++] = temp[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 覆写入新字符</span></span><br><span class="line">                chars[pointer++] = hold = c;</span><br><span class="line">                <span class="comment">// 重置重复字符数</span></span><br><span class="line">                contiCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以重复字符结尾时，不会进入foreach中的else分支，此处单独判断是否有未结算的连续字符数</span></span><br><span class="line">        <span class="keyword">if</span>(contiCount!=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">string</span> temp = contiCount.ToString();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.Length; i++) chars[pointer++] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210821/ac.png" alt="AC"></p>
<h1 id="🟢-2021-08-20-541-反转字符串-II"><a href="#🟢-2021-08-20-541-反转字符串-II" class="headerlink" title="🟢 2021.08.20 (541. 反转字符串 II)"></a>🟢 2021.08.20 (<a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a>)</h1><h2 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每 <code>2k</code> 个字符反转前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “abcdefg”, k = 2<br><strong>输出：</strong>“bacdfeg”</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “abcd”, k = 2<br><strong>输出：</strong>“bacd”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文组成</li>
<li><code>1 &lt;= k &lt;= 104</code></li>
</ul>
<h2 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h2><p>此题不难，只需按一般情况逆置 k 位字符，然后将字符指针以 2k 长度为单位进行跳转，直接跳转到下一个逆置起点，继续逆置 k 位，以此类推即可。本题我使用 for 循环的循环变量来控制跳转，同时利用 for 循环的循环条件来判断接下来是否够 k 位，进而可以避免循环内部再做 if 判断。</p>
<p>对于最后可能剩下的不够 k 位的情况，单独用一个 if 来捕获，进行剩余字符的逆置。这里我画了一幅图展示完整过程，以供理解。<img src="/dailyProblem/20210820/1.png" alt="1"></p>
<p>理清了思路，代码也就水到渠成了，完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> temp; <span class="comment">// 用于swap的中间变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ReverseStr</span>(<span class="params"><span class="keyword">string</span> s, <span class="keyword">int</span> k</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.ToCharArray(); <span class="comment">// string是只读的，转为char[]方便修改</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 逆置满k位的 第2ik ~ 第(2i+1)k-1位</span></span><br><span class="line">        <span class="keyword">for</span>(; (<span class="number">2</span>*i+<span class="number">1</span>)*k<span class="number">-1</span> &lt; s.Length; i++) cs = ReversePartialStr(cs, <span class="number">2</span>*i*k, (<span class="number">2</span>*i+<span class="number">1</span>)*k<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 如有剩余不满k位的，则逆置剩余的 第2ik ~ 第s.Length-1位</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(<span class="number">2</span>*i*k &lt; s.Length<span class="number">-1</span> ? ReversePartialStr(cs, <span class="number">2</span>*i*k, s.Length<span class="number">-1</span>) : cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆置第left位~第right位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">ReversePartialStr</span>(<span class="params"><span class="keyword">char</span>[] cs, <span class="keyword">int</span> left, <span class="keyword">int</span> right</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 交换cs[left]和cs[right]</span></span><br><span class="line">            temp = cs[left]; cs[left] = cs[right]; cs[right] = temp;</span><br><span class="line">            left++; right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210820/ac.png" alt="AC"></p>
<h1 id="🟢-2021-08-19-345-反转字符串中的元音字母"><a href="#🟢-2021-08-19-345-反转字符串中的元音字母" class="headerlink" title="🟢 2021.08.19 (345. 反转字符串中的元音字母)"></a>🟢 2021.08.19 (<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. 反转字符串中的元音字母</a>)</h1><h2 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>“hello”<br><strong>输出：</strong>“holle”</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>“leetcode”<br><strong>输出：</strong>“leotcede”</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>元音字母不包含字母 “y” 。</li>
</ul>
<h2 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h2><p>这题还是比较简单的。反转元音字母本质上也就是逆置数组，只需要设置首尾指针然后进行对调即可。只不过要逆置的元素中间插入了一些干扰项，因此需要先将首尾指针先定位到需要调换的元素位置上然后再进行调换，有点类似于快排找枢轴的过程。</p>
<p>但是有一点比较坑的是，题目没有特别说明可能含大写字母，因此在判断元音字母时这点需要额外注意。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ReverseVowels</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.ToCharArray(); <span class="comment">// string是只读的，为了修改内容先转成char[]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; <span class="comment">// 设置首尾指针</span></span><br><span class="line">        <span class="keyword">int</span> right = s.Length<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> temp; <span class="comment">// 用于交换首尾指针元素的中间变量</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right  &amp;&amp; cs[left]!=<span class="string">'a'</span> &amp;&amp; cs[left]!=<span class="string">'A'</span></span><br><span class="line">                              &amp;&amp; cs[left]!=<span class="string">'e'</span> &amp;&amp; cs[left]!=<span class="string">'E'</span></span><br><span class="line">                              &amp;&amp; cs[left]!=<span class="string">'i'</span> &amp;&amp; cs[left]!=<span class="string">'I'</span></span><br><span class="line">                              &amp;&amp; cs[left]!=<span class="string">'o'</span> &amp;&amp; cs[left]!=<span class="string">'O'</span></span><br><span class="line">                              &amp;&amp; cs[left]!=<span class="string">'u'</span> &amp;&amp; cs[left]!=<span class="string">'U'</span></span><br><span class="line">            ) left++; <span class="comment">// 从左向右找元音字母</span></span><br><span class="line">            <span class="keyword">while</span>(right&gt;left  &amp;&amp; cs[right]!=<span class="string">'a'</span> &amp;&amp; cs[right]!=<span class="string">'A'</span></span><br><span class="line">                              &amp;&amp; cs[right]!=<span class="string">'e'</span> &amp;&amp; cs[right]!=<span class="string">'E'</span></span><br><span class="line">                              &amp;&amp; cs[right]!=<span class="string">'i'</span> &amp;&amp; cs[right]!=<span class="string">'I'</span></span><br><span class="line">                              &amp;&amp; cs[right]!=<span class="string">'o'</span> &amp;&amp; cs[right]!=<span class="string">'O'</span></span><br><span class="line">                              &amp;&amp; cs[right]!=<span class="string">'u'</span> &amp;&amp; cs[right]!=<span class="string">'U'</span></span><br><span class="line">            ) right--; <span class="comment">// 从右向左找元音字母</span></span><br><span class="line">            <span class="comment">// 将左右找到的元音字母交换</span></span><br><span class="line">            temp = cs[left];</span><br><span class="line">            cs[left] = cs[right];</span><br><span class="line">            cs[right] = temp;</span><br><span class="line">            <span class="comment">// 交换后记得移动首尾指针 不然就死循环了</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">string</span>(cs); <span class="comment">// 用修改完成后的char[]构造新string返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210819/ac.png" alt="AC"></p>
<h1 id="🔴-2021-08-18-552-学生出勤记录-II"><a href="#🔴-2021-08-18-552-学生出勤记录-II" class="headerlink" title="🔴 2021.08.18 (552. 学生出勤记录 II)"></a>🔴 2021.08.18 (<a href="https://leetcode-cn.com/problems/student-attendance-record-ii/" target="_blank" rel="noopener">552. 学生出勤记录 II</a>)</h1><h2 id="题目-45"><a href="#题目-45" class="headerlink" title="题目"></a>题目</h2><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
<li><code>&#39;A&#39;</code>：Absent，缺勤</li>
<li><code>&#39;L&#39;</code>：Late，迟到</li>
<li><code>&#39;P&#39;</code>：Present，到场</li>
</ul>
<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<ul>
<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>&#39;A&#39;</code>）<strong>严格</strong> 少于两天。</li>
<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>&#39;L&#39;</code>）记录。</li>
</ul>
<p>给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>n = 2<br><strong>输出：</strong>8<br><strong>解释：</strong><br>有 8 种长度为 2 的记录将被视为可奖励：<br>“PP” , “AP”, “PA”, “LP”, “PL”, “AL”, “LA”, “LL”<br>只有”AA”不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>n = 1<br><strong>输出：</strong>3</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p><strong>输入：</strong>n = 10101<br><strong>输出：</strong>183236316</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>
<h2 id="题解（DFS-记忆化搜索）"><a href="#题解（DFS-记忆化搜索）" class="headerlink" title="题解（DFS+记忆化搜索）"></a>题解（DFS+记忆化搜索）</h2><p>这题自己没做出来，看了一眼别人的题解才瞬间被点通了，以后这种序列问题都应该有意识地考虑递归解法结合记忆化搜索来优化。虽然这题的难度系数是困难，但是完全没做出来实在是不应该啊，还是自己太菜了。。</p>
<p>首先需要能够想到基础的递归写法。要统计符合条件的序列数量，那么我们从第一位置开始选字母，然后选好后再选下一位的字母。只有这一位字母的选择满足题目条件才有资格去选下一位字母，这样只要选完了最后一位字母，就找到了一条有效序列。并且由于是每位每种有效情况的字母都遍历了，因此可以做到不重不漏。</p>
<p>定义 <code>int NextDay(int day, int a, int l, int n)</code> 是选下一位字母的递归函数，返回这个参数情况下满足题意的序列个数。因为判断条件和之前状态有关联，因此需要两个参数 <code>a</code> 和 <code>l</code> 把之前状态传进来，其中 <code>a</code> 是前面出现的 Absent 的次数，<code>l</code> 是前面连续出现的 Late 的次数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NextDay</span>(<span class="params"><span class="keyword">int</span> day, <span class="keyword">int</span> a, <span class="keyword">int</span> l, <span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"><span class="comment">// day: 当前天数; a: 之前 Absent 的次数; l: 之前连续 Late 的天数.</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(day &gt; n) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// n天都选完了，</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1.这天Present，任何情况下都可以放Present，不影响有效性</span></span><br><span class="line">    count = (count + NextDay(day+<span class="number">1</span>, a, <span class="number">0</span>, n)) % MOD;</span><br><span class="line">    <span class="comment">// 2.如果之前有连续两天Late了，那么今天就不能放Late了，否则就连续三天了，因此l必须&lt;2</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;<span class="number">2</span>) count = (count + NextDay(day+<span class="number">1</span>, a, l+<span class="number">1</span>, n)) % MOD;</span><br><span class="line">    <span class="comment">// 3.如果之前已经有Absent了，那么就不能再Absent了，因此a必须严格为0</span></span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>) count = (count + NextDay(day+<span class="number">1</span>, a+<span class="number">1</span>, <span class="number">0</span>, n)) % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题的递归逻辑就是这样了，很简洁，也很直觉，很可惜自己并没有往这个方面想，菜是原罪。</p>
<p>当然，直接这样提交的话是会超时的，不过用记忆化搜索优化一下就好了，这个不难。当然这题也可以DP解，但暂时先止步于记忆化搜索，之后DP当专题来专门学习，然后再回过头来拿这些题目练习复习。</p>
<p>DFS+记忆化搜索版完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> MOD = (<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span>[,,] mem; <span class="comment">// [day, a, l]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CheckRecord</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize mem</span></span><br><span class="line">        mem = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    mem[i,j,k] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NextDay(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NextDay</span>(<span class="params"><span class="keyword">int</span> day, <span class="keyword">int</span> a, <span class="keyword">int</span> l, <span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function">    <span class="comment">// day: current day; a: count of absent day before this day;</span></span></span><br><span class="line"><span class="function">    <span class="comment">// l: conti count of late day before this day.</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(day &gt; n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mem[day,a,l]!=<span class="number">-1</span>) <span class="keyword">return</span> mem[day,a,l];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Present this day</span></span><br><span class="line">        count = (count + NextDay(day+<span class="number">1</span>, a, <span class="number">0</span>, n)) % MOD;</span><br><span class="line">        <span class="comment">// Late this day</span></span><br><span class="line">        <span class="keyword">if</span>(l&lt;<span class="number">2</span>) count = (count + NextDay(day+<span class="number">1</span>, a, l+<span class="number">1</span>, n)) % MOD;</span><br><span class="line">        <span class="comment">// Absent this day</span></span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>) count = (count + NextDay(day+<span class="number">1</span>, a+<span class="number">1</span>, <span class="number">0</span>, n)) % MOD;</span><br><span class="line"></span><br><span class="line">        mem[day,a,l] = count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210818/ac.png" alt="AC"></p>
<h1 id="🟢-2021-08-17-551-学生出勤记录-I"><a href="#🟢-2021-08-17-551-学生出勤记录-I" class="headerlink" title="🟢 2021.08.17 (551. 学生出勤记录 I)"></a>🟢 2021.08.17 (<a href="https://leetcode-cn.com/problems/student-attendance-record-i/" target="_blank" rel="noopener">551. 学生出勤记录 I</a>)</h1><h2 id="题目-46"><a href="#题目-46" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
<li><code>&#39;A&#39;</code>：Absent，缺勤</li>
<li><code>&#39;L&#39;</code>：Late，迟到</li>
<li><code>&#39;P&#39;</code>：Present，到场</li>
</ul>
<p>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<ul>
<li>按 <strong>总出勤</strong> 计，学生缺勤（<code>&#39;A&#39;</code>）<strong>严格</strong> 少于两天。</li>
<li>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（<code>&#39;L&#39;</code>）记录。</li>
</ul>
<p>如果学生可以获得出勤奖励，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “PPALLP”<br><strong>输出：</strong>true<br><strong>解释：</strong>学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “PPALLL”<br><strong>输出：</strong>false<br><strong>解释：</strong>学生最后三天连续迟到，所以不满足出勤奖励的条件。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 为 <code>&#39;A&#39;</code>、<code>&#39;L&#39;</code> 或 <code>&#39;P&#39;</code></li>
</ul>
<h2 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h2><p>这题没什么好解的，直接按直觉写就击败100%用户了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">CheckRecord</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> A = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">char</span> c <span class="keyword">in</span> s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'A'</span>) A++; <span class="comment">// 缺勤</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'L'</span>) L++;</span><br><span class="line">            <span class="keyword">else</span> L = <span class="number">0</span>; <span class="comment">// 只记录连续迟到</span></span><br><span class="line">            <span class="keyword">if</span>(A==<span class="number">2</span> || L==<span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 满足缺勤两次或连续迟到三次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210817/ac.png" alt="AC"></p>
<h1 id="🟠-2021-08-16-526-优美的排列"><a href="#🟠-2021-08-16-526-优美的排列" class="headerlink" title="🟠 2021.08.16 (526. 优美的排列)"></a>🟠 2021.08.16 (<a href="https://leetcode-cn.com/problems/beautiful-arrangement/" target="_blank" rel="noopener">526. 优美的排列</a>)</h1><h2 id="题目-47"><a href="#题目-47" class="headerlink" title="题目"></a>题目</h2><p>假设有从 1 到 N 的 <strong>N</strong> 个整数，如果从这 <strong>N</strong> 个数字中成功构造出一个数组，使得数组的第 <strong>i</strong> 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<ol>
<li>第 <strong>i</strong> 位的数字能被 <strong>i</strong> 整除</li>
<li><strong>i</strong> 能被第 <strong>i</strong> 位上的数字整除</li>
</ol>
<p>现在给定一个整数 N，请问可以构造多少个优美的排列？</p>
<p>示例1:</p>
<blockquote>
<p><strong>输入:</strong> 2<br><strong>输出:</strong> 2<br><strong>解释: </strong></p>
<p>第 1 个优美的排列是 [1, 2]:<br>    第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>      第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除</p>
<p>第 2 个优美的排列是 [2, 1]:<br>    第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>      第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</p>
</blockquote>
<p><strong>说明:</strong></p>
<ol>
<li><strong>N</strong> 是一个正整数，并且不会超过15。</li>
</ol>
<h2 id="题解（DFS）"><a href="#题解（DFS）" class="headerlink" title="题解（DFS）"></a>题解（DFS）</h2><p>看完题目首先想到的是暴力解法，即遍历每一位（第 i 位），在每位上再遍历 $[1,N]$ 范围内的所有数，依次选取第 i 位上能够放上的所有满足构成优美排列的数字并进行下一位数的选取，当最后一位数也选取完成后，就构造出了一个优美排列，即</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index: 第 i 位</span></span><br><span class="line"><span class="comment">// n: 可以放置的数的范围上限</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 优美排列数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNext</span>(<span class="params"><span class="keyword">int</span> index, <span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 最后一位数已经完成选取，排列已经构造完成</span></span><br><span class="line">    <span class="keyword">if</span>(index &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 为第 index 位数遍历所有可能的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查 i 放在第 index 位是否满足优美排列条件</span></span><br><span class="line">        <span class="keyword">if</span>(i%index==<span class="number">0</span> || index%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 继续放置下一位数</span></span><br><span class="line">            FindNext(index+<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样还有一个问题，即当某个数字 i 在某位处被选取后，是不应当在后面的位处再被选取的，因此我们需要在进入下一位递归前，为当前选取的数字做一个标记，防止被再次选中，并且在递归回溯时取消标记（因为回溯后当前位使用 i 的情况就结束了，通过for循环继续遍历使用其它数的情况）</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span>[] used;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CountArrangement</span>(<span class="params"><span class="keyword">int</span> n</span>) </span>&#123;</span><br><span class="line">        used = <span class="keyword">new</span> <span class="keyword">bool</span>[n+<span class="number">1</span>];</span><br><span class="line">        FindNext(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNext</span>(<span class="params"><span class="keyword">int</span> index, <span class="keyword">int</span> n</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一个优美排序构造完成了</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 检查 i 放在第 index 位是否满足优美排列条件</span></span><br><span class="line">            <span class="keyword">if</span>(!used[i] &amp;&amp; (i%index==<span class="number">0</span> || index%i==<span class="number">0</span>))</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 将当前数标记为已被使用，防止递归内部被重复使用</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                FindNext(index+<span class="number">1</span>, n);</span><br><span class="line">                <span class="comment">// 取消该数的使用状态，继续遍历第 index 位放下一个数字的情况</span></span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210816/ac.png" alt="执行情况"></p>
<h1 id="🟠-2021-08-15-576-出界的路径数"><a href="#🟠-2021-08-15-576-出界的路径数" class="headerlink" title="🟠 2021.08.15 (576. 出界的路径数)"></a>🟠 2021.08.15 (<a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">576. 出界的路径数</a>)</h1><h2 id="题目-48"><a href="#题目-48" class="headerlink" title="题目"></a>题目</h2><p>给你一个大小为 <code>m x n</code> 的网格和一个球。球的起始坐标为 <code>[startRow, startColumn]</code> 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 <strong>最多</strong> 可以移动 <code>maxMove</code> 次球。</p>
<p>给你五个整数 <code>m</code>、<code>n</code>、<code>maxMove</code>、<code>startRow</code> 以及 <code>startColumn</code> ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 $10^9 + 7$ <strong>取余</strong> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<p><img src="/dailyProblem/20210815/out_of_boundary_paths_1.png" alt="示例1"></p>
<blockquote>
<p><strong>输入：</strong>m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0<br><strong>输出：</strong>6</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<p><img src="/dailyProblem/20210815/out_of_boundary_paths_2.png" alt="示例1"></p>
<blockquote>
<p><strong>输入：</strong>m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1<br><strong>输出：</strong>12</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>0 &lt;= maxMove &lt;= 50</code></li>
<li><code>0 &lt;= startRow &lt; m</code></li>
<li><code>0 &lt;= startColumn &lt; n</code></li>
</ul>
<h2 id="题解（DFS-记忆化搜索）-1"><a href="#题解（DFS-记忆化搜索）-1" class="headerlink" title="题解（DFS+记忆化搜索）"></a>题解（DFS+记忆化搜索）</h2><p>读完题目，很自然地可以想到通过递归来解决问题。首先不考虑各种限制。</p>
<p>因为第 i 行 j 列最多移动 maxMove 步的出界路径数就是当前格子处移动一步可能的出界数再加上上下左右四个格子处最多移动 maxMove - 1 步的出界路径数的和。</p>
<p>即，若定义 <code>PathCount(int m, int n, int maxMove, int startRow, int startColumn)</code> 为第 startRow 行 startRow 列在 mxn 网格中最多移动 maxMove 步的路径数 count，则</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PathCount</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    count = 当前格移动一步的出界数 +</span><br><span class="line">    	PathCount(m, n, maxMove<span class="number">-1</span>, startRow<span class="number">-1</span>, startColumn) +</span><br><span class="line">    	PathCount(m, n, maxMove<span class="number">-1</span>, startRow+<span class="number">1</span>, startColumn) +</span><br><span class="line">    	PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn<span class="number">-1</span>) +</span><br><span class="line">    	PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将 count 设置为全局变量，在递归过程中更新这个量的话，那么就是</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PathCount</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    count += 当前格移动一步的出界数;</span><br><span class="line">    count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow<span class="number">-1</span>, startColumn) +</span><br><span class="line">             PathCount(m, n, maxMove<span class="number">-1</span>, startRow+<span class="number">1</span>, startColumn) +</span><br><span class="line">             PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn<span class="number">-1</span>) +</span><br><span class="line">             PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么具体在 PathCount 中，如何实际地更新 count (当前格移动一步的出界数)呢？即什么情况说明已经找到了一条出界路径？</p>
<p>不难想到，当 maxMove 大于 0，即球还可以移动的前提下，若当前所在行号为 0，那么就一定能够向上出界，即找到了一条出界路径，可以将 count++。同理，若当前所在列号为 0、当前所在行号为 m - 1（底边界处）、当前所在列号为 n - 1（右边界处）时也是有效的出界路径。因此 count 的实际更新可以被归结为以下四种情况</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startRow == <span class="number">0</span>) count++;</span><br><span class="line"><span class="keyword">if</span>(startRow == m<span class="number">-1</span>) count++;</span><br><span class="line"><span class="keyword">if</span>(startColumn == <span class="number">0</span>) count++;</span><br><span class="line"><span class="keyword">if</span>(startColumn == n<span class="number">-1</span>) count++;</span><br></pre></td></tr></table></figure>
<p>接下来只需要考虑递归出口即可。不难想到，当前位置处于网格之外，或者不能够再移动（maxMove为0）时就到达出口了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出口条件</span></span><br><span class="line"><span class="keyword">if</span>(startRow &lt; <span class="number">0</span> || startColumn &lt; <span class="number">0</span> || startRow &gt;= m || startColumn &gt;= n || maxMove == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>至此，可以得到如下直觉解法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindPaths</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PathCount(m, n, maxMove, startRow, startColumn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">PathCount</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 球已在界外或无法再移动时到达递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(startRow &lt; <span class="number">0</span> || startColumn &lt; <span class="number">0</span> || startRow &gt;= m || startColumn &gt;= n || maxMove == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 球向上/下/左/右移动1次即可出界</span></span><br><span class="line">        <span class="keyword">if</span>(startRow == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startRow == m<span class="number">-1</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startColumn == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startColumn == n<span class="number">-1</span>) count++;</span><br><span class="line">        <span class="comment">// 统计上下左右四个格子的出界情况数，根据题目，每步应该除余 1e9+7 防止溢出</span></span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow<span class="number">-1</span>, startColumn); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow+<span class="number">1</span>, startColumn); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn<span class="number">-1</span>); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn+<span class="number">1</span>); count %= mod;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样确实可以解决问题。<strong>但是</strong>，当输入参数过大导致递归深度过深时，运行时间会爆炸式增长。稍加分析可以发现，在第0层递归时的第一个 PathCount 调用栈中遍历过的格子，可能在后续递归中被大量重复访问，不仅重复访问，而且还会重复开启递归栈，造成时间爆炸。</p>
<p>因此我们可以设置一个变量（int[,,] mem），记录某格处最大走 maxMove 步对应的已经计算过的路径数量，在访问该格时，首先检查变量中该位置最大走 maxMove 步是否有值了，如果有就直接可以直接返回，省去所有重复的递归栈，以此优化原算法，此思想即为<strong>记忆化搜索</strong>。</p>
<p>最终完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span>[,,] mem; <span class="comment">// 记忆第 i 行 j 列处最大移动 maxMove 步的路径数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindPaths</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化记忆变量为-1，代表暂没有走过该状态</span></span><br><span class="line">        mem = <span class="keyword">new</span> <span class="keyword">int</span>[m,n,maxMove+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; maxMove+<span class="number">1</span>; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    mem[i,j,k] = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始计数</span></span><br><span class="line">        <span class="keyword">return</span> PathCount(m, n, maxMove, startRow, startColumn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">PathCount</span>(<span class="params"><span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> maxMove, <span class="keyword">int</span> startRow, <span class="keyword">int</span> startColumn</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 球已在界外或无法再移动时到达递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(startRow &lt; <span class="number">0</span> || startColumn &lt; <span class="number">0</span> || startRow &gt;= m || startColumn &gt;= n || maxMove == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若已经走过了该状态，则直接返回该状态对应的路径数，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span>(mem[startRow, startColumn, maxMove] != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> mem[startRow, startColumn, maxMove];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 球向上/下/左/右移动1次即可出界</span></span><br><span class="line">        <span class="keyword">if</span>(startRow == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startRow == m<span class="number">-1</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startColumn == <span class="number">0</span>) count++;</span><br><span class="line">        <span class="keyword">if</span>(startColumn == n<span class="number">-1</span>) count++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计上下左右四个格子的出界情况数，根据题目，每步应该除余 1e9+7 防止溢出</span></span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow<span class="number">-1</span>, startColumn); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow+<span class="number">1</span>, startColumn); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn<span class="number">-1</span>); count %= mod;</span><br><span class="line">        count += PathCount(m, n, maxMove<span class="number">-1</span>, startRow, startColumn+<span class="number">1</span>); count %= mod;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 记录当前状态的路径数</span></span><br><span class="line">        mem[startRow, startColumn, maxMove] = count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210815/ac.png" alt="执行情况"></p>
<h1 id="⚪-2021-08-14-1583-统计不开心的朋友"><a href="#⚪-2021-08-14-1583-统计不开心的朋友" class="headerlink" title="⚪ 2021.08.14 (1583. 统计不开心的朋友)"></a>⚪ 2021.08.14 (<a href="https://leetcode-cn.com/problems/count-unhappy-friends/" target="_blank" rel="noopener">1583. 统计不开心的朋友</a>)</h1><p><strong>🟠 未做</strong></p>
<h1 id="⚪-2021-08-13-233-数字-1-的个数"><a href="#⚪-2021-08-13-233-数字-1-的个数" class="headerlink" title="⚪ 2021.08.13 (233. 数字 1 的个数)"></a>⚪ 2021.08.13 (<a href="https://leetcode-cn.com/problems/number-of-digit-one/" target="_blank" rel="noopener">233. 数字 1 的个数</a>)</h1><p><strong>🔴 不会</strong></p>
<h1 id="⚪-2021-08-12-516-最长回文子序列"><a href="#⚪-2021-08-12-516-最长回文子序列" class="headerlink" title="⚪ 2021.08.12 (516. 最长回文子序列)"></a>⚪ 2021.08.12 (<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a>)</h1><h2 id="题目-49"><a href="#题目-49" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “bbbab”<br><strong>输出：</strong>4<br><strong>解释：</strong>一个可能的最长回文子序列为 “bbbb” 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>s = “cbbd”<br><strong>输出：</strong>2<br><strong>解释：</strong>一个可能的最长回文子序列为 “bb” 。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h2 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h2><p><strong>🟠 待更新</strong></p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LongestPalindromeSubseq</span>(<span class="params"><span class="keyword">string</span> s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[,] maxLength = <span class="keyword">new</span> <span class="keyword">int</span>[s.Length, s.Length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.Length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLength[i,i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.Length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 左右对称回缩，中间范围最长回文长度加上当前新的首位即为i到j最长回文长度</span></span><br><span class="line">                    maxLength[i,j] = maxLength[i+<span class="number">1</span>,j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 记忆上一个最长的序列长度为i到j最长回文长度</span></span><br><span class="line">                    maxLength[i,j] = Math.Max(maxLength[i+<span class="number">1</span>,j], maxLength[i,j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength[<span class="number">0</span>, s.Length<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="⚪-2021-08-11-446-等差数列划分-II"><a href="#⚪-2021-08-11-446-等差数列划分-II" class="headerlink" title="⚪ 2021.08.11 (446. 等差数列划分 II)"></a>⚪ 2021.08.11 (<a href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/" target="_blank" rel="noopener">446. 等差数列划分 II</a>)</h1><p><strong>🔴 不会</strong></p>
<h1 id="🟠-2021-08-10-413-等差数列划分"><a href="#🟠-2021-08-10-413-等差数列划分" class="headerlink" title="🟠 2021.08.10 (413. 等差数列划分)"></a>🟠 2021.08.10 (<a href="https://leetcode-cn.com/problems/arithmetic-slices/" target="_blank" rel="noopener">413. 等差数列划分</a>)</h1><h2 id="题目-50"><a href="#题目-50" class="headerlink" title="题目"></a>题目</h2><p>如果一个数列 <strong>至少有三个元素</strong> ，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<ul>
<li>例如，<code>[1,3,5,7,9]</code>、<code>[7,7,7,7]</code> 和 <code>[3,-1,-5,-9]</code> 都是等差数列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，返回数组 <code>nums</code> 中所有为等差数组的 <strong>子数组</strong> 个数。</p>
<p><strong>子数组</strong> 是数组中的一个连续序列。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>nums = [1,2,3,4]<br><strong>输出：</strong>3<br><strong>解释：</strong>nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>nums = [1]<br><strong>输出：</strong>0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h2 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h2><p>这题按直觉解就很容易解，依次将第 i 个元素作为子数组的首元素，然后利用首元素和下一个元素计算该子数列的公差，然后开始向后检查，只要每一个元素和前一个元素之差等于公差，那么都构成一个等差子数列，直到与前一位之差不等于公差，第 i 个元素作为首元素就不存在更多等差子数列了，将 i++ 进行后续判断。</p>
<p>如1234578，先将首位设置为第一个元素1，然后利用(12)计算出公差为1，往后(123)中(23)之差为1，就是一个子数列，往后(1234)中(34)之差也为1也是子数列，(12345)中(45)也是，但(123457)中(57)就不是了，那么再往后也不可能再是等差数列了，于是将首位设置为第二个元素同理搜索。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOfArithmeticSlices</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 至少三个元素才能构成等差数列</span></span><br><span class="line">        <span class="keyword">if</span>(nums.Length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// rear: 计算差值的左元素; front: 计算差值的右元素; delta: 子数组的期待公差</span></span><br><span class="line">        <span class="keyword">int</span> rear, front, delta, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 以i为子数组的首元素，计算该子数组(等差数列)期待的公差</span></span><br><span class="line">            rear = i; front = i+<span class="number">1</span>;</span><br><span class="line">            delta = nums[front] - nums[rear];</span><br><span class="line">            <span class="comment">// 只要每一对rear、front之差为期待的公差值就找到了一个子等差数列，移动rear和front继续计算下一对差值</span></span><br><span class="line">            <span class="keyword">while</span>(++front &lt; nums.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[front] - nums[++rear] == delta) count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210810/ac.png" alt="AC"></p>
<h1 id="🟠-2021-08-09-313-超级丑数"><a href="#🟠-2021-08-09-313-超级丑数" class="headerlink" title="🟠 2021.08.09 (313. 超级丑数)"></a>🟠 2021.08.09 (<a href="https://leetcode-cn.com/problems/super-ugly-number/" target="_blank" rel="noopener">313. 超级丑数</a>)</h1><h2 id="题目-51"><a href="#题目-51" class="headerlink" title="题目"></a>题目</h2><p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。</p>
<p>给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。</p>
<p>题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p><strong>输入：</strong>n = 12, primes = [2,7,13,19]<br><strong>输出：</strong>32<br><strong>解释：</strong>给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><strong>输入：</strong>n = 1, primes = [2,3,5]<br><strong>输出：</strong>1<br><strong>解释：</strong>1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 106</code></li>
<li><code>1 &lt;= primes.length &lt;= 100</code></li>
<li><code>2 &lt;= primes[i] &lt;= 1000</code></li>
<li>题目数据 <strong>保证</strong> <code>primes[i]</code> 是一个质数</li>
<li><code>primes</code> 中的所有值都 <strong>互不相同</strong> ，且按 <strong>递增顺序</strong> 排列</li>
</ul>
<h2 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h2><p>由于超级丑数是由质因数相乘得到的，因此给定一组质因数后，其对应的超级丑数有无数个，所以肯定是无法通过先计算出所有超级丑数，然后取第 n 个返回的思路了。故应该思考如何从小到大按顺序依次生成超级丑数。</p>
<p>其中一个关键点是，由于超级丑数是由质因数相乘得到的，那么就意味着<strong>任一超级丑数一定能被分解成一个质因数和一个更小的超级丑数</strong>，也即<strong>超级丑数是由更小的超级丑数同质因数生成的</strong>。那么反过来，我们借此就可以由最小的超级丑数1，遍历质因数同1相乘，来找到(生成)最小的下一个超级丑数。</p>
<p><img src="/dailyProblem/20210809/1.png" alt="1"></p>
<p>现在就有了两个超级丑数，并且它们是最小的两个，那么第三个超级丑数就一定是由这两个小的超级丑数同所有质因数相乘得到的结果中最小的那个。不过需要注意的是，质因数并不需要和所有找到的超级丑数相乘再比较，因为我们要找的是最小的那个，只需要和允许相乘的最小的那一个超级丑数相乘就行了，比如质因数4和第 1 个超级丑数相乘了，那么这个质因数就没有必要和第 2 个以及后面的超级丑数相乘了，因为往后一定是乘出来更大的数。</p>
<p>那么如何知道某个质因数应当和第几个超级丑数相乘呢？其实只需要设置一个(质因数-&gt;超级丑数)指针，最开始所有质因数都是和最小的超级丑数相乘，当某个质因数 x 被选出来同1相乘的结果最小时，生成了第二个超级丑数，此后 x 就不可能再和 1 相乘了，因此 x 对应的指针就可以向后移动到第二个超级丑数的位置，后面只需要和第二个超级丑数乘就是 x 能生成的最小的超级丑数。</p>
<p><img src="/dailyProblem/20210809/2.png" alt="1"></p>
<p>依次类推，生成到第 n 个超级丑数，就得到了本题的答案。</p>
<p>此外，如果有其它质因数和其指针对应的超级丑数相乘的结果和生成的下一个超级丑数相同，那么这个质因数的指针也应该后移一位，因为相同的超级丑数没有意义，应当指向下一位能生成大于当前超级丑数序列中最大超级丑数的最小超级丑数。</p>
<p>完整代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NthSuperUglyNumber</span>(<span class="params"><span class="keyword">int</span> n, <span class="keyword">int</span>[] primes</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化待装n个超级丑数的容器</span></span><br><span class="line">        <span class="keyword">int</span>[] uglyNums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        uglyNums[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 1是初始的最小的超级丑数</span></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化pUg为质因数对应的超级丑数指针</span></span><br><span class="line">        <span class="keyword">int</span>[] pUg = <span class="keyword">new</span> <span class="keyword">int</span>[primes.Length];</span><br><span class="line">        <span class="comment">// 初试时全都指向最小的超级丑数1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; primes.Length; i++) pUg[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nextUg, pMove, min;</span><br><span class="line">        <span class="comment">// 生成到第n个超级丑数</span></span><br><span class="line">        <span class="keyword">while</span>(count!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// nextUg为各质因数和各自指针指向的超级丑数相乘结果中最小的那一个，首先将最小值初始化为第一个</span></span><br><span class="line">            nextUg = uglyNums[pUg[<span class="number">0</span>]] * primes[<span class="number">0</span>];</span><br><span class="line">            pMove = <span class="number">0</span>;</span><br><span class="line">            min = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将质因数同对应的超级丑数相乘，找到最小的那组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; primes.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                min = uglyNums[pUg[i]] * primes[i];</span><br><span class="line">                <span class="keyword">if</span>(min &lt; nextUg)</span><br><span class="line">                &#123;</span><br><span class="line">                    nextUg = min;</span><br><span class="line">                    pMove = i; <span class="comment">// 记录其指针下标方便移动</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果生成的超级丑数和上一个超级丑数的不同，才添加为超级丑数，否则只移动指针</span></span><br><span class="line">            <span class="keyword">if</span>(nextUg!=uglyNums[count<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                uglyNums[count] = nextUg;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            pUg[pMove]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回第n个超级丑数</span></span><br><span class="line">        <span class="keyword">return</span> uglyNums[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/dailyProblem/20210809/ac.png" alt="AC"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
        
      </div>
      
      
      
    </div>
    



    
    
    
  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    

    <div class="sidebar-inner">
      
      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Sunwish</p>
              <p class="site-description motion-element" itemprop="description">个人项目：<br>1. Alterful · 键盘增强：<br>https://alterful.com/<br>2. Easecurve · 缓动引擎：<br>https://easecurve.com/<br>3. AQTS · 自动量化交易系统</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://sunwish.houkaifa.com/" title="Sunwish" target="_blank">Sunwish</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://alterful.com/" title="Alterful" target="_blank">Alterful</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://easecurve.houkaifa.com/" title="Easecurve" target="_blank">Easecurve</a>
                  </li>
                
              </ul>
            </div>
          

          

          
            
          
          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-11-01-237-删除链表中的节点"><span class="nav-text">🟢 2021.11.01 (237. 删除链表中的节点)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-31-500-键盘行"><span class="nav-text">🟢 2021.10.31 (500. 键盘行)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-1"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-1"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-30-260-只出现一次的数字-III"><span class="nav-text">🟠 2021.10.30 (260. 只出现一次的数字 III)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-2"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-2"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-29-335-路径交叉"><span class="nav-text">⚪ 2021.10.29 (335. 路径交叉)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-28-869-重新排序得到-2-的幂"><span class="nav-text">🟠 2021.10.28 (869. 重新排序得到 2 的幂)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-3"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-3"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🔴-2021-10-27-301-删除无效的括号"><span class="nav-text">🔴 2021.10.27 (301. 删除无效的括号)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-4"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-4"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-26-496-下一个更大元素-I"><span class="nav-text">🟢 2021.10.26 (496. 下一个更大元素 I)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-5"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-5"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-25-240-搜索二维矩阵-II"><span class="nav-text">🟠 2021.10.25 (240. 搜索二维矩阵 II)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-6"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-6"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-24-638-大礼包"><span class="nav-text">⚪ 2021.10.24 (638. 大礼包)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-23-492-构造矩形"><span class="nav-text">🟢 2021.10.23 (492. 构造矩形)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-7"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-7"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-22-229-求众数-II"><span class="nav-text">🟠 2021.10.22 (229. 求众数 II)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-8"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-8"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-21-66-加一"><span class="nav-text">🟢 2021.10.21 (66. 加一)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-9"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-9"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-20-453-最小操作次数使数组元素相等"><span class="nav-text">⚪ 2021.10.20 (453. 最小操作次数使数组元素相等)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-19-211-添加与搜索单词"><span class="nav-text">🟠 2021.10.19 (211. 添加与搜索单词)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-10"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-10"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-18-476-数字的补数"><span class="nav-text">🟢 2021.10.18 (476. 数字的补数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-11"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-11"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-17"><span class="nav-text">⚪ 2021.10.17</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-16"><span class="nav-text">⚪ 2021.10.16</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-15-38-外观数列"><span class="nav-text">🟠 2021.10.15 (38. 外观数列)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-12"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-12"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-14-剑指-Offer-II-069-山峰数组的顶部"><span class="nav-text">🟢 2021.10.14 (剑指 Offer II 069. 山峰数组的顶部)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-13"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-13"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-13-412-Fizz-Buzz"><span class="nav-text">🟢 2021.10.13 (412. Fizz Buzz)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-14"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-14"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-12-29-两数相除"><span class="nav-text">🟠 2021.10.12 (29. 两数相除)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-15"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-15"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🔴-2021-10-11-273-整数转换英文表示"><span class="nav-text">🔴 2021.10.11 (273. 整数转换英文表示)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-16"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-16"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-10-441-排列硬币"><span class="nav-text">🟢 2021.10.10 (441. 排列硬币)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-17"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-17"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-10-09-352-将数据流变为多个不相交区间"><span class="nav-text">⚪ 2021.10.09 (352. 将数据流变为多个不相交区间)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-08-187-重复的DNA序列"><span class="nav-text">🟠 2021.10.08 (187. 重复的DNA序列)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-18"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-18"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-07-434-字符串中的单词数"><span class="nav-text">🟢 2021.10.07 (434. 字符串中的单词数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-19"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-19"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-06-414-第三大的数"><span class="nav-text">🟢 2021.10.06 (414. 第三大的数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-20"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-20"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-05-284-窥探迭代器"><span class="nav-text">🟠 2021.10.05 (284. 窥探迭代器)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-21"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-21"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-04-482-密钥格式化"><span class="nav-text">🟢 2021.10.04 (482. 密钥格式化)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-22"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-22"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-10-03-166-分数到小数"><span class="nav-text">🟠 2021.10.03 (166. 分数到小数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-23"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-23"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-02-405-数字转换为十六进制数"><span class="nav-text">🟢 2021.10.02 (405. 数字转换为十六进制数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-24"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-24"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-10-01-1436-旅行终点站"><span class="nav-text">🟢 2021.10.01 (1436. 旅行终点站)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-25"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-25"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-30-223-矩形面积"><span class="nav-text">🟠 2021.09.30 (223. 矩形面积)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-26"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-26"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🔴-2021-09-29-517-超级洗衣机"><span class="nav-text">🔴 2021.09.29 (517. 超级洗衣机)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-27"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-27"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-28-437-路径总和-III"><span class="nav-text">🟠 2021.09.28 (437. 路径总和 III)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-28"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-28"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-09-27-639-解码方法-II"><span class="nav-text">⚪ 2021.09.27 (639. 解码方法 II)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚫-2021-09-26-371-两整数之和"><span class="nav-text">⚫ 2021.09.26 (371. 两整数之和)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-25-583-两个字符串的删除操作"><span class="nav-text">🟠 2021.09.25 (583. 两个字符串的删除操作)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-29"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-29"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-24-430-扁平化多级双向链表"><span class="nav-text">🟠 2021.09.24 (430. 扁平化多级双向链表)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-30"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-30"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-09-23-326-3的幂"><span class="nav-text">🟢 2021.09.23 (326. 3的幂)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-31"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-31"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-22-725-分隔链表"><span class="nav-text">🟠 2021.09.22 (725. 分隔链表)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-32"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-32"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-09-21-58-最后一个单词的长度"><span class="nav-text">🟢 2021.09.21 (58. 最后一个单词的长度)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-33"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-33"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-20-673-最长递增子序列的个数"><span class="nav-text">🟠 2021.09.20 (673. 最长递增子序列的个数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-34"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-34"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-19-650-只有两个键的键盘"><span class="nav-text">🟠 2021.09.19 (650. 只有两个键的键盘)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-35"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-35"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-09-18-292-Nim-游戏"><span class="nav-text">🟢 2021.09.18 (292. Nim 游戏)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-36"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-36"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-09-17-36-有效的数独"><span class="nav-text">🟠 2021.09.17 (36. 有效的数独)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-37"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-37"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-25-797-所有可能的路径"><span class="nav-text">🟠 2021.08.25 (797. 所有可能的路径)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-38"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解（回溯搜索）"><span class="nav-text">题解（回溯搜索）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-24-787-K-站中转内最便宜的航班"><span class="nav-text">🟠 2021.08.24 (787. K 站中转内最便宜的航班)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-39"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解（BFS-剪枝）"><span class="nav-text">题解（BFS+剪枝）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-08-23-1646-获取生成数组中的最大值"><span class="nav-text">🟢 2021.08.23 (1646. 获取生成数组中的最大值)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-40"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-38"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-22-789-逃脱阻碍者"><span class="nav-text">🟠 2021.08.22 (789. 逃脱阻碍者)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-41"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-39"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-21-443-压缩字符串"><span class="nav-text">🟠 2021.08.21 (443. 压缩字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-42"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-40"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-08-20-541-反转字符串-II"><span class="nav-text">🟢 2021.08.20 (541. 反转字符串 II)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-43"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-41"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-08-19-345-反转字符串中的元音字母"><span class="nav-text">🟢 2021.08.19 (345. 反转字符串中的元音字母)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-44"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-42"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🔴-2021-08-18-552-学生出勤记录-II"><span class="nav-text">🔴 2021.08.18 (552. 学生出勤记录 II)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-45"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解（DFS-记忆化搜索）"><span class="nav-text">题解（DFS+记忆化搜索）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟢-2021-08-17-551-学生出勤记录-I"><span class="nav-text">🟢 2021.08.17 (551. 学生出勤记录 I)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-46"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-43"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-16-526-优美的排列"><span class="nav-text">🟠 2021.08.16 (526. 优美的排列)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-47"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解（DFS）"><span class="nav-text">题解（DFS）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-15-576-出界的路径数"><span class="nav-text">🟠 2021.08.15 (576. 出界的路径数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-48"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解（DFS-记忆化搜索）-1"><span class="nav-text">题解（DFS+记忆化搜索）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-08-14-1583-统计不开心的朋友"><span class="nav-text">⚪ 2021.08.14 (1583. 统计不开心的朋友)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-08-13-233-数字-1-的个数"><span class="nav-text">⚪ 2021.08.13 (233. 数字 1 的个数)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-08-12-516-最长回文子序列"><span class="nav-text">⚪ 2021.08.12 (516. 最长回文子序列)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-49"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-44"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#⚪-2021-08-11-446-等差数列划分-II"><span class="nav-text">⚪ 2021.08.11 (446. 等差数列划分 II)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-10-413-等差数列划分"><span class="nav-text">🟠 2021.08.10 (413. 等差数列划分)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-50"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-45"><span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#🟠-2021-08-09-313-超级丑数"><span class="nav-text">🟠 2021.08.09 (313. 超级丑数)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目-51"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解-46"><span class="nav-text">题解</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

          

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sunwish</span>

  

  
</div>


  










<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共 108.4k 字</span>
</div>

<!--
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>
-->
<span class="post-meta-divider">|</span>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"><a href="http://beian.miit.gov.cn/" target="_blank">赣ICP备2022001064号-2</a></span>
</div>


<div>
    <span id="busuanzi_container_site_uv"><i class="fa fa-user"></i> 本站访客<span id="busuanzi_value_site_uv"></span>人次</span>
    <span class="post-meta-divider">|</span>
    <span class="site-pv"><i class="fa fa-eye"></i> 总阅读量: <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
    <!--
    <span class="post-meta-divider">|</span>
    <span class="site-uv"><i class="fa fa-user"></i> 访问人数<span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
    -->
</div>
<script src="./js/src/pvuvfix.js"></script>



        





  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=65941008";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>


  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  








  <!--<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>-->
  
  
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(function (item) {
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'sa3sYJwnqEBnYDpS7VFT70ya-gzGzoHsz',
        appKey: 'TPHHBKrFtoGkcocnjqN78Fue',
        placeholder: 'ヾﾉ≧∀≦)o 文章看完啦，别吝啬你的观点哦',
        avatar:'mm',
        meta:guest,
        pageSize:'10' || 10,
        visitor: true
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  
  <style>
    .copy-btn {
      display: inline-block;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 700;
      line-height: 20px;
      color: #333;
      white-space: nowrap;
      vertical-align: middle;
      cursor: pointer;
      background-color: #eee;
      background-image: linear-gradient(#fcfcfc, #eee);
      border: 1px solid #d5d5d5;
      border-radius: 3px;
      user-select: none;
      outline: 0;
    }

    .highlight-wrap .copy-btn {
      transition: opacity .3s ease-in-out;
      opacity: 0;
      padding: 2px 6px;
      position: absolute;
      right: 4px;
      top: 8px;
    }

    .highlight-wrap:hover .copy-btn,
    .highlight-wrap .copy-btn:focus {
      opacity: 1
    }

    .highlight-wrap {
      position: relative;
    }
  </style>
  <script>
    $('.highlight').each(function (i, e) {
      var $wrap = $('<div>').addClass('highlight-wrap')
      $(e).after($wrap)
      $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function (e) {
        var code = $(this).parent().find('.code').find('.line').map(function (i, e) {
          return $(e).text()
        }).toArray().join('\n')
        var ta = document.createElement('textarea')
        document.body.appendChild(ta)
        ta.style.position = 'absolute'
        ta.style.top = '0px'
        ta.style.left = '0px'
        ta.value = code
        ta.select()
        ta.focus()
        var result = document.execCommand('copy')
        document.body.removeChild(ta)
        
          if(result)$(this).text('复制成功')
          else $(this).text('复制失败')
        
        $(this).blur()
      })).on('mouseleave', function (e) {
        var $b = $(this).find('.copy-btn')
        setTimeout(function () {
          $b.text('复制')
        }, 300)
      }).append(e)
    })
  </script>


</body>
</html>

