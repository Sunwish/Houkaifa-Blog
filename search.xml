<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PushDeer：一种无APP的通知推送解决方案</title>
    <url>/2022/07/24/Pushdeer-notification/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>去年六月，我曾写下一篇博客介绍如何 <a href="https://houkaifa.com/2020/06/21/wechat-notifier/" target="_blank" rel="noopener">借助 ServerChan 实现个人微信通知推送</a>，在那篇文章中介绍了 ServerChan 及其使用方法，总的来说，对于简单的通知需求，使用 ServerChan 是非常简单有效的。但是实际使用起来，其仍有一些非常明显的弊端会暴露出来，使得在真实日常场景中只能强差人意。这两天发现了一种更加有效的移动端通知推送方案：PushDeer，在此做简单的记录与分享。</p>
</blockquote>
<p><img src="/2022/07/24/Pushdeer-notification/1.png" alt="image-20220724205455641"></p>
<a id="more"></a>
<hr>
<h1 id="一、什么是-PushDeer"><a href="#一、什么是-PushDeer" class="headerlink" title="一、什么是 PushDeer"></a>一、什么是 PushDeer</h1><p>使用过 ServerChan 的朋友们应该对手机通知推送的需求不陌生。简单来说，我们有一个软件，它可能是监控类型的（如服务器资源监控），可能是计算类型的（如炼丹），我们需要它能够在特定的条件下主动给我们的手机上发送通知，这样就免得我们要 24h 盯着，或者时不时来检查了。PushDeer 就是这一类问题的一项开源解决方案，与 ServerChan 不同的是，ServerChan 借助微信公众号来发送通知提醒，而 PushDeer 是借助专门的手机端 APP 来推送提醒。</p>
<p><strong>既然都能推送提醒，那么 PushDeer 相比 ServerChan 来讲有什么优势呢？</strong></p>
<ul>
<li><p>首先，通知与微信解耦了，与正常的微信消息通知不会混在一起了；</p>
</li>
<li><p>其次，ServerChan 给微信发的通知无法直接显示通知内容，而需要进入微信-&gt;进入公众号，然后才能看见通知内容。而 PushDeer 能够在锁屏界面，或者是手机顶部弹出来的通知栏中直接看到通知内容，一目了然；</p>
</li>
<li><p>最后，PushDeer 是开源解决方案，支持自架服务器，并且支持 docker compose 快速部署，服务可以掌握在自己手上，而 ServerChan 无法避免地要依赖于方糖的公众号。</p>
</li>
</ul>
<p>如果访问 <a href="https://www.pushdeer.com/" target="_blank" rel="noopener">PushDeer 的官网</a>，你会在「什么是 PushDeer」页面看到这样的自述：PushDeer 是一个开源的无 APP 推送解决方案，其<strong>特色</strong>包括：「易用」、「可控」和「渐进」。其中三个关键词的解释在此就不赘述，<strong>那么什么是所谓的无 APP 推送解决方案呢？PushDeer 的逻辑又是什么呢？</strong></p>
<ul>
<li><p>所谓无 APP 并不是说不需要 APP 就能给手机推消息，这是不可能的，这个无 APP 指的是你无需开发自己的 APP，直接用 PushDeer 的 APP 就可以了，并且 PushDeer 的 APP 也是开源的，有需要的话完全可以自己魔改然后上架，但其实直接使用官方上架的 APP 就可以了。</p>
</li>
<li><p>PushDeer 的推送逻辑我按照个人理解画下了图1-1，供参考。首先在手机上连接 PushDeer 服务端，将本设备绑定到服务端上，然后生成一个或多个用于接收通知的 Key。而在你的程序端，你需要拿着设备上生成的 Key 和要推送的消息内容丢给服务端，服务端找一找这个 Key 是属于哪个设备的，然后将消息推送给相应的设备即可。</p>
<p><img src="/2022/07/24/Pushdeer-notification/image-20220724225616058.png" alt="image-20220724225616058" style="zoom:80%;"></p>
</li>
</ul>
<center>图 1-1 PushDeer 推送逻辑</center>

<h1 id="二、如何使用-PushDeer"><a href="#二、如何使用-PushDeer" class="headerlink" title="二、如何使用 PushDeer"></a>二、如何使用 PushDeer</h1><p>PushDeer 提供两种版本，一种是官方在线版，一种是自架版。</p>
<p>官方在线版顾名思义，就是图1-1中的 PushDeer Server 端已经帮你部署好了，PushDeer App 也是直连官方服务器，你要做的只是登上 App 去拿个 Key，然后给你的程序用就行了。</p>
<p>而自架版同样顾名思义，就是 PushDeer Server 要自己部署，此外 PushDeer App 要使用特别的 「PushDeer·自架版」，在自架版 App 中可以手动指明要连接的自己部署 PushDeer 服务端的服务器地址，以进行进一步的操作。而至于 Your Program 到 PushDeer Server 这一步，就和 ServerChan 一样，是走的简单粗暴的 HTTP 请求。</p>
<p>具体的操作，如果是官方在线版，那么直接扫码打开轻应用或者前往 App Store 下载完整 App，登录，绑定设备，生成 Key 即可完成手机端的工作，程序端则按照以下格式向官方服务端发起 HTTP 请求即可：    </p>
<ul>
<li>发送文字：<code>https://api2.pushdeer.com/message/push?pushkey=key&amp;text=要发送的内容</code></li>
<li>发送图片：<code>https://api2.pushdeer.com/message/push?pushkey=&lt;key&gt;&amp;text=&lt;图片URL&gt;&amp;type=image</code></li>
<li>发送 Markdown：<code>https://api2.pushdeer.com/message/push?pushkey=&lt;key&gt;&amp;text=标题&amp;desp=&lt;markdown&gt;&amp;type=markdown</code></li>
</ul>
<blockquote>
<p>在URL中可以用<code>%0A</code>换行，当参数中有特殊字符时，需要进行 urlencode，因此更建议通过函数或者SDK发送。</p>
<p>安卓平台的快应用尚在开发，可下载并安装 Android 测试版 APP (<a href="https://github.com/easychen/pushdeer/releases/tag/android1.0alpha" target="_blank" rel="noopener">GitHub</a>|<a href="https://gitee.com/easychen/pushdeer/releases/android1.0alpha" target="_blank" rel="noopener">Gitee</a>)。</p>
</blockquote>
<p><img src="https://www.pushdeer.com/images/2022-02-03-17-55-30.png" alt="img" style="zoom:80%;"></p>
<center>图 2-1 官方在线版 App Clip</center>

<p>对于自架版，首先在服务器上拉取服务端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/easychen/pushdeer.git</span><br><span class="line">cd pushdeer</span><br><span class="line">sudo docker-compose -f docker-compose.self-hosted.yml up --build -d</span><br></pre></td></tr></table></figure>
<p>完成后访问服务器的 8800 端口（注意记得放行相应端口），能够正常访问则说明服务端部署成功。后面的步骤和官方在线版就几乎一样了，区别仅仅是：</p>
<ol>
<li>手机端要使用自架版轻应用或 App；</li>
<li>程序端的接口地址记得修改为自架服务端的地址；</li>
</ol>
<p><img src="https://www.pushdeer.com/images/2022-02-03-17-51-26.png" alt="img" style="zoom:80%;"></p>
<center>图 2-2 自架版 App Clip</center>

<p><strong>需要注意的是：</strong></p>
<ul>
<li>自架服务器端需每年2月拉取一次更新推送证书</li>
<li>轻应用方式绑定的设备，如果 30 天未使用，轻应用将被 iOS 自动清理，届时设备 id 失效，无法给这个设备推送了。其实也就是图1-1中通过 Key 找到的设备 id 失效了，推不出去，那么需要重新绑定，重新生成 Key，并在程序端更新目标 Key 才能推送。因此其实相比图新鲜使用 App Clip，还是下载下来用更靠谱。</li>
</ul>
<p>最后，如果你一点代码都懒得写的话，其实 PushDeer 已经有了一些常用语言的 SDK，包括 <a href="https://gitee.com/mrbread/pushdeer_csharp_sdk" target="_blank" rel="noopener">C#</a>、<a href="https://gitee.com/mrbread/pushdeer-java-sdk" target="_blank" rel="noopener">Java</a>、<a href="https://github.com/gaoliang/pypushdeer" target="_blank" rel="noopener">Python</a>、<a href="https://github.com/iepngs/pushdeer-backend-go" target="_blank" rel="noopener">Go</a> 和 <a href="https://github.com/xkrfer/pushdeer-node" target="_blank" rel="noopener">Node</a>，因此如果你的项目是由以上几种语言编写的，那么程序端你只需要导一下热心网友的 SDK 包，然后直接调 API 往里喂参数就完事了。<em>（小声bb：也没必要这么懒吧，有导包的那会儿功夫自己都实现完了</em></p>
<h1 id="三、实际使用效果"><a href="#三、实际使用效果" class="headerlink" title="三、实际使用效果"></a>三、实际使用效果</h1><p>我使用自架版，将 PushDeer 应用到了我的一个个人开源小工具「<a href="https://github.com/Sunwish/TraderHelper" target="_blank" rel="noopener">TraderHelper</a>」上，用户只需要扫码使用 App Clip，或者下载自架版 App，绑定设备生成一下 Key，最后把 Key 填入程序中，就可以在手机上收到自己自选股设定的价格预警了。</p>
<p><img src="/2022/07/24/Pushdeer-notification/QQ图片20220724230627.jpg" alt="QQ图片20220724230627" style="zoom: 25%;"></p>
<center>图 3-1 PushDeer 推送效果测试</center>

<p>所以说，PushDeer 其实不仅仅能开发者自用（如服务器负载预警、服务器异常推送、定时任务推送等），同时开发者也可以借助 PushDeer，在不额外开发自己软件的移动端的情况下，给用户提供「通知」这一拓展服务，只不过就是需要给用户一些引导，指引其完成设备的绑定、Key 的生成，以及将 Key 提供给程序这三个步骤罢了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>PushDeer</tag>
        <tag>Notification</tag>
      </tags>
  </entry>
  <entry>
    <title>导出镜像备份阿里ECS并在本地虚拟机中运行</title>
    <url>/2021/07/03/ECS-backup-run-in-vmware-workstation/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>事情是这样的，阿里云原先的云翼计划没有了，云翼机器也无法再按价续费，而通过新的开发者计划购买的轻量应用服务器又不支持从ECS迁移，因此为了备份数据，避免服务器过期后资源被释放造成不可逆损失，故尝试导出镜像对原服务器做备份。此外，为了在本地重现环境，还可将RAW转为VMDK后于虚拟机中运行。</p>
</blockquote>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、导出镜像"><a href="#一、导出镜像" class="headerlink" title="一、导出镜像"></a>一、导出镜像</h1><p>在阿里云服务器实例列表中找到要备份的服务器，选择“数据保存”。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/2.png" alt="Title"></p>
<p>选择“创建自定义镜像”。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/3.png" alt="Title"></p>
<p>填写镜像名称和描述后开始创建镜像。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/4.png" alt="Title"></p>
<p>在“实例与镜像”→“镜像”中可以看到镜像的创建进度。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/5.png" alt="Title"></p>
<div class="spoiler collapsed"><div class="spoiler-title">关于异地镜像迁移</div><div class="spoiler-content"><p>如果有两台ECS，并且不想要备份镜像到本地，而是希望将一台ECS生成的镜像备份到另一台ECS上跑，而两台ECS不在同一地区的话，需要迁移（复制）镜像。</p>
<p>在镜像生成完毕后，镜像选卡页会出现“复制镜像”选项，选择后指定目标地域和自定义名称即可。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/6.png" alt="Title"></p>
<p>等待镜像复制。注意，复制任务的进度需要切换至目标地区的“镜像”页查看。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/7.png" alt="Title"></p>
</div></div>
<p>创建完成后“导出镜像”。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/8.png" alt="Title"></p>
<p>授权访问。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/9.png" alt="Title"></p>
<p>导出到Bucket。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/10.png" alt="Title"></p>
<p>如果没有的话需要先创建Bucket。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/11.png" alt="Title"></p>
<p>导出完成后在Bucket中对镜像进行解冻。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/12.png" alt="Title"></p>
<p>解冻收费标准。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/13.png" alt="Title"></p>
<p>根据标准和镜像大小就可以确认费用，确定解冻。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/14.png" alt="Title"></p>
<p>等待解冻。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/15.png" alt="Title"></p>
<p>解冻完成后就可以下载了。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/16.png" alt="Title"></p>
<h1 id="二、导入本地虚拟机（VMware-workstation）"><a href="#二、导入本地虚拟机（VMware-workstation）" class="headerlink" title="二、导入本地虚拟机（VMware workstation）"></a>二、导入本地虚拟机（VMware workstation）</h1><p>使用 qemu-img 将下载下来的RAW格式镜像转换为vmdk虚拟磁盘。</p>
<div class="spoiler collapsed"><div class="spoiler-title">qemu-img-win-x64-2_3_0.zip (3.4M)</div><div class="spoiler-content"><p>链接: <a href="https://pan.baidu.com/s/1jH3GqwwOcfHFb-M9SfBuag" target="_blank" rel="noopener">https://pan.baidu.com/s/1jH3GqwwOcfHFb-M9SfBuag</a><br>提取码: 6wdn</p>
</div></div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./qemu-img convert -O vmdk InputRawFileName.raw OutputVMDKFileName.vmdk</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/17.png" alt="Title"></p>
<p>转换完成。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/17.5.png" alt="Title"></p>
<p>在VM中新建虚拟机。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/18.png" alt="Title"></p>
<p>创建自定义虚拟机。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/19.png" alt="Title"></p>
<p>稍后安装操作系统。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/20.png" alt="Title"></p>
<p>一路到选择磁盘处，使用现有虚拟磁盘。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/21.png" alt="Title"></p>
<p>选择转换得到的vmdk虚拟磁盘。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/22.png" alt="Title"></p>
<p>保持现有格式即可。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/23.png" alt="Title"></p>
<p>创建完成后，启动虚拟机，在开机时点按方向键，使用 rescue 启动。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/24.png" alt="Title"></p>
<p>完成。</p>
<p><img src="/2021/07/03/ECS-backup-run-in-vmware-workstation/25.png" alt="Title"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>趣谈双端离线状态下的授权认证实现</title>
    <url>/2021/05/25/Thinking-of-double-end-offline-authorization-verification/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>昨天 Anduin 在直播时讨论了一个相当有意思的话题，即在客户端和服务端均处于离线状态，且双端之间没有任何数据交换的情况之下，如何实现客户端对服务端的临时授权。其实类似的授权机制在生活中就有案例，比如我手机上的Steam令牌应用自登录以来就从来没连上网过，但是令牌中的动态密码却能够正确地完成电脑端Steam的身份认证，不过这里电脑端的Steam还是连接了网络进行验证的。本文来尝试探讨一种双端均处于离线状态场景的临时认证办法。因为没有查阅相关资料做参考，因此本文最终的系统不一定足够完美。</p>
</blockquote>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、情景导入"><a href="#一、情景导入" class="headerlink" title="一、情景导入"></a>一、情景导入</h1><p>假设一天周末小明出去浪了，而小明的好基友小黑在没有提前打招呼的情况下突然来小明家玩儿，当小黑到了小明的家门口敲门时却发现，小明家里此刻并没有人，于是小黑打电话给小明说，“小明小明你人呢，我到你家门口了，速来击剑🤺！”</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/2.png" alt="Title"></p>
<p>可是小明现在还在外面浪所以并不能很快地赶回家里和小黑击剑，只能先让小黑在外面晾几个小时。因为小明家里的门锁是电子的密码门锁，于是小黑想让小明把密码告诉他，让自己进去等小明，可是小明知道把自家门锁的密码告诉别人这件事实在是太危险了，尽管是告诉自己的好基友小黑也不是那么地靠谱。那么有没有什么办法能够改造一下小明家的门锁，让小黑能够临时进去一下，同时又不泄漏小明家的密码呢？</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/3.png" alt="Title"></p>
<p>如果小明把密码直接告诉给小黑肯定是不安全的，就算后续可以回家修改密码也会让家人非常不方便。其实如果小明家里的锁是智能锁的话问题就很简单，小明直接在手机APP上远程开锁即可，又或者可以尝试在手机APP上生成一个临时密码，这个临时密码存储在服务器上，锁端只需要在验证的时候通过连接服务器进行密码校验即可。但是问题在于小明家的门锁是智障锁，压根没有网络功能，也就无法远程开锁，也不存在连接服务器验证新密码这回事。</p>
<p>那么如何才能让小明在远端生成一个临时密码，同时在锁端完全离线的状况下识别出这个密码，实现小明对小黑的临时的授权呢？</p>
<h1 id="二、从简单的动态密码说起"><a href="#二、从简单的动态密码说起" class="headerlink" title="二、从简单的动态密码说起"></a>二、从简单的动态密码说起</h1><p>其实一通分析下来很容易发现，这个问题的核心就是需要锁密码能够动态变化，达到一个临时开锁的目的。既然是要使得密码动态起来，那么一个很容易想到的办法就是将密码规则设置为动态的。比如根据时间来确定门锁的密码，使得每一天的门锁密码都不一样：</p>
<script type="math/tex; mode=display">
f(y,m,d)=43y+8848m+6666d</script><p>例如今天是2021年5月25日，那么今天的密码经过函数 $f$ 计算就是297793，锁在验证的时候首先计算出297793这个值，然后将其与开门者输入的密码相比较，如果匹配则开门。在这一策略下，小明可以很放心地把这个密码告诉小黑，因为这个密码只能解锁今天的门锁，等到明天，门锁根据函数计算出来的正确密码就变成了304459，这时再用297793就无法打开门锁了。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/4.png" alt="Title"></p>
<p>如果要有更好的动态性，只需要向锁函数引入更精细的时间量即可，如使用下式就能够使得每分钟的门锁密码都不一样：</p>
<script type="math/tex; mode=display">
f(y,m,d,h,min)=c_1y+c_2m+c_3+c_4h+c_5min</script><p>这样将密码函数写死在锁里的做法确实可以实现锁端离线状态下对小黑的临时授权，只要小明记得密码函数，他就可以通过计算得到锁端的当前密码是多少，锁因为只使用了时间进行计算因此也不必联网。但是这么做会有两个很明显的缺陷：</p>
<ol>
<li>锁函数是容易被破解的。一旦锁函数被破解，那么全世界的人都能够随时计算出小明家今天的密码从而破门而入强行击剑了；</li>
<li>密码的计算很不方便。如果是分钟精度，那么小明每次需要临时密码时都得掏出纸笔计算一波。</li>
</ol>
<h2 id="2-1-关于缺陷一"><a href="#2-1-关于缺陷一" class="headerlink" title="2.1 关于缺陷一"></a>2.1 关于缺陷一</h2><p>第一个缺陷很显然，只要小黑厚着脸皮多向小明要几次密码，经过数据分析就容易得出每天密码的生成规律，进而推出锁函数，就算使用更加复杂的非线性函数，只要最终的密码与时间这种量直接相关，同样总有被破解的一天。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/5.png" alt="Title"></p>
<p>但其实只要对函数计算出来的密码进行进一步的处理，如哈希处理，再进行有损截取，就很难被复原了，比如：</p>
<script type="math/tex; mode=display">
password = GetDeterministicHashCode(f(y,m,d,h,min))\%1000000</script><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数名在后文中简记作 Hash</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetDeterministicHashCode</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unchecked</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hash1 = (<span class="number">5381</span> &lt;&lt; <span class="number">16</span>) + <span class="number">5381</span>;</span><br><span class="line">        <span class="keyword">int</span> hash2 = hash1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.Length; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash1 = ((hash1 &lt;&lt; <span class="number">5</span>) + hash1) ^ str[i];</span><br><span class="line">            <span class="keyword">if</span> (i == str.Length - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            hash2 = ((hash2 &lt;&lt; <span class="number">5</span>) + hash2) ^ str[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash1 + (hash2 * <span class="number">1566083941</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/6.png" alt="Title"></p>
<p>经过哈希函数一处理，如何计算 $f(y,m,d,h,min)$ 其实已经不要紧了，因此我们可以直接将年月日时分的文本信息作为动态量，如我现在写博文的时间18点34分的密码就为</p>
<script type="math/tex; mode=display">
password = Hash(20215251834)\%1000000 = 895870</script><p>但是，实际上哈希函数也并不是什么稀奇的函数，所以单纯对当前时间做哈希同样很容易被猜到，进而被小黑破解，因此我们可以将哈希参数复杂化一些，如混上一些静态字段：</p>
<script type="math/tex; mode=display">
password = Hash(DateTime+"Sunwish")\%1000000</script><p>这样一来，尽管小黑猜到了锁函数使用的是哈希码截断，也猜到了哈希参数使用了动态的时间来实现密码的变化，但是只要猜不到参数中混入了“Sunwish”这个字段，小黑就无法复现认证码。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/7.png" alt="Title"></p>
<p>至此第一个问题，“锁函数是容易被破解的”就算基本解决了。</p>
<h2 id="2-2-关于缺陷二"><a href="#2-2-关于缺陷二" class="headerlink" title="2.2 关于缺陷二"></a>2.2 关于缺陷二</h2><p>对于第二个问题，即“密码的计算很不方便”，在经过第一个问题的解决之后，密码计算变得更加不方便了，现在几乎就不可能被手算出来。</p>
<p>好在这个算法是我们自己设计的，因此只需要开发相应的APP，在需要使用临时密码的时候打开 APP 查看即可，而这个 APP 只需要负责计算 $Hash(DateTime+”Sunwish”)\%1000000$ 的值并显示出来。这样，小明只需要打开 APP，然后将此时的密码告诉小黑就能让小黑打开房门，同时因为临时密码是变动的，因此小黑之后再使用这个密码是无法打开门锁的，保证了门锁的安全性。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/8.png" alt="Title"></p>
<p>这样一来看似问题解决了，<strong>但要命的是，这个多出来的 APP 又引发了新的更严重的安全隐患。</strong></p>
<p>虽然小黑拿到的密码只能够临时使用，同时就算小黑拿到了很多的密码也难以解出密码的规律了，但是一个很严重的问题就是，现在门锁的可靠性完全依赖于小明的手机了，任何人只要进入了小明的手机，就能够随意查看小明家门的密码，更严重的是，如果小明使用的手机是安卓系统，那么小黑只需要偷偷从小明手机上把 apk 拷到自己手机上，小黑就能神不知鬼不觉地随时在自己手机上查看小明家门的密码，这肯定是不能被小明容忍的。</p>
<h1 id="三、APP与锁的解耦"><a href="#三、APP与锁的解耦" class="headerlink" title="三、APP与锁的解耦"></a>三、APP与锁的解耦</h1><p>哦豁，既要使用 APP 来查看临时密码，又不能让别人在 APP 里看到临时密码，咋办？</p>
<h2 id="3-1-密码锁"><a href="#3-1-密码锁" class="headerlink" title="3.1 密码锁"></a>3.1 密码锁</h2><p>一个非常符合直觉的方法是给密码加密码，即需要输入正确的应用密码才能够查看门锁的临时密码。这个办法看似能够缓解缺陷二，因为小黑就算拿到了小明的手机，没有 APP 的查看密码就无法进入门锁密码的查看页，也就拿不到当前的门锁密码。</p>
<p>但其实这个方法仍有缺陷，小黑可以通过一些手段搞到小明的 APP 文件，然后对应用程序进行逆向工程拿到应用密码，甚至可以直接暴破小明的 APP，跳过应用的密码页，因此简单的密码锁并不是很靠谱。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/9.png" alt="Title"></p>
<h2 id="3-1-隐式密码"><a href="#3-1-隐式密码" class="headerlink" title="3.1 隐式密码"></a>3.1 隐式密码</h2><p>另一个更精妙的保护设计是不使用显式的密码锁，而是将哈希混淆字段作为应用密码，同门锁的加密函数相耦合，使得应用密码输入成为不可绕过（不可被暴破）的门锁密码生成过程之一，同时完全避免了密码输入正确与否的回显提示，使企图的 APP 破解工作雪上加霜。耦合后的锁函数就变成了</p>
<script type="math/tex; mode=display">
password = Hash(DateTime+AppPsw)\%1000000</script><p>其中 AppPsw 是由 APP 使用者来输入的，只有在输入了正确的混淆字段“Sunwish”，才能生成正确的、能被锁端接受的认证码（因为锁端 AppPsw 字段是固定的“Sunwish”，且双端运行的锁函数是一致的，因此只要参数一致双端就能生成相同的认证码实现验证，不需要网络），同时如果 AppPsw 输入错误，应用也不会报错，而是会按照错误的哈希参数生成错误的认证码，但破解者小黑是无法得知其是否正确的，在小黑的视角看来，无论输入什么内容总是能够生成一个认证码，但是生成的认证码却无法解锁门锁，让人摸不着头脑，这使得破解变得更加不可能，因为 APP 上密码正确与否的评判标准都已经不存在了。</p>
<p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/10.png" alt="Title"></p>
<p>不过还没结束，这个系统仍然存在一些隐患。由于 APP 端所谓的“密码”就是锁端哈希参数的混淆字段，而此时混淆字段是被明文写在锁端的，因此只要小黑身手不凡，还是能够通过拆解小明家的锁，从硬件电路层面破解芯片中存储的内容，即从硬件角度破解出锁中的“Sunwish”字段，然后再偷来小明的APP，输入“Sunwish”就可以正确地生成门锁密码。</p>
<p>因此，锁端附加字段最好要做 MD5 加密处理：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetMD5</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Use input string to calculate MD5 hash</span></span><br><span class="line">    <span class="keyword">using</span> (System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] inputBytes = System.Text.Encoding.ASCII.GetBytes(input);</span><br><span class="line">        <span class="keyword">byte</span>[] hashBytes = md5.ComputeHash(inputBytes);</span><br><span class="line">        <span class="comment">// Convert the byte array to hexadecimal string</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hashBytes.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.Append(hashBytes[i].ToString(<span class="string">"X2"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时在 APP 端也要对称地将 AppPsw 做加密操作，即临时密码计算函数变为</p>
<script type="math/tex; mode=display">
password = Hash(DateTime+MD5(AppPsw))\%1000000</script><p>以“Sunwish”为例，经过加密后存储使用，小黑只能从门锁中破解出：</p>
<script type="math/tex; mode=display">
1BE859CD2B258B2187E49B98F1A30201</script><p>这对于小黑来说几乎不可能逆向出原密码，也就仍然无法使用小明的 APP，此时唯一的密钥“Sunwish”只有小明知道，并且只会在小明使用 APP 输入时短暂地存在于内存中，一旦生成认证码密钥就将无影无踪，只有输入了这个正确的答案才能生成正确的，能与锁端达成共识的认证码打开门锁。</p>
<h1 id="四、升级门锁辣！"><a href="#四、升级门锁辣！" class="headerlink" title="四、升级门锁辣！"></a>四、升级门锁辣！</h1><p>可以注意到整个过程中，门锁与APP均始终处于离线状态，且门锁和APP之间不存在任何数据交换，小明在 APP 中生成的认证码只有临时可用，且只有小明才能使用 APP 生成正确的认证码，其它任何人都无法从 APP 获取有效的认证码，APP 破解也因为没有密码正确与否的评判依据而举步维艰，安全性基本得到了保证，整个系统中唯一的密钥就是存在小明脑子里的“Sunwish”字段。至此，我们就解决了小明小黑的双端离线授权问题。</p>
<p>最后我们处理一些细节问题，并实现认证码5分钟内有效的逻辑，并将这个系统封装一下。</p>
<h2 id="4-1-公共部分"><a href="#4-1-公共部分" class="headerlink" title="4.1 公共部分"></a>4.1 公共部分</h2><p>其中一个问题是 <code>int GetDeterministicHashCode(string)</code> 函数的返回整数有可能是负数，同时经过 $\%1000000$ 运算后的数值位数并不是固定的，因此我们封装一个认证码生成函数，利用哈希参数生成固定位数的正值认证码（其中 <code>VALICODE_LENGTH</code> 是全局常量，指明认证码的长度）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetDeterministicValidationCode</span>(<span class="params"><span class="keyword">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 生成正值认证码，位数取值范围为 [1, VALICODE_LENGTH]</span></span><br><span class="line">    <span class="keyword">int</span> valiCode = Math.Abs(GetDeterministicHashCode(str) % (<span class="keyword">int</span>)Math.Pow(<span class="number">10</span>, VALICODE_LENGTH));</span><br><span class="line">	<span class="comment">// 认证码位数处理成固定 VALICODE_LENGTH 位，低位补零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VALICODE_LENGTH - valiCode.ToString().Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        valiCode *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valiCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是动态参数——时间文本的封装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetDateAttach</span>(<span class="params">DateTime dateTime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> dateAttach =</span><br><span class="line">        dateTime.Year.ToString() +</span><br><span class="line">        dateTime.Month.ToString() +</span><br><span class="line">        dateTime.Day.ToString() +</span><br><span class="line">        dateTime.Hour.ToString() +</span><br><span class="line">        dateTime.Minute.ToString();</span><br><span class="line">    <span class="keyword">return</span> dateAttach;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-APP-端"><a href="#4-2-APP-端" class="headerlink" title="4.2 APP 端"></a>4.2 APP 端</h2><p>生成临时认证码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Generate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入隐式密码</span></span><br><span class="line">    Console.Write(<span class="string">"Input password to generate a tempory offline validation code: "</span>);</span><br><span class="line">    <span class="keyword">string</span> psw = Console.ReadLine().Trim();</span><br><span class="line">	<span class="comment">// 对输入的密码做一次MD5加密</span></span><br><span class="line">    <span class="keyword">string</span> psw_md5 = GetMD5(psw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取动态参数，即时间</span></span><br><span class="line">    <span class="keyword">string</span> dateAttach = GetDateAttach(DateTime.Now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 混淆时间和一次加密后的密码进行认证码生成</span></span><br><span class="line">    <span class="keyword">int</span> validationCode = GetDeterministicValidationCode(psw_md5 + dateAttach);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出5分钟内有效的临时认证码（APP端只管生成认证码，多长时间有效的判定逻辑在锁端）</span></span><br><span class="line">    Console.WriteLine(<span class="string">$"Validation code: <span class="subst">&#123;validationCode&#125;</span> (Valide in 5 minites)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-门锁端"><a href="#4-3-门锁端" class="headerlink" title="4.3 门锁端"></a>4.3 门锁端</h2><p>定义好预先存储在门锁里的已经经过一次加密过的隐式密码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">string</span> psw_md5 = <span class="string">"1BE859CD2B258B2187E49B98F1A30201"</span>;</span><br></pre></td></tr></table></figure>
<p>对认证码进行有效性验证：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Check</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输入待验证的认证码</span></span><br><span class="line">    Console.Write(<span class="string">"Please input validation code: "</span>);</span><br><span class="line">    <span class="keyword">string</span> validationCode = Console.ReadLine().Trim();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算包含当前时刻的过去5分钟有效认证码，共5条</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; validList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 过去5分钟的五条动态参数</span></span><br><span class="line">        DateTime dateAttach = DateTime.Now - TimeSpan.FromMinutes(i);</span><br><span class="line">		<span class="comment">// 5个动态参数计算出的五条认证码</span></span><br><span class="line">        validList.Add(GetDeterministicValidationCode(psw_md5 + GetDateAttach(dateAttach)).ToString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只要输入的认证码同五条有效认证码的任意一个匹配，则认证通过</span></span><br><span class="line">    <span class="keyword">if</span>(validList.IndexOf(validationCode) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Code is valid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Code is invalid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-效果演示"><a href="#4-3-效果演示" class="headerlink" title="4.3 效果演示"></a>4.3 效果演示</h2><p><img src="/2021/05/25/Thinking-of-double-end-offline-authorization-verification/11.png" alt="Title"></p>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"></div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Authorization</tag>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>末流科班一战上岸中科大软院初试复试经验总结</title>
    <url>/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇记录了我作为一名末流双非科班学生，一战备考中国科学技术大学软件学院并成功上岸的经验总结。我将在本文中详尽地回忆自四月以来我初试复习的各科规划、时间管理、学习方法、以及复试内容的问答回忆。需要说明的是，本文内容具有很强的主观性，是我个人复习过程的梳理和总结，故文中内容及所给的一切建议请自行斟酌，选择性吸收，切勿盲目照搬。</p>
</blockquote>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、综述"><a href="#一、综述" class="headerlink" title="一、综述"></a>一、综述</h1><p>首先声明：相对来说，我的初试分数不高，区区410分在21科软400+400+的奇观年中只能瑟瑟发抖，本文也仅仅是我个人一年以来复习经验的回忆录，文中所有的学习方法和复习建议均带有强烈的主观性，如需参考，请读者充分发挥主观能动性，择适吸收，对于与你观点冲突的观点，请以你自己的观点为准，你就是对的。</p>
<p>在这篇总结中，我会侧重于规划思路的记录。主要原因是，简单地陈述每个时间段用了什么书、做了什么事这种经验帖网上有很多了，我自己也是看着这些经验帖一路走过来的，因此我更想侧重一些不一样的角度来分享，比如思路方面、策略方面的分享，希望能给到今后考研的小伙伴们，或者说是为如何去计划考研感到迷茫的朋友们一些小小的帮助吧。当然，我的相关具体复习时间和参考用书也是会穿插提到的。</p>
<p>同时对于22想报考科软的朋友们，结合今年的形式我也有几点建议：</p>
<ul>
<li><strong>不能接受初试以390分为基础目标的，谨慎报考</strong>。22可能有一批21高分考生因为复试都没进又没走调剂，心系科软不甘淘汰而再来一年与你们同台竞争。也会有一些预测22爆冷来抄底的，相信他们也会做好22依旧温暖的心理准备来复习。</li>
<li><strong>本科非计算机相关专业的跨考生，谨慎报考</strong>。科软历来不歧视跨考生，甚至有“跨考天堂”的美称，但今年情况有变，机试难度陡升，有很多代码题，对跨考生确实很不友好，22机试形势如何就是未知数了，故若决定跨考科软，可做好相应准备。</li>
<li><strong>不能接受数二英二调剂的考生，谨慎报考</strong>。需要明确科软初试考数二英二，而其他院校大多已经是考数一英一了，故若没进复试或复试被刷，那么能调剂的外校选择是不如11的，虽然有校内调剂机会，但是今年校内先研调剂是优先数一英一，若11收完仍不够，22才有顺补的机会。</li>
</ul>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/6.png" alt="Title"></p>
<center><b>图1 多少高分hxd的血泪堆出来的数据</b></center>

<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/2.png" alt="Title"></p>
<center><b>图2 初试成绩</b></center>

<h2 id="1-整体规划"><a href="#1-整体规划" class="headerlink" title="1. 整体规划"></a>1. 整体规划</h2><p>总的来说，我是采取循序渐进的策略，或者说增量复习的思路吧，也就是从高数开始，逐步引入各科复习。</p>
<p>大约在四月初的时候，我确定了要考研并开始着手了解行情、收集资料，四月中旬初步开始着手复习。远观，在四月、五月、六月整整三个月期间，我只进行了数学复习，并在六月底开始408复习，八月初开始英语复习，九月初开始政治复习；近看，四月中到五月中是高数复习，五月中后才引入线代复习，408也是同理，从数据结构单科开始，逐步引入计组、操作系统和计网的复习。</p>
<center><b>表1 个人渐进表</b></center>

<div class="table-container">
<table>
<thead>
<tr>
<th>大致时期</th>
<th>在习科目</th>
</tr>
</thead>
<tbody>
<tr>
<td>四月中~五月中</td>
<td>高数</td>
</tr>
<tr>
<td>五月中~七月中</td>
<td>高数、线代</td>
</tr>
<tr>
<td>六月中~七月初</td>
<td>高数、线代、数据结构</td>
</tr>
<tr>
<td>七月初~八月初</td>
<td>高数、线代、数据结构、计组</td>
</tr>
<tr>
<td>八月初~八月中</td>
<td>高数、线代、数据结构、计组、计网、英语</td>
</tr>
<tr>
<td>八月中~九月初</td>
<td>高数、线代、数据结构、计组、计网、英语、操作系统</td>
</tr>
<tr>
<td>九月初~十二月</td>
<td>高数、线代、数据结构、计组、计网、英语、操作系统、政治</td>
</tr>
</tbody>
</table>
</div>
<p>这样做最大的好处是不会一下开始多门新课的学习造成太大的压力，能更容易地进入备考状态，每门课都能拥有属于自己的独立渡入期，毕竟不是每个人都能够一下平衡和接受那么多课程的任务和负担，也不是每一个人都可以一开始就在一天中高效吸收多门科目的知识。这样做的第二个好处是能够更好地打好数学及专业课基础，由于前期只有数学复习任务，你可以有足够的专心和沉浸来学习和理解数学中繁多的知识点，这不论是心理上还是实践上都能够更好地让人接受。</p>
<p>对大部分人来说，考研的备战过程会是一场马拉松，想要取得好的成绩，我以为时间上的付出是必不可少的。因此，如果选择要考研，那么最好尽早下定决心，拖得越晚开始只会使得自己的后期时间紧张，尤其是考408的话，一定要尽早复习，408工科最难专业课的“美誉”不是白瞎的。</p>
<h2 id="2-复习形式"><a href="#2-复习形式" class="headerlink" title="2. 复习形式"></a>2. 复习形式</h2><p>复习形式指的是复习过程中，选择纸质学习还是无纸化学习。此两者各有优劣，宜按照个人情况理性选择。</p>
<p>纸质学习的优点之一在于能够容易地静心复习，在控制好手机的前提下能够杜绝各种信息的干扰。优点之二在于纸质书更有仪式感，翻阅起来也更加方便和快捷。但关键缺点在于纸质笔记想要记地合理与美观（指看上去整洁清爽）并不容易，同时难于整理和调整。也不排除有人屏幕一看久就眼睛疼等问题。</p>
<p>无纸化学习最大的优点在于对资料、笔记的整理非常友好，你可以轻松无代价地在平板上调整、扩充你的笔记和框架，同时不需要携带一堆沉重的书，物理负担几乎没有。这点在后面的笔记分享中你可以感受得到。但关键缺点在于你容易被平板上的其它娱乐诱惑，导致复习前生产力，复习后爱奇艺。。</p>
<p>我个人选择的是无纸化学习，而克服缺点的办法也十分简单粗暴：我不会允许自己在自己的平板上下载任何与考研复习无关的应用。在整个考研期间，我的平板上没有优酷、爱奇艺和任何游戏及娱乐APP，并且关闭了一切不必要应用推送，只保留了日历和提醒事项推送。因此我的建议是，<strong>如果选择了无纸化复习，那么请尽量使你的平板在考研复习的这一年里成为纯粹的电子笔记本和网课播放器。</strong>当你习惯于无纸化学习，我认为在某些方面的效率上是能够吊打纸质学习的。</p>
<h1 id="二、各科规划"><a href="#二、各科规划" class="headerlink" title="二、各科规划"></a>二、各科规划</h1><p>下面将按照各科目起始复习时间的顺序线性展开我个人的各科复习规划，分阶段包括课程选择、参考书目等方面。</p>
<h2 id="1-数学（二）"><a href="#1-数学（二）" class="headerlink" title="1. 数学（二）"></a>1. 数学（二）</h2><h3 id="1-1-高等数学"><a href="#1-1-高等数学" class="headerlink" title="1.1 高等数学"></a>1.1 高等数学</h3><p>在我个人看来，框架学习法是考研高数学习的有效方法，高数复习的核心问题和关键难点在于<strong>知识点的理解</strong>和题目<strong>所考知识点的识别</strong>这两个方面上，其中知识点的理解是知识框架的搭建过程，而所考知识点的识别则是由题目到知识框架的映射过程。打个不恰当的比方，知识框架的搭建就是二叉排序树建树的过程，而所考知识点的识别就是排序树的查找过程。所有所谓的解题技巧也都应基于这两点才有其意义，因此高数几轮的复习也可以依此各有侧重。我的数学分数并不高，但是复习过程中也有一些个人的心得希望能对各位有所启发。</p>
<h4 id="关于网课和资料"><a href="#关于网课和资料" class="headerlink" title="关于网课和资料"></a>关于网课和资料</h4><p>首先是网课和资料的选择。当下热门的考研高数老师有很多，如张宇、汤家凤等，每一名老师都有自己不同的授课风格。建议在网上初步了解几名老师，之后试听一节或两节课来确定最适合自己的、自己听上去最舒服的那位老师，毕竟接下来你可是要跟着他学完整个高数基础的。关于资料的选择，个人建议一轮网课跟谁就配套谁的讲义，例如我跟的是张宇老师，那么我就配套张宇的《基础30讲》。</p>
<p>至于习题集？很多人在一轮阶段就开始做习题集、刷1800，个人认为大可不必。原因有二：第一，私以为一轮刷题的目的是验证知识点的理解是否到位以及加深对知识点的记忆。其中，验证理解到位根本不必大量的题目，只需几道经典题即可测出你是否理解了这个知识点，一般讲义对应章节的例题和习题正是此知识点的经典题，<strong>宜重点掌握例题</strong>，而知识点的记忆通过在复习的前期刷大量题来巩固是低效的，因为在后续的学习中本来就还要回过头来再巩固的，因此与其初期在一个章节做大量题花费时间，再往后学新的知识时又被遗忘，不如达到理解熟悉的目的就立马继续向前推进。这与英语单词的记忆有异曲同工之妙，背十个单词时，每个单词背10分钟花费100分钟过一遍的效果远不及同样100分钟每个单词只背1分钟过10遍的效果。故我认为可以尽可能详细但快速地过一轮，对所有知识点将要学习的章节有一个全面认识，然后进行强化学习。而且后续二轮再配全书和习题集，三轮要二刷全书和题集，后面还有历年真题套卷和分题型二刷，最后还要做不少模拟卷，我认为总体下来题量是完全够的。当然，你想要在一轮多就做点题也是没问题的，<strong>我并不反对多做题</strong>。</p>
<h4 id="一轮复习"><a href="#一轮复习" class="headerlink" title="一轮复习"></a>一轮复习</h4><p>前面提到高数复习重在知识点的理解和题目考察知识点的识别上，私以为一轮复习的重点就在于<strong>知识点的理解</strong>，这是一切一切的基础。在这个阶段建议以网课主导复习，因为老师的循循善诱能够很好帮助你达到知识点理解的目的。此外，在看网课的过程中记录笔记<strong>相当有必要</strong>，知识点是散落在书中各处的，而建立笔记你便可以随时方便地回顾知识体系、知识重点和关键点。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/3.jpg" alt="Title"></p>
<center><b>图3 我的一轮笔记</b></center>

<p>那么题目是否要刷？答案是肯定的，<strong>且一定要做题</strong>，否则是在浪费时间。但又不应本末倒置，看完几节网课后自己看一遍书，将例题和课后习题完成即可，不必刷太多。此阶段中每次刷题前都请在心里让自己明确自己此时刷题的目的：增强对知识点的熟悉和理解。</p>
<p><strong>一轮复习花费一至两个多月都是可接受的</strong>，具体时间规划还应依据开始复习的时间确定，如我四月底开始复习不算早了，我大概花了一个月过完一轮，若三月初就开始复习，则大可复习地更详尽，多思考回味，一共花上两个月的时间，但也不宜耗时过久。</p>
<p>那么一轮应该复习到怎样的程度算是合格呢？我的看法是，对照无具体细节的知识框架图，框架中的每一个点在脑子里能回忆起这里面大概讲了些什么东西，有哪些重要的概念即可。打个比方，看着数列极限这个框架点，只要能够回忆起数列极限是什么、数列极限有哪些性质、有哪些求数列极限的基本方法（单调有界准则、先设后证）就行了。</p>
<h4 id="二轮复习"><a href="#二轮复习" class="headerlink" title="二轮复习"></a>二轮复习</h4><p>二轮复习是强化复习阶段，主要任务在于深化对知识的理解，并进一步巩固对知识体系的印象，为下一个阶段”所考知识点的识别”奠定基础。在一轮复习完成后，花两天时间过一遍讲义、自己笔记和框架作为放松，就可以进入二轮复习了。二轮复习是否要看网课这点不同的人观点不一，有人认为跟着一个老师的网课就应该从基础班到强化班到冲刺班一跟到底。我认为数学比较薄弱的同学是可以这样的，不过，我个人过完一轮后没有感到十分地吃力，<strong>因此我在二轮中选择以自己啃书为主</strong>，当你看不下去时再看一会儿网课视频以供消遣或辅助理解。之所以这么说是因为我秉持”师父领进门，修行看个人”的学习观点，自己动脑思考学习的效果我认为要胜于看网课被动接受的效果。既然一轮已经学完了，对每个知识点也有了了解和一定的理解，那么为何不尝试自己思考学习呢？</p>
<p>此阶段可以以两本书进行复习，一本全书类复习书，如我使用的李王复习全书，一本习题集，如我使用的660题。其中复习全书作为核心复习书，复习的过程就是带着脑子啃全书的过程，而至于题目，与一轮一样，仍然是<strong>宜重点掌握例题</strong>，章节习题作为知识掌握的验收题，而习题集如660题则是作为补充资料。对于掌握不好的知识点，如例题做的很费劲，章节习题效果又不好的点，应该在好好重新研读全书知识讲解或者去看对应网课辅助理解，重做例题的前提下，进一步补充习题集中的题目以确保自己真的掌握了，而不只是记住了全书上的那几道题的答案而已。而对于掌握的好，但觉得题量还不够的地方，也可以用习题集做题量补充。</p>
<p><strong>在二轮中的错题就要注意标记了</strong>，在书上圈起来即可，这个目的是为了三轮二刷全书和题集时能够有明确的重点，同时这也是我不建议一轮时标错题的原因，会很影响后面更重要环节的标记。而如果你是平板复习，那我建议你不仅要标记错题，而且要进行错题整理和归纳，并不定期刷错题，详情见后面的错题管理分享。</p>
<p>因为是自己啃书，并且还要做习题集，题量上也大了不少，故<strong>大概可花费两个多月左右</strong>，当然这个时间不是死的只是一个参考。啃全书的过程中也要注意记笔记，并且此时的<strong>笔记可重新来做</strong>，一轮时做的笔记可以放一边了，后续的笔记都可以在二轮笔记的基础上做补充。<strong>二轮应比一轮更加重视笔记的整理，注意做抽象笔记</strong>，即有些已经理解了点和方法就不必再展开写，回看笔记时在脑子里快速回忆一遍未展开的点和方法是什么内容即可，这也有助于锻炼知识回溯能力。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/4.jpg" alt="Title"></p>
<center><b>图4 我的二轮笔记（由一轮的两页精缩到了一页）</b></center>

<p>那么二轮应该复习到怎样的程度算是合格呢？我的看法是，在一个空白文档中，或者拿一张白纸，可以<strong>自己列出所有章节的框架图，并填充框架细节</strong>即可。这个默写的框架图应当尽可能接近于或与你自己做的框架笔记是一致的，以保证你对自己框架的熟悉程度，在后面的复习中，这个存储在你脑子里的框架将在此基础上不断完善和扩充，并成为你解题的重要工具。</p>
<h4 id="三轮复习"><a href="#三轮复习" class="headerlink" title="三轮复习"></a>三轮复习</h4><p>三轮仍是强化复习，主要任务是二刷全书、习题集以及你的二轮中的错题。<strong>花费时间大概一个月左右</strong>。复习方法与二轮一致，但笔记不必重做，只需对框架笔记做必要的增补和调整即可，且复习应有侧重，二轮中的薄弱章节要着重复习，复习的很好的章节可快速过一遍，我对待题目的优先级为<strong>例题&gt;=二轮中的错题&gt;其它题目</strong>。</p>
<p><strong>此阶段我更加注意的是做题策略，尝试强化框架映射的意识了</strong>。拿到题的第一任务应该是思考这题是哪章的题目？然后回忆对应章节的知识框架，然后将此题与知识框架进行比对，找到此题归属的具体的框架点。如果在脑中找到了对应的框架点，那么就成功完成了一次题目到知识框架的映射过程。例如拿到一题求极限，那么应当首先明确这是一道函数极限题，然后回忆函数极限的框架，明确函数极限可有等价代换、无穷小比阶、洛必达法则、泰勒展开等化简方法和解题办法，那么只要题不超纲，这些方法中的一个或某些个组合就一定能够解出这题，这样解题思路和方向就都有了。</p>
<p>如果没能找到，那么说明你对自己知识框架的印象还不够深，可能有些点忘记了，如忘了无穷小比阶这个极限化简工具，或者框架不够完善，如之前一直就不知道无穷小比阶还能用来化简极限，那么就应复习对应框架或对框架进行相应的补充，使题考知识点可以与框架实现完美映射。</p>
<h4 id="真题模拟"><a href="#真题模拟" class="headerlink" title="真题模拟"></a>真题模拟</h4><p>三轮结束后整理和回顾一下自己的全部笔记就可以进入真题模拟阶段了。</p>
<p>我于十月初开始真题模拟。在开始真题模拟时你的框架应该足够完善了，也就是三轮的复习后应该能够相对完整地回忆起高数每章节的框架和重点知识点，知道自己的薄弱点，并且对于解题思路是怎么来的也有了自己的理解。真题模拟的目的就是将第三轮中训练的解题思路在真题中按照真实考试时间段<strong>掐表落实</strong>，对于框架的不完善等问题，同三轮一样进行补充调整。</p>
<p><strong>真题模拟按照一天至两天一套的速度推进即可</strong>，对于做得较好的年份，当天能够吸收的，就一天一套，对于做的较差的则单独花一天吸收，即两天一套。做到后面时，很多题目都能够下意识知道应该如何处理并完成处理，达到了知行合一的境界，那么就不必想框架，而对于一下不知道如何操作的题，框架的重要性就体现出来了，只要你在前面的框架体系搭建的足够完美，那么这道不知如何操作的题一定能够映射到框架中的一个位置，只需按照对应框架点中的办法去处理即可推进解题。可以说，下意识知道怎么做相当于Cache命中了，而一下想不到如何做就需要”访存“了，你的大脑就是内存，而这个访存访的也就是你的知识框架，虽然速度慢一点，但只要你的知识框架足够完整，就一定能从中调取出相应的解题方法。</p>
<p><strong>此外，我建议真题要刷两遍</strong>，第一遍以套卷形式进行实考模拟，严格按照考试时间进行考试。历年真题刷完一遍并总结吸收后进行真题二刷，二刷不再按套卷刷，而是分题型刷（李永乐的历年真题解析一书中有历年真题的分题型训练），主要目的一是明确自己真题是否吃透了，二是进一步熟悉真题风格，熟悉各种题型在历年的真题中是怎样的形式、角度和考法来考的，同时还是对各题型知识点和框架的进一步深化。</p>
<p><strong>最后，真题建议留两套用作最后考前一周的全真模拟。</strong></p>
<h4 id="关于模拟卷"><a href="#关于模拟卷" class="headerlink" title="关于模拟卷"></a>关于模拟卷</h4><p>进入模拟卷有一个前提，即吃透了真题，也就是历年真题中的每一道题你都搞懂了，都能映射到框架上了，随便拿一题都能很快的找到解题方向了。如果真题吃的不透，过早开始模拟效果可能要打折扣的。我在十一月底才开始做模拟卷，<strong>和真题模拟一样一至两天一套推进</strong>。</p>
<p>至于模拟卷的选择，我个人使用的是李林六、四套卷和李永乐六套卷，其中李永乐没时间做了，且大题看着没有考研题内味，便只做了选填部分。</p>
<h4 id="关于错题"><a href="#关于错题" class="headerlink" title="关于错题"></a>关于错题</h4><p>一轮复习可以不做错题记录，因为错题可能过多，且此阶段知识点都不够了解，错题不太能代表什么。</p>
<p>二轮复习请务必收集错题（可在Anki中收集），二轮错题高亮了你知识点的薄弱处，至少要标记错题，以供三轮复习参考。</p>
<p>三轮复习请务必收集错题（可在Anki中收集），三轮错题高亮了你知识框架的漏洞，错题必须在知识框架上有所反映，强化错误知识点的相关框架熟悉度。</p>
<p>真题错题请务必做错题本，且<strong>建议单开一本错题本</strong>，要记录清楚错题原因，是思路错误还是框架漏洞，思路错误则就具体问题进行纠正，框架漏洞则继续补框架。</p>
<p>模拟题错题请务必做错题本，可以紧跟在真题错题集后面做，也可以单开。私以为模拟卷训练的目的是查漏补缺、保持考前做套卷的手感，以及各种知识点的反复记忆激活，<strong>题目本身意义已经不大，此阶段的错题甚至不必记录题目</strong>，只需记录错的知识点就足够了，这样考前看错题集时可以直接回顾知识点，不必看累赘的题目。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/5.jpg" alt="Title"></p>
<center><b>图5 我的真题错题本及书签</b></center>

<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/8.jpg" alt="Title"></p>
<center><b>图6 我的模拟卷错题本，不记录题目只记录错题知识点</b></center>

<h4 id="其它类型笔记"><a href="#其它类型笔记" class="headerlink" title="其它类型笔记"></a>其它类型笔记</h4><p>除了常规的笔记本和错题集外，我个人在复习过程中还有制作其它一些类型的记录本，如《迷惑行为大赏&amp;踩坑记录》记录了所有令自己都感到迷惑的操作和错误，如求函数间断点时将分子分母同为零的因式消去了，又如求隐函数极值时将偏导给解出来了，实则令人迷惑。我也有制作《速查手册》，将我个人认为重要的以及总是记不清的公式汇总<em>（数学中所有要背的公式如泰勒展开、等价代换、积分公式、形心弧长公式等等等等，务必要做到熟稔于心、倒背如流！）</em>，方便随时查阅巩固。以及《各章漏洞框架》，将第三轮及后面真题中发现的各章的漏洞单独形成框架，即各章的漏洞框架。各位也可依照个人需要创新不同类型的笔记集，而笔记的创建和维护在平板上是极为容易和方便的，这也是无纸化学习最大的优点。</p>
<h3 id="1-2-线性代数"><a href="#1-2-线性代数" class="headerlink" title="1.2 线性代数"></a>1.2 线性代数</h3><p>线代复习可说的不多，我单推李永乐，就我个人亲身感受来看，<strong>使用李永乐线代讲义并配一本补充习题集如660题，足够线代科目的全程复习</strong>。</p>
<h4 id="一轮复习-1"><a href="#一轮复习-1" class="headerlink" title="一轮复习"></a>一轮复习</h4><p>一轮复习可直接看李永乐线代网课强化班，今年没出可看去年的。当然，你若时间非常充足，想先看基础班再看强化班也不是不可。复习策略大体同高数，学完章节网课看线代讲义对应内容并完成例题和习题，侧重亦与高数一样，<strong>宜重点掌握例题</strong>，一轮错题自行决定要不要记录。</p>
<h4 id="后续复习"><a href="#后续复习" class="headerlink" title="后续复习"></a>后续复习</h4><p>一轮结束后，二轮整体思路亦同高数，应以自己啃书为主，二轮的错题需要进行整理，至少需要标记。复习书目仍是一轮时的线代辅导讲义和自行选择的习题集。不仅是二轮，后续不管你想搞几轮，进入真题模拟阶段前反复n刷线代讲义和习题集就完事了，至于何时进入真题模拟阶段，应以高数复习进度决定，待高数几轮复习完成后，同高数一起进入真题套卷模拟。错题等细节问题全部参考上面高数相关内容。</p>
<h2 id="2-专业课（408）"><a href="#2-专业课（408）" class="headerlink" title="2. 专业课（408）"></a>2. 专业课（408）</h2><p>专业课不考408的可以跳过这部分了。</p>
<p>话说在前面，若你有幸考408，那我劝你尽早起步，408在计算机考研专业课中应属最难的，而且越来越多院校改考408，这个问题的情况大家都开始意识到了。不仅跨考，就算是科班复习也绝不会轻松。408中数据结构、计算机组成原理、操作系统和计算机网络四门科目，不仅对知识本身的理解和掌握提出了很高的要求，并且内容繁杂，考的细致入微，近来真题中还出现了几门科目的知识揉在一道题中考的情况，对知识全面性和贯通性都有比较高的要求。这里引王道的真言：408复习的奥秘在于反复多遍。</p>
<h3 id="2-1-第一阶段"><a href="#2-1-第一阶段" class="headerlink" title="2.1 第一阶段"></a>2.1 第一阶段</h3><p>按照增量复习的总体策略，你应当先选一门课程作为408复习的起始课程，我是从数据结构开始的复习，复习策略还是与高数基本一致（由此可以看出，我的各科复习策略其实是大同小异的，确定基础策略后在实际中结合具体科目特点再行调整，你可完全不按照我的办法，而是多看几篇经验帖确定自己的策略和思路来形成你的计划），也是一轮网课主导，二轮啃书主导。</p>
<p>408复习的主流参考书是王道和天勤，一般情况下选择一个入坑即可。我个人推荐王道，虽然天勤据说是更加通俗，对跨考更加友好，我有看了几眼，貌似也确实如此，但我想王道也不至于那么难，许多重要的基础概念也是有较为详细的讲解的，并且王道官方在B站上有完全免费的408配套网课，因此我更推荐选择王道。若跨考生王道复习有困难，建议就困难点去翻阅科班教材。若困难太多，可尝试改换天勤参考书。</p>
<p><strong>408四门的一轮均按照网课-&gt;王道书-&gt;章后习题推进即可</strong>，没有太多好说的。至于整体时间的分配上，每科一个月的时间我认为是充足的，复习顺利的话其实一科两三周就够了，并且应采取流水线复习策略为佳，这样4门全过完一轮只需两个半月左右，且在第4门过完一轮的时候，第1、2门已经差不多过完二轮了。这样的流水线复习策略经我实践认为十分适合408的复习，能够做到全程各科反复多遍，复习时间分配均匀且不会因为长时间复习一门专业课而枯燥。</p>
<p>另外值得注意的是，408第一轮可以选择只做选择题，或者说重点做选择题，大题可以每章节挑几道题做做看。这样做的原因是，一轮主要要搞懂408中繁多的知识和概念，这个负担已经很重了，再去做大题的话会耗费大量的时间，我个人对于408的观点是，一轮尽量速战速决，通过反复多轮来进行巩固深化。</p>
<p>408二轮就不必看完整二刷网课了，直接啃王道单科书即可。特别地，对于掌握薄弱的章节可以回去反复看对应网课视频，因为王道视频的分p是十分友好的，对于不熟悉的知识你能够轻松定位到具体某个p的视频。</p>
<p><em>PS：有一点计组复习中的小提示，如果计组定点数浮点数那部分内容的复习很吃力的话，建议直接跳过去，那部分内容确实很劝退，但在历年在真题中每年所占的分值并不多，后面的存储器中央处理器和IO等才是重点，不应被这一小块搞崩了心态，因此可以把后面的全都学完了，再来补学。甚至在考前一个来月的时候专门突击一下搞定也可。</em></p>
<h3 id="2-2-第二阶段"><a href="#2-2-第二阶段" class="headerlink" title="2.2 第二阶段"></a>2.2 第二阶段</h3><p>11月之前，你大可以能刷几遍王道就刷几遍，深入贯彻反复多遍方针（前提你得认真在过，走马观花那是浪费时间）。但10月底11月初就要开始进行真题训练了。真题训练同数学一样，严格按照考试时间段进行掐表训练，并确定自己的做题顺序。2009~2020一共12套真题，再扣下两套做最后模拟，也就剩下10套了，可两天一套，第一天训练并初步总结，第二天吸收昨天卷子的错题和知识点，并做好错题点笔记，觉得容易的一天能吸收完的就一天一套。</p>
<p><strong>这个阶段的错题可单开一本错题知识点记录本</strong>，错题要记录或标记，但错题知识点建议另记，分不分科目无所谓，我是四门全混在一起记，因为我觉得408一家亲，知识点本身就杂乱，不必分的那么清楚。</p>
<p><strong>同高数，真题建议留两套用作最后考前一周的全真模拟。</strong></p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/7.jpg" alt="Title"></p>
<center><b>图7 真题错题点记录节选</b></center>

<p>真题阶段结束后就进入就可以刷模拟卷了，我是11月中下旬开始做408模拟题。这里我使用王道的《核心考点及模拟题》，书中包含核心考点和8套模拟题。在真题阶段结束和模拟题阶段开始前，专业课时间段可以花上几天的时间放松一下，所谓放松也就是看核心考点，因为之前已经过了好几轮了，所以单纯看看考点可以说是很放松了，同时又能达到总体极速再复习一遍的目的。按照我的经验，此时将408的4门核心考点全部过一遍只需要两至三天的时间。后续模拟题的做法完全同真题，错题也同真题一样处理。</p>
<p>最后的考前冲刺复习可以围绕【错题点记录本】、【Anki错题】和【核心考点】为中心。</p>
<h2 id="3-英语（二）"><a href="#3-英语（二）" class="headerlink" title="3. 英语（二）"></a>3. 英语（二）</h2><p>关于英语复习我没有太多好说的，主要因为我的英语是野路子，高中三年没听过几节英语课，没背过几个单词，书都是崭新的，平均110 120分左右，到了大学里也没怎么听过英语课，完全裸考四级512分。考研英语82（好像科软初试英语高于80分者还可直接免修研究生公共英语）我也只能算是复习了，仅此而已，事实上我连考研大纲词汇都没背完，只背了大概一半左右吧，题目也只做了往年的真题，大小作文背的模板，网课只听了刘晓燕的翻译课，刘老师讲的还是不错的。还有完型网课，我听了两节说了一堆技巧和策略感觉一言难尽，还不如我上来直接干来的稳。不过该课程历年以来好评如潮，大家其实还是可以听一下。最后考研英语完型填空错两个，阅读错两个，七选五错一个，客观题丢7分，另外我估计小作文扣3分，大作文扣5分（考完回想起来我大作文第一句就有低级语法错误…），翻译扣3分，刚好82。介于这种情况，英语复习我就不多说了，只希望大家好好复习，以我为戒。</p>
<p>不过除了具体的复习内容，我还是有两点可以分享的，第一点就是后期真题模拟的做题顺序，个人推荐主流策略：即大作文-&gt;小作文-&gt;新题型-&gt;阅读-&gt;翻译-&gt;完型的顺序，你也可以按照自己的顺序，但是英语后期套卷阶段时<strong>请一定要确定一个做题顺序</strong>，这是保证你考场上做题手感的一个前提，当前，其他科目如数学专业课也最好确定一个做题顺序。</p>
<p>第二点就是阅读真题的重要性。英语得阅读者得天下，而私以为阅读最佳题源就是历年的真题，只要命题组不换届，那么英语阅读题的命题思路将不会大变，因此我的英语阅读在整个复习期间只刷了真题阅读，每天刷一两篇，或者隔几天刷一套都行，真题中要做到除了人名和生僻的专业词汇外，所有单词要背下来，不能出现生词。此外，<strong>英语二选手我强烈建议优先刷英语一阅读</strong>，因为英二只有大概四级上下浮动的难度，而英一估计有六级左右难度，前期把英一阅读刷两遍适应难度，再做英二阅读会轻松得多。我把英一英二历年阅读整整刷了3遍，不要吐槽第二遍第三遍答案都记住了还怎么刷之类的话，英语阅读刷的是解题思路，解题思路！解题思路！我在三刷的时候每篇阅读仍要花费至少10分钟左右的时间才能做完。因为尽管你已经记得题目的答案了，但你务必要再走一遍思考线，这才是英语阅读多刷的意义：把握命题组的命题思路。</p>
<p>英语阅读九月前后开始刷时间都足够，其他的像完型、翻译、新题型、大小作文我就不多说了，自己都没有什么复习章法，大家可看其他人的经验分享。</p>
<p><strong>同高数，真题建议留两套用作最后考前一周的全真模拟。</strong></p>
<h2 id="4-政治"><a href="#4-政治" class="headerlink" title="4. 政治"></a>4. 政治</h2><p>政治在我看来是研究生入学考试中收益投入比最高的一门科目了。有一句戏言，全国考研政治的考生只有肖秀荣一人，其它所有考生不过是抄肖的答案，看谁抄的好抄的多罢了。亲身经历一年后只想说，肖老yyds！</p>
<p>考研政治很玄学，有的人只是考前背了肖4和肖8就考了70+，有的人却复习了好几个月最后才不过60几分，因此我的建议是七八九月份均可以开始政治复习，<strong>但不宜过早复习</strong>。如想相对较早复习，如七月八月开始复习，那么看先刘涛老师的基础班作为消遣，再看强化班，边刷1000题即可。如复习地较晚或者不想花太多时间在政治上，那么也至少十月前开始复习，也看刘涛老师的课，只看强化课，且只需看马哲部分，1000题能做多少算多少，做到肖8到货前，等肖8肖4到了刷肖8肖4即可。</p>
<p>对了，考研政治的复习书（厚厚的那种）私以为是无必要的，只需要一本题集和肖4肖8即可，且考研政治中<strong>选择题的重要性远远大于简答题</strong>。考研政治选择题主要靠刷1000题和肖8肖4的知识积累感觉积累，且有许多帽子题没有技巧，就是靠背，因此注意留心网上的各科帽子题总结、史纲时间轴等，可以关注b站空卡学姐的相关更新（我去年的政治相关资料几乎都是来自空卡的总结，总结的非常好），政治复习不要在资料信息上吃了亏。</p>
<p>考研政治大题并不是说不重要，而是相比之下只要好好背了肖，那么大家拉不开多大的差距。大题以肖4为准，如不放心，肖8的大题也可看看，如看肖8的话建议重点放在大题的答题的格式和答题话术上，了解政治大题的答案是长什么样的，自己大概后面应该是要什么风格去答题。此外注意，肖8一到就马上开始刷选择题，一天一套，掐表计时明确自己的做题时长，之后每天反复刷肖8，直到肖4到货。<strong>肖4一到请当天立马开始背肖4大题</strong>！肖4到货时一般时间已经临近考试，时间非常紧张，你背的越早，背的越熟，考场上你就越能从容答题，能够答得更好。要知道，考研第一场考的就是政治，请认真对待，不要在第一场就崩了心态，因此肖4到了不要留着不舍得看，马上开始背。但背肖4不是说选择题就不做了，<strong>选择题的重要性远远大于简答题是大前提</strong>，因此选择题仍然每天刷1~2套，范围也是肖4肖8选择题。</p>
<p>此外政治大题的背诵应注意技巧，个人总结有两点技巧：</p>
<ul>
<li><p>其一，建议以关键词为导向背诵，首先把一题的答案熟读几遍，然后按自己的理解圈出关键词，然后背诵的时候关键词重读，后续缩略到关键词背诵，达到只要<strong>在草稿纸上写出关键词，就能串词背出完整答案</strong>的程度，注意，是要能够由关键词串回答案，而不是仅仅背几个关键词就完事了。</p>
</li>
<li><p>其二，要将问题抽象化再背，应将答案与抽象问题建立联系，而不要与具体问题建立联系，使得答题思路受限。如去年肖4第二套的一题：<code>为什么说大力提升自主创新能力，尽快突破关键核心技术，”这是关系我国发展全局的重大问题，也是形成以国内大循环为主题的关键“？</code>不要记这么长的题干，应直接抽象为四个字”科技创新”，而后按照关键词法背诵此题答案，并将答案与”科技创新“建立联系，但凡考试中遇到”科技创新“话题的题目，就可以在草稿纸上直接默写当时背的关键词，而后选取展开可以切题的关键词直接串出答案。</p>
</li>
</ul>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/9.png" alt="Title"></p>
<center><b>图8 抽象题干及关键词抽离</b></center>

<p>以上图为例，第二问的题干被我抽象为了”高质量发展“，并抽离出了红字关键词，并在背熟后进一步浓缩成了右侧紫色关键词”十四五、阶条格、矛新重开“，并确保由精简关键词能够倒推串联背出完整的答案。这样一来考试中只要问到高质量发展的内容，便可以快速在纸上写好关键词，得到答题的框架，并有条有理地完成作答。</p>
<p>按这种方法，考前一周左右肖4应该背的很熟了，此时大题可以采取展开复习法，即将所有诸如”科技创新“、”高质量发展“这样的抽象问题列在草稿纸上，然后逐一按关键词默写展开框架，并在脑中串联出完整答案，能够达到这个状态，政治大题可不必多虑矣。</p>
<p>列框架这个环节就不要管字写得怎么样了，框架应能尽可能迅速地列出。我考研政治选择题拉跨了，对完答案直接<strong>痛失选择18分，最终却仍拿到73分</strong>，大题得分情况可想而知了，如果不是选择题滑铁卢的话，今年80分都是有希望的。</p>
<p>最后，考研政治大题除了马原之外，其它都应能写多少写多少，能写满答题卡最好，当然切题答是前提。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/13.jpg" alt="Title"></p>
<center><b>图9 抽象问题及框架冲刺复习法（草稿纸上只写抽象问题，框架均为默写，且要能对着框架关键词串出完整回答）</b></center>

<h1 id="三、时间管理"><a href="#三、时间管理" class="headerlink" title="三、时间管理"></a>三、时间管理</h1><p>本节主要想来分享一下我在考研复习期间，不同阶段中每天的复习时间是如何管理和分配的。</p>
<h2 id="1-总体策略"><a href="#1-总体策略" class="headerlink" title="1. 总体策略"></a>1. 总体策略</h2><p>首先明确一件事情，我在复习过程中不强调每天复习几小时，只关注当天任务是否完成。规划是自变量，复习时间的分配根据规划的调整而调整。</p>
<ul>
<li>总的来说，我会在开始一门课程的复习时首先估算完成一轮复习的时间，并且提出一个Deadline；</li>
<li>然后计算大概每隔几天要到一个什么样进度，如复习到哪里才能在Deadline前完成这个规划；</li>
<li>接下来我会在这个”每隔几天“中领出第一个”几天“并制定较为具体的任务，如明天、后天、大后天这三天过完复习全书第一章；</li>
<li>再进一步将全书第一章划分三天的复习内容；</li>
<li>最后，对最近的一天即”明天“设置具体的内容计划，在日历应用中分配具体的时间。</li>
</ul>
<p>可以看到，这是一个远景低纬度加载，近景高模渲染的时间规划模型。这样做的好处是如果我明天的任务没有按期完成，那么我的远景规划不受到任何影响，只需将未完成任务调和进后两天的任务中即可调整补救。再不济也只需融入下一个”几天“整体协调来最大程度淡化计划未完成对整个规划的影响。</p>
<h2 id="2-规划方法"><a href="#2-规划方法" class="headerlink" title="2. 规划方法"></a>2. 规划方法</h2><p>确定了规划的策略，那么如何更好地看到自己的计划呢？</p>
<p>如果你是苹果用户，那么我强推系统自带的日历，在日历中你可以轻松地创建事件规划，并对其进行时间段分配、颜色分类、添加提醒、备注等。我一般在每天晚上睡觉前进行明天的详细规划，也就是上一小节中的最后一点。并为每个事件添加提前5分钟或提前15分钟的提醒来起到督促作用。我之所以能够回忆起自己复习的各阶段时间和任务，主要也是得益于日历规划能使我回溯到考研复习的任意一天，看到过去的每天我都做了些什么。这样一来，不仅第二天的任务得到了明确，同时也能够随时回顾自己之前都做了些什么，并且如果有几天放松了，那么在日历的周视图中会产生大片的空白，还会产生一定的负罪感，起到警醒作用，emmm。。。</p>
<p>如果是纸质复习选手，没有平板，且手机也不是iOS，那么安卓一定也有类似的日历APP，大家可自行了解一下。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/11.png" alt="Title"></p>
<center><b>图10 日历周视图</b></center>

<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/10.png" alt="Title"></p>
<center><b>图11 日历月视图</b></center>

<h2 id="3-各阶段时间安排参考"><a href="#3-各阶段时间安排参考" class="headerlink" title="3. 各阶段时间安排参考"></a>3. 各阶段时间安排参考</h2><p>我个人按照综述中自己的渐进表，各阶段是这样安排的，仅供思路参考，请勿不思照搬。</p>
<h3 id="数学阶段（个人六月中旬前）"><a href="#数学阶段（个人六月中旬前）" class="headerlink" title="数学阶段（个人六月中旬前）"></a>数学阶段（个人六月中旬前）</h3><p>在只有高数复习的阶段，白天进行网课学习，晚上自己对照讲义复习巩固。</p>
<p>在高数和线代并行阶段，早上进行高数网课学习，下午自己对照讲义复习巩固，晚上看线代网课及讲义。</p>
<p>在线代一轮结束后，线代不再看视频了，白天也不再复习线代，只在每天晚上固定划两个小时刷讲义和660题。</p>
<h3 id="数学专业课阶段（个人八月前）"><a href="#数学专业课阶段（个人八月前）" class="headerlink" title="数学专业课阶段（个人八月前）"></a>数学专业课阶段（个人八月前）</h3><p>此时数学一轮已经结束，无需看视频，每天上午固定啃高数复习全书，下午固定专业课。</p>
<p>只有一门专业课时，如我是先复习DS的，那么下午DS独占。DS和CCP两门专业课时，两门均分下午时间。DS+CCP+CN时，一天DS和CCP均分下午，一天CN独占下午，同理四门并发时，一天DS和CCP独占，一天CN和OS独占。</p>
<p>此阶段也开始压榨线代时间，因为高数和专业课的重要性和难度都远大于线代，故晚上线代只给一个半小时左右时间刷讲义，其余时间分给当天的专业课回顾和660题，当然一般会将专业课回顾安排在晚上第一批，因为下午刚刚复习完专业课，可做过渡衔接。</p>
<h3 id="数学专业课英语阶段（个人九月前）"><a href="#数学专业课英语阶段（个人九月前）" class="headerlink" title="数学专业课英语阶段（个人九月前）"></a>数学专业课英语阶段（个人九月前）</h3><p>此阶段同之前差不太多，主要在于晚上进一步压榨线代时间，在晚上再塞一个英语复习，不过占时间也不多，两篇阅读做+改+吸收差不多一个小时，只要晚上提早一点开始，晚上推迟一些结束就行了。</p>
<h3 id="再往后的阶段"><a href="#再往后的阶段" class="headerlink" title="再往后的阶段"></a>再往后的阶段</h3><p>后面高数和线代讲义因该都已经刷了好几遍了，不用再花那么大块时间，故高数和线代都放在上午处理，但还是高数占大部分时间。晚上线代时间就换成政治了。再往后进入真题和模拟卷阶段规划就更简单了，早上固定是数学套题模拟或吸收，下午固定是408套卷模拟和吸收，偶尔几天专业课休息，换成英语套题模拟，晚上固定是英语和政治复习，如此持续直到考前一周，将之前保留的几套没做的真题拿出来做全天的真题模拟（即早上考数学，下午考专业课或英语）。</p>
<p>当然，以上安排仅为理想安排，实际上会根据每天的复习情况对第二天的计划做调整，比如我有段时间荒废了，专业课任务紧张，晚上会主要排给专业课，具体情况具体安排，这里只是给出我的各阶段安排思路，仅供参考。</p>
<p>此外，当计划严重没有执行好时，如我有多次（三四次）连续一个星期、两个星期放纵了完全没复习，那么<strong>回来复习时应及时调整整体计划</strong>，即重新走一遍3.1节中的步骤，确保你的复习进度仍处于可控状态内。</p>
<h1 id="四、错题管理"><a href="#四、错题管理" class="headerlink" title="四、错题管理"></a>四、错题管理</h1><p>前面写太多了，这里不想写了。就分享一个我做错题收集和复习的 iPad 应用——Anki（无穷图标的那个）。</p>
<p><strong>虽然前面我没有提到，但不管是数学专业课还是政治，二轮之后错题都是要常刷的</strong>。这个时间不固定，自己什么时候有空或者想刷就安排刷，但一定要刷，不要把错题放一边吃灰白记了。我一般下午专业课任务复习完有时间多就刷刷专业课错题，晚上线代任务复习完有时间多就刷刷线代和高数错题。Anki这个应用会自动给你推之前记录的错题，并且复习过的错题隔一段时间会回滚到待刷队列中达到反复复习的目的，并且软件中可以添加标签分类，并勾选只显示哪些科目的错题。</p>
<p>但是，记得把 Anki 的通知权限给关了，你肯定不希望它成天在你复习时跳出来提醒打扰你复习，这个做错题时间最好由你自己在日历中来动态规划。</p>
<p><img src="/2021/03/27/Postgraduate-Entrance-Examination-Experience-Sharing/12.png" alt="Title"></p>
<center><b>图12 Anki 错题管理</b></center>

<h1 id="五、复试回忆"><a href="#五、复试回忆" class="headerlink" title="五、复试回忆"></a>五、复试回忆</h1><h2 id="英语问题："><a href="#英语问题：" class="headerlink" title="英语问题："></a>英语问题：</h2><p>英语面有些意外，正常是要自我介绍的，但我上来老师没有让我自我介绍，直接就问我问题了：</p>
<ol>
<li>你为什么选择USTC？（因为当时满脑子都是自我介绍，所以第一个问题我就懵了没听清，还烦请老师再说了一遍，老师笑了我一下，重复说了一遍我才确认问题）</li>
<li>C/S 和 B/S 架构之间有什么区别？</li>
</ol>
<h2 id="专业问题："><a href="#专业问题：" class="headerlink" title="专业问题："></a>专业问题：</h2><ol>
<li><p><strong>老师：</strong>你们软件工程这门课讲了什么？</p>
<p><strong>我：</strong>讲了软件的生命周期：问题定义、可行性分析、需求分析、总体设计、详细设计、编码和单元测试以及软件维护。还讲了软件的开发过程，比如瀑布模型、快速原型模型、螺旋模型、增量模型等。还讲了软件测试的一些内容。</p>
</li>
<li><p><strong>老师：</strong>那我问问你，需求分析阶段是做什么了，都分析了什么需求？</p>
<p><strong>我：</strong>总的来说有显式需求、隐式需求、用户需求，显式需求就是功能需求，就是这个软件有没有按照客户的需要在做规定的动作，隐式需求有性能需求、可靠性需求等，用户需求就包含了显式和隐式需求。</p>
</li>
<li><p><strong>老师：</strong>你们学校有没有开软件工程实践方面的课程内容？</p>
<p><strong>我：</strong>没有。（问完之后老师还又重复了确认了几遍这个问题，我都是说确实没有。。现在想想这个回答真的很蠢，其实完全可以把自己的课程设计或者生产实习之类的说上去的。。）</p>
<p><strong>老师：</strong>好吧，那你自己有没有参加过相关的实践，或者说涉及团队合作方面的比赛，如果有你在其中做了什么工作？</p>
<p><strong>我：</strong>参加了数学建模竞赛，在比赛中负责算法的编程实现、辅助建模以及论文中的数据可视化工作。</p>
<p><strong>老师：</strong>在比赛中你是用什么语言呢？</p>
<p><strong>我：</strong>Matlab。</p>
</li>
<li><p><strong>老师：</strong>好，你是软件工程专业的学生，那本科期间一定学了不少编程语言吧，请问你都学过哪些语言？</p>
<p><strong>我：</strong>C、C++、Java，此外我平时会做一些自己的小项目，一般使用 C#。</p>
</li>
<li><p><strong>老师：</strong>这么多编程语言，你觉得编程语言都有哪几类，可不可以分一下类？没事你可以先想一想再回答。</p>
<p><strong>我：</strong>（思考片刻）解释型语言，还有非解释型（这里脑子短路了准确说应该是编译型语言），非解释语言就是需要编译过后才能够运行，大体上可以分成这两类吧。</p>
</li>
<li><p><strong>老师：</strong>那强类型语言和弱类型语言你是否有了解？</p>
<p><strong>我：</strong>有的，我的理解是，强类型语言应该是类型确定的，一个变量的类型在编译期间就能够被确定，弱类型语言可以有类型不确定的变量。（这个地方其实我说的并不太对，虽然确实有了解，但是一时没想起来就随口说了。。）</p>
<p><strong>老师：</strong>那你能不能据此对编程语言分一下类，哪些是强类型语言，哪些是弱类型？</p>
<p><strong>我</strong>：C 应该属于强类型语言吧，弱类型语言比如有 JavaScript。</p>
<p><strong>老师：</strong>也不是那么严谨，C 也不好说是强类型吧，C 可以做强制类型转换的。</p>
</li>
<li><p><strong>老师：</strong>我们日常生活中都是使用十进制，但在计算机中总是使用二进制、八进制、十六进制，请你说一下这些进制在什么时候用到，为什么。</p>
<p><strong>我：</strong>二进制主要是计算机底层使用，因为在计算机中使用硬件实现双稳态的电路比较方便。十六进制的话主要是用于地址表示，比如在汇编中会使用十六进制，因为计算机中的地址可能非常长，如果用二进制的话可读性很差，而使用十六进制就会比较短，可读性较好。八进制我不了解，不清楚什么时候用到。</p>
</li>
<li><p><strong>老师：</strong>计算机中的程序和文本文件都是二进制，它们有什么区别吗？</p>
<p><strong>我：</strong>程序是编译后代码以二进制存储，而文本文件存储的是 ASCII 码。</p>
<p><strong>老师：</strong>那他们都是二进制，有什么区别？</p>
<p><strong>我：</strong>虽然最终在计算机中都是二进制表示，但是它们编码的意义不同，文本文件的二进制是 ASCII 码编码。</p>
</li>
<li><p><strong>老师：</strong>输入输出函数 printf 和 scanf，其中 scanf 需要传地址，而 printf 却不需要，为什么？</p>
<p><strong>我：</strong>我想想（沉默思考了十几秒）</p>
<p><strong>老师提示：</strong>想想一般什么情况下会要传指针？</p>
<p><strong>我：</strong>哦对，scanf 因为读入数据需要写入内存，所以需要地址来进行内存修改，而 printf 不需要改变数据，因此只需要传递要输出变量的值就行了。</p>
<p><strong>老师：</strong>那也就是值传递和指针传递嘛。</p>
</li>
<li><p><strong>老师：</strong>看你408的分数应该准备了很久吧，我问你一个操作系统的问题，操作系统中临界区有什么需要注意的？</p>
<p><strong>我：</strong>临界区在同一时刻只能有一个进程访问，不能多个进程同时访问。</p>
<p><strong>老师：</strong>你说的是对的，那我再问一下你计算机网络，计算机网络中的 CSMA/CD 协议，多台计算机接入一根总线，同一时刻只有一台主机能够发送数据对吧，那么这个总线也是一个临界区，他和操作系统中的临界区有什么区别呢？</p>
<p><strong>我：</strong>操作系统的临界区是通过上锁来保证，上锁是原子操作，通过锁可以知道此时有没有进程在访问，而 CSMA/CD 中需要检测信道。</p>
<p><strong>老师：</strong>这个我知道，但是我想问的就是这个有什么区别，为什么 CSMA/CD 就不能像操作系统一样上锁？</p>
<p>（之后我想继续回答刚说几个字但是被老师打断了，计时器响了时间到了，然后面试就结束了，整个过程差不多18分钟吧，不到20分钟）</p>
</li>
</ol>
<p>此外还穿插问了一些其他问题，比如我在本科期间有没有做过班干，寝室里有多少人，室友现在都做什么，考上研究生之后有什么打算之类的，差不多就是这些。总的来说只要放松心态，老师们还是很亲切的，至少面我的老师们是这样，问题方面也不会特意刁难，只要尽量多的把自己会的说出来就行。比如第一个问题软工学了什么，只说生命周期和开发过程两个大点不如把这两个点展开一些说，既能体现自己知道细节，同时也能拖延更多的时间，只要不要展得太细了就行。毕竟面试就那么些时间，你不抓紧你会的问题这个机会多答的话，剩下的时间就可能有更多你不会的问题压向你。最后感觉想要引导老师还是挺难的，在面试的过程中我多次提到自己有项目平时会做项目，但老师好像并不感兴趣完全没问。。</p>
<h1 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h1><p>以上就是我个人一年以来的备考经验分享。因为自己也是看着学长学姐们的经验一步一步摸索过来的，因此也想留下些什么，希望这份总结能够对你有帮助，祝你复习顺利，成功上岸！</p>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看保留内容</div><div class="spoiler-content"><p>毫无保留 (・∀・(・∀・(・∀・*) </p>
</div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验心得</category>
      </categories>
      <tags>
        <tag>Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow 2.3 入门与实战笔记 02 —— 线性回归与梯度下降</title>
    <url>/2021/02/03/Tensorflow-02/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本文记录了 Tensorflow 中线性回归的实现方法及如何使用梯度下降算法，仅为框架用法，其理论与底层实现不做介绍，有需要请移步往期深度学习专题博文，搭配食用更佳 <a href="https://houkaifa.com/2019/03/02/DeepLearning-01/" target="_blank" rel="noopener">深度学习（一）Logistics 回归与梯度下降</a>。</p>
</blockquote>
<p><img src="/2021/02/03/Tensorflow-02/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><h2 id="1-包"><a href="#1-包" class="headerlink" title="1. 包"></a>1. 包</h2><p>确保你已经安装好 tensorflow 及接下来会使用到的包 pandas 及 matplotlib。</p>
<h2 id="2-Jupyter-notebook"><a href="#2-Jupyter-notebook" class="headerlink" title="2. Jupyter notebook"></a>2. Jupyter notebook</h2><p>打开 Jupyter notebook 新建一个 Python 3 文件以编写与测试代码。</p>
<h2 id="3-数据"><a href="#3-数据" class="headerlink" title="3. 数据"></a>3. 数据</h2><p>本篇以受教育年数与工作收入作为模型训练数据，以期实现一个由受教育年数来预测工作收入的简单模型。将以下数据放入记事本中，改后缀为 Income.csv 得到测试用数据，将文件放在新建的 Python 3 文件的同级目录或方便读取的目录。</p>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看 Income.csv 数据</div><div class="spoiler-content"><p>,Education,Income<br>1,10.000000 ,26.658839<br>2,10.401338 ,27.306435<br>3,10.842809 ,22.132410<br>4,11.244147 ,21.169841<br>5,11.645449 ,15.192634<br>6,12.086957 ,26.398951<br>7,12.048829 ,17.435307<br>8,12.889632 ,25.507885<br>9,13.290970 ,36.884595<br>10,13.732441 ,39.666109<br>11,14.133779 ,34.396281<br>12,14.635117 ,41.497994<br>13,14.978589 ,44.981575<br>14,15.377926 ,47.039595<br>15,15.779264 ,48.252578<br>16,16.220736 ,57.034251<br>17,16.622074 ,51.490919<br>18,17.023411 ,51.336621<br>19,17.464883 ,57.681998<br>20,17.866221 ,68.553714<br>21,18.267559 ,64.310925<br>22,18.709030 ,68.959009<br>23,19.110368 ,74.614639<br>24,19.511706 ,71.867195<br>25,19.913043 ,76.098135<br>26,20.354515 ,75.775216<br>27,20.755853 ,72.486055<br>28,21.167191 ,77.355021<br>29,21.598662 ,72.118790<br>30,22.000000 ,80.260571</p>
</div></div>
<h1 id="二、读入数据"><a href="#二、读入数据" class="headerlink" title="二、读入数据"></a>二、读入数据</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 pandas 包用于读取 csv 数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取 csv 数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">"Income.csv"</span>)</span><br><span class="line"><span class="comment"># 输出读取得到的数据</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<p>由 图2-1 输出可知数据包含两列，分别是 Education 与 Income。</p>
<p><img src="/2021/02/03/Tensorflow-02/2.png" alt="输出data数据"></p>
<center>图 2-1 输出内容</center>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 matplotlib 包用于数据可视化</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 内联显示</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 data 散点图，以 data.Education 为横坐标，data.Income 为纵坐标</span></span><br><span class="line">plt.scatter(data.Education, data.Income)</span><br></pre></td></tr></table></figure>
<p>由 图2-2 可知分别以 Education 和 Income 为横轴坐标轴的数据分布基本呈现线性关系。</p>
<p><img src="/2021/02/03/Tensorflow-02/3.png" alt="data散点图"></p>
<center>图 2-2 data 散点图</center>

<h1 id="三、模型搭建与训练"><a href="#三、模型搭建与训练" class="headerlink" title="三、模型搭建与训练"></a>三、模型搭建与训练</h1><h2 id="1-创建模型实例"><a href="#1-创建模型实例" class="headerlink" title="1. 创建模型实例"></a>1. 创建模型实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立序贯模型（最简单的线性），返回一个 Model 实例</span></span><br><span class="line">model = tf.keras.Sequential()</span><br><span class="line"><span class="comment"># 向模型添加层</span></span><br><span class="line">model.add(tf.keras.layers.Dense(<span class="number">1</span>, input_shape=[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>
<p>其中 <code>tf.keras.layers.Dense()</code> 返回一个常规的神经网络层（NN Layer），其第一个参数为 unit 正整数，指明输出矩阵维度，此处 1 表明该层的输出是 $\n times 1$ 的。</p>
<p>第二个参数 input_shape 指明输入形状，input_shape=[1] 指明输入样本的特征数为 1（此例输入即 data.Education），而该层输入参数是 2 个（应该分别是一维的权重 $w$ 和偏置 $b$ 吧）。</p>
<p>此外，查官方文档可知 input_shape 参数继承自 Layer 类，其实质是一个 TensorShape 类型的实例。</p>
<p>因此也可写作 <code>model.add(tf.keras.layers.Dense(1, input_shape=tf.TensorShape([1])))</code></p>
<p>此外，Dense 层也有其他参数，如可在构造函数中为 activation 赋值以指明本层激活函数，详细可以去看看<a href="https://tensorflow.google.cn/api_docs/python/tf/keras/layers/Dense?hl=en" target="_blank" rel="noopener">文档</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出此时模型信息</span></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p>使用 summary 可以看出，此时 model 拥有了一个 Layer，这个 layer 的输出形状是 $None \times 1$ 的。经查阅 Tensorflow 官方文档，tf 中的输入输出形状均描述为形如 <code>(batch_size, ..., input/output_dim)</code> 的结构，即输出形状 $m \times n$ 的意义是 $m$ 个样本的输出，每个样本的输出维度为 $n$，这与往期深度学习博文中的抽象数学定义也是相符的。None 猜测一下应该是表示输出数待定，待定为我们输入样本的个数。</p>
<p><img src="/2021/02/03/Tensorflow-02/4.png" alt="model summary"></p>
<center>图 2-2 Model summary</center>

<h2 id="2-配置模型"><a href="#2-配置模型" class="headerlink" title="2. 配置模型"></a>2. 配置模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译模型</span></span><br><span class="line">model.compile(optimizer=<span class="string">'adam'</span>, loss=<span class="string">'mse'</span>)</span><br></pre></td></tr></table></figure>
<p>在训练模型之前还需对模型进行一些配置，例如指明优化方法、损失函数等，compile 就是用于指明这些配置，详细的可配置参数请移步 <a href="https://tensorflow.google.cn/versions/r2.4/api_docs/python/tf/keras/Model?hl=en#compile" target="_blank" rel="noopener">compile 函数文档</a>。</p>
<p>optimizer 指明优化方法，该参数接受优化方法名，也接受优化方法的实例（<a href="https://tensorflow.google.cn/versions/r2.4/api_docs/python/tf/keras/optimizers" target="_blank" rel="noopener">tf.keras.optimizers</a>），adam 即使用梯度下降作为优化方法。</p>
<p>loss 指明 LossFunction，同样接受损失函数名或损失函数实例（<a href="https://tensorflow.google.cn/versions/r2.4/api_docs/python/tf/keras/losses" target="_blank" rel="noopener">tf.keras.losses</a>），mse 即使用均方差作为损失函数。</p>
<h2 id="3-训练模型"><a href="#3-训练模型" class="headerlink" title="3. 训练模型"></a>3. 训练模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以 data.Education 和 data.Income 作为输入参数，训练模型 5000 轮</span></span><br><span class="line">history = model.fit(data.Education, data.Income, epochs=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>详细可选参数移步官方文档：<a href="https://tensorflow.google.cn/versions/r2.4/api_docs/python/tf/keras/Model?hl=en#fit" target="_blank" rel="noopener">tf.keras.Model.fit</a></p>
<p><img src="/2021/02/03/Tensorflow-02/5.png" alt="fit history"></p>
<center>图 2-2 Fit history</center>

<h1 id="四、模型预测"><a href="#四、模型预测" class="headerlink" title="四、模型预测"></a>四、模型预测</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用刚才训练好的模型对训练集进行预测</span></span><br><span class="line">pd = model.predict(data.Education)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算预测值与真实值之间的差距</span></span><br><span class="line">delta = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data.Income.values)):</span><br><span class="line">    delta.append(data.Income.values[i] - pd[i])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制差距图</span></span><br><span class="line">plt.scatter(list(range(<span class="number">0</span>, len(delta))), delta)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/03/Tensorflow-02/6.png" alt="delta"></p>
<center>图 2-2 Delta</center>

<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"><p>Tensorflow 线性回归核心步骤：</p>
<ol>
<li>创建序贯模型：<code>model = tf.keras.Sequential()</code></li>
<li>为神经网络添加层：<code>model.add(tf.keras.layers.Dense(输出维数, input_shape=[特征数]))</code></li>
<li>配置神经网络：<code>model.compile(optimizer=&#39;优化方法名&#39;, loss=&#39;损失函数名&#39;)</code></li>
<li>训练神经网络：<code>model.fit(特征输入, 期望输出, epochs=训练轮次)</code></li>
<li>使用训练好的模型进行预测：<code>model.predict(特征输入)</code></li>
</ol>
</div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow 2.3 入门与实战笔记 01 —— 环境搭建</title>
    <url>/2021/01/28/Tensorflow-01/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本文记录了 Win10 系统下 Tensorflow 环境的搭建以及 CPU 与 GPU 版本的 Tensorflow 安装。</p>
</blockquote>
<p><img src="/2021/01/28/Tensorflow-01/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="1-环境要求"><a href="#1-环境要求" class="headerlink" title="1. 环境要求"></a>1. 环境要求</h1><h2 id="1-1-系统要求"><a href="#1-1-系统要求" class="headerlink" title="1.1 系统要求"></a>1.1 系统要求</h2><p>以下 64 位系统支持 Tensorflow：</p>
<ul>
<li>Ubuntu 16.04 +</li>
<li>Windows 7 +</li>
<li>macOS 10.12.6 (Sierra) + （不支持GPU）</li>
<li>Raspbian 9.0 +</li>
</ul>
<h2 id="1-2-Python-版本要求"><a href="#1-2-Python-版本要求" class="headerlink" title="1.2 Python 版本要求"></a>1.2 Python 版本要求</h2><p>Python 3.5 ~ 3.7</p>
<h2 id="1-3-额外要求"><a href="#1-3-额外要求" class="headerlink" title="1.3 额外要求"></a>1.3 额外要求</h2><p>Windows 用户需安装 VC：<a href="https://support.microsoft.com/zh-cn/help/2977003/the-lastest-supported-visual-c-downloads" target="_blank" rel="noopener">Visual C++ 官网下载链接</a></p>
<h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><h2 id="2-1-Miniconda"><a href="#2-1-Miniconda" class="headerlink" title="2.1 Miniconda"></a>2.1 Miniconda</h2><p>推荐使用 Miniconda 搭建 Python 环境，Miniconda 是最小的 conda 安装环境，其提供了：</p>
<ol>
<li>conda 包管理工具</li>
<li>python</li>
</ol>
<p>Python 3.7 对应的 Miniconda Windows-x86 64位 安装包下载：<a href="https://repo.anaconda.com/miniconda/Miniconda3-py37_4.8.2-Windows-x86_64.exe" target="_blank" rel="noopener">Miniconda3-py37_4.8.2-Windows-x86_64.exe</a><br>Miniconda 历史版本下载地址：<a href="https://repo.anaconda.com/miniconda/" target="_blank" rel="noopener">https://repo.anaconda.com/miniconda/</a></p>
<p>以 Miniconda3 4.8.2 (64-bit) 为例，全部默认安装即可。</p>
<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-01.png" alt="Miniconda-install-01"></p>
<center><b>图2-1 Miniconda-install-01</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-02.png" alt="Miniconda-install-02"></p>
<center><b>图2-2 Miniconda-install-02</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-03.png" alt="Miniconda-install-03"></p>
<center><b>图2-3 Miniconda-install-03</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-04.png" alt="Miniconda-install-04"></p>
<center><b>图2-4 Miniconda-install-04</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-05.png" alt="Miniconda-install-05"></p>
<center><b>图2-5 Miniconda-install-05</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-07.png" alt="Miniconda-install-06"></p>
<center><b>图2-6 Miniconda-install-06</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-08.png" alt="Miniconda-install-07"></p>
<center><b>图2-7 完成安装后可在开始菜单中找到 Anaconda3 命令行工具</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Miniconda-install-09.png" alt="Miniconda-install-08"></p>
<center><b>图2-8 Anaconda Prompt (Anaconda 命令行)</b></center>

<h2 id="2-2-Visual-C"><a href="#2-2-Visual-C" class="headerlink" title="2.2 Visual C++"></a>2.2 Visual C++</h2><p>Windows 用户需安装 VC：<a href="https://support.microsoft.com/zh-cn/help/2977003/the-lastest-supported-visual-c-downloads" target="_blank" rel="noopener">Visual C++ 官网下载链接</a></p>
<p>安装完成后需要重启计算机。</p>
<h2 id="2-3-Tensorflow"><a href="#2-3-Tensorflow" class="headerlink" title="2.3 Tensorflow"></a>2.3 Tensorflow</h2><p>Tensorflow 分为 CPU 版本和 GPU 版本。GPU 版本的 Tensorflow 可以利用 NVIDIA GPU 强大的计算加速能力，使 Tensorflow 的运行更为高效，尤其是可以成倍地提升模型训练的速度。</p>
<p>若没有 NVIDIA 显卡，则只能安装 CPU 版本。</p>
<h3 id="2-3-1-CPU-版本安装"><a href="#2-3-1-CPU-版本安装" class="headerlink" title="2.3.1 CPU 版本安装"></a>2.3.1 CPU 版本安装</h3><ol>
<li><p>升级 pip 版本（可选，若 pip 版本大于 19.0 可忽略此步骤）：<br>打开 anaconda prompt 命令行执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>使用 <code>pip --version</code> 可查看本机 pip 版本号</p>
</blockquote>
<ol>
<li><p>安装 Tensorflow 2.3 的 CPU 版本：<br>打开 anaconda prompt 命令行执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-cpu==2.3.0 -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<p>耐心等待安装即可。</p>
</li>
</ol>
<p><img src="/2021/01/28/Tensorflow-01/Tensorflow-install-01.png" alt="Tensorflow-install-01"></p>
<center><b>图2-9 Tensorflow 安装中</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Tensorflow-install-02.png" alt="Tensorflow-install-02"></p>
<center><b>图2-10 Tensorflow 安装中</b></center>

<p><img src="/2021/01/28/Tensorflow-01/Tensorflow-install-03.png" alt="Tensorflow-install-03"></p>
<center><b>图2-11 Tensorflow 安装完毕</b></center>

<ol>
<li><p>测试 Tensorflow 是否成功安装：<br>继续在 anaconda 命令行窗口执行 <code>python</code> 进入 python 环境，在 python 环境下执行</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入 tensorflow</span></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   继续执行 </p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，双下划线</span></span><br><span class="line">print(tf.__version__)</span><br></pre></td></tr></table></figure>
<p>   输出 tensorflow 版本：</p>
<p><img src="/2021/01/28/Tensorflow-01/Tensorflow-install-04.png" alt="Tensorflow-install-04"></p>
<center><b>图2-12 Tensorflow 安装成功</b></center>

<h3 id="2-3-2-GPU-版本安装"><a href="#2-3-2-GPU-版本安装" class="headerlink" title="2.3.2 GPU 版本安装"></a>2.3.2 GPU 版本安装</h3><ol>
<li>NVIDIA 参数检查</li>
</ol>
<p>安装 GPU 版本必须有 GPU 硬件的支持。Tensorflow 对 NVIDIA 先科的支持较为完备，我们使用 conda 来安装 GPU 版本。</p>
<p>对于 NVIDIA 显卡，<strong>要求其 CUDA Compute Capability （算力）须不低于 3.5</strong>。<br>算力参考：<a href="https://developer.nvidia.com/cuda-gpus" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-gpus</a></p>
<p>驱动版本注意：NVIDIA 的<strong>驱动程序需 418.x 或更高版本，CUDA 版本需要是 10.1，CUDNN 版本号不得小于 7.6</strong>。可在命令行中执行 <code>nvidia-smi</code> 查看驱动版本。</p>
<blockquote>
<p>若出现 ‘nvidia-smi’ 不是内部或外部命令，也不是可运行的程序或批处理文件。<br>请将 <code>C:\Program Files\NVIDIA Corporation\NVSMI</code> 添加至系统 PATH 环境变量中。</p>
</blockquote>
<ol>
<li>Conda 国内源配置</li>
</ol>
<p>因为 GPU 版本的两个依赖库比较大，推荐使用 conda 进行安装，并配置 conda 的国内源。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置 conda 国内源（清华镜像源请勿配置https，速度会巨慢无比且频繁出错）</span></span><br><span class="line">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"></span><br><span class="line">conda config --add channels http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line"></span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>
<ol>
<li>依赖库安装</li>
</ol>
<p>打开 anaconda prompt 命令行，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install cudatoolkit=10.1</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/28/Tensorflow-01/install-cudatoolkit.png" alt="install-cudatoolkit"></p>
<center><b>图2-13 记得确认下载安装</b></center>

<p><img src="/2021/01/28/Tensorflow-01/install-cudatoolkit-error.png" alt="install-cudatoolkit-error"></p>
<center><b>图2-14 下载过程中可能出现 HTTP 错误，需要耐心重试</b></center>

<p><img src="/2021/01/28/Tensorflow-01/install-cudatoolkit-finish.png" alt="install-cudatoolkit-finish"></p>
<center><b>图2-15 cudatoolkit 安装完成</b></center>


<p>继续在 anaconda prompt 命令行中执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install cudnn=7.6.5</span><br></pre></td></tr></table></figure>
<ol>
<li>Tensorflow GPU 版本安装</li>
</ol>
<p>最后，在 anaconda prompt 命令行中执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install tensorflow-gpu==2.3.0 -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<p>搞定。</p>
<h2 id="2-4-Matplot-amp-Notebook"><a href="#2-4-Matplot-amp-Notebook" class="headerlink" title="2.4 Matplot &amp; Notebook"></a>2.4 Matplot &amp; Notebook</h2><p>在后续学习中需要使用到 matplotlib 绘图库，pandas 以及 jupyter notebook 交互式开发环境，使用以下命令完成安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install matplotlib notebook pandas -i https://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<p>如还需安装其他库，按照同样格式即可进行安装（<code>pip install 要安装库的名称 -i https://pypi.douban.com/simple/</code>）。</p>
<p>Jupyter notebook 安装完成后，在控制台执行 jupyter notebook 即可启动。</p>
<p><img src="/2021/01/28/Tensorflow-01/jupyter-install-01.png" alt="Jupyter-install-01.png"></p>
<center><b>图2-16 运行 Jupyter notebook</b></center>

<p><img src="/2021/01/28/Tensorflow-01/jupyter-install-02.png" alt="Jupyter-install-02.png"></p>
<center><b>图2-17  Jupyter notebook</b></center>

<h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h1><p>至此，Tensorflow 2.3 环境配置完成。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>多视角探析贝塞尔曲线匀速化技术、实现及其应用</title>
    <url>/2021/01/02/UniformBezier/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>就在三年前，我于CSDN博客上发布了一篇题为《贝塞尔曲线运动n阶追踪方程的数学原理及其匀速化方法和应用》的博客文章，主要探讨的是贝塞尔曲线由一阶至n阶在数学层面的生成过程，以及匀速化的一些问题。不过当时博文中的“匀速化”似乎存在歧义，有朋友反馈匀速化后仍不匀速，后经了解才发现此匀速化非彼匀速化。本文尝试区分探讨两种匀速化及各自的应用场景和实现方法。</p>
</blockquote>
<p><img src="/2021/01/02/UniformBezier/1.jpg" alt="HeadPic"></p>
<a id="more"></a>
<hr>
<h1 id="一、匀速化与“匀速化”"><a href="#一、匀速化与“匀速化”" class="headerlink" title="一、匀速化与“匀速化”"></a>一、匀速化与“匀速化”</h1><p><img src="/2021/01/02/UniformBezier/2.gif" alt="在 Easecurve 中绘制贝塞尔曲线"></p>
<center>图 1-1 在 Easecurve 中绘制贝塞尔曲线</center>

<p>这，就是贝塞尔曲线，三阶的。在之前的博文中，你已经见过了n阶形态的数学推导，应该来说，贝塞尔曲线的生成模式还是相当的简洁和符合直觉的，除了其三阶常常应用为各矢量绘图软件中的钢笔工具之外，还有相当多的地方需要用到它。</p>
<h2 id="1-路径-生成-匀速化"><a href="#1-路径-生成-匀速化" class="headerlink" title="1. 路径(生成)匀速化"></a>1. 路径(生成)匀速化</h2><p>一个方面就是路径匀速化，或者说生成匀速化。例如在GTA5、2077等各种类型的可行走的游戏当中，并不是所有的道路都是横平竖直的，道路可能是弯曲的，尤其是在赛车游戏中，各种曲线赛道和弯道几乎无处不在，又如潜行类游戏中，NPC 沿着固定曲线路径匀速行走。那么这就带来了一个问题，<strong>如何让 NPC 在曲线道路上匀速地行走？</strong>，也即如何匀速地生成一条贝塞尔曲线。在这个角度下，一条贝塞尔曲线的横轴与纵轴均表示实体位置，如横轴代表水平坐标 $x$，纵轴代表垂直坐标 $y$，曲线上的任意点的含义是目标实体的真实相对位置。</p>
<p><img src="/2021/01/02/UniformBezier/5.png" alt="弯道视为贝塞尔曲线，曲线上的点横纵坐标记录了实体的位置信息"></p>
<center>图 1-2 弯道视为贝塞尔曲线，曲线上的点横纵坐标记录了实体的位置信息</center>

<h2 id="2-缓动匀速化"><a href="#2-缓动匀速化" class="headerlink" title="2. 缓动匀速化"></a>2. 缓动匀速化</h2><p>另一方面则是缓动匀速化，在这个角度下，贝塞尔曲线的横轴不是实体的横坐标，而是时间，纵轴也不是实体的纵坐标，而是位移。缓动匀速化旨在<strong>实现让实体获得符合贝塞尔曲线规律的运动效果。</strong></p>
<p><img src="/2021/01/02/UniformBezier/6.png" alt="缓动贝塞尔曲线，曲线上的点横纵坐标分别代表t时刻实体的位移量"></p>
<center>图 1-3 缓动贝塞尔曲线，曲线上的点横纵坐标分别代表t时刻实体的位移量</center>

<p>好，下面我们就来分别探讨一下这两种匀速化的细节，如何实现这两种匀速化，以及两种匀速化都由什么意义和应用吧。</p>
<h1 id="二、路径匀速化"><a href="#二、路径匀速化" class="headerlink" title="二、路径匀速化"></a>二、路径匀速化</h1><h2 id="1-技术难点"><a href="#1-技术难点" class="headerlink" title="1. 技术难点"></a>1. 技术难点</h2><p>之前说到，路径匀速化说白了就是如何实现让 NPC 在曲线道路上匀速地行走。</p>
<p>这个问题看上去很蠢，因为直接让 NPC 匀速运动不就好了。对于一条水平的或者垂直的或者斜率恒定的直线来说，确实很好实现。例如对于一条斜率为 $45°$ 的直线路径，只需要想好 NPC 行走的速度 $v$，然后每隔一个固定的时间差 $t$ 让 NPC 分别在水平和垂直方向上的位移增加 $vtcos\theta$ 和 $vtsin\theta$ 即可。</p>
<p>但是曲线运动或许没有这么简单，首先，曲线上的 $\theta$ 并不是固定的度数，因此要写出一个固定的形如 $\Delta x =  vsin\theta \Delta t$ 并不容易，其次贝塞尔方程是时间 $t$ 到坐标 $(x, y)$ 的映射，而实际上计算机代码本身就不是匀速执行的，因此想要获得匀速的 $t$ 本身就不是一件容易的事情。</p>
<p>要理解这一点，我们可以先从直线开始。如果你对贝塞尔公式熟悉的话，不难知道直线其实可以看作是一阶的贝塞尔曲线。因此我们先从一阶入手，看看匀速化贝塞尔是不是真的那么轻松和符合直觉。</p>
<script type="math/tex; mode=display">
B_{1}(t) = (1-t)P_0 + tP_1</script><p>我们先来看一看按照 “这个问题看上去很蠢” 的一般性思路来解决这个问题，即简单粗暴设置一个 Timer，经每个固定的时间间隔累计当前已流逝的时间 $sum_t$，再设置一个期望的完成运动的总时间 $total_t$，将两者作商即得到当前时刻处于整个运动时间中的比例位置：</p>
<script type="math/tex; mode=display">
timeRate = \frac{sum\_t}{total\_t}</script><p>按照常理来讲，我们只需要将运动的始末点坐标和这个 $timeRate$ 带入贝塞尔公式中即可得到此时刻对应的点的坐标。而我们设置的定时器的 Interval 是固定的，那么得到的点的运动也就应该是恒定的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void timerHandlerThread()</span><br><span class="line">&#123;</span><br><span class="line">	// 设置计划花费 timeFull 的时间走完目的路径</span><br><span class="line">    if (timeSigma &lt;= timeFull)</span><br><span class="line">    &#123;</span><br><span class="line">    	// 设置一个点坐标，作为我们 t 时刻运动到的位置</span><br><span class="line">        Point unrealPoint = new Point();</span><br><span class="line">        // 累计时钟周期，得到当前经过的总时间</span><br><span class="line">        timeSigma += timer1.Interval;</span><br><span class="line">        // 贝塞尔时间域在 [0,1]，将当前经过的时间除以计划时间带入得当前位置坐标</span><br><span class="line">        unrealPoint = b3.b3_c(p, timeSigma / timeFull);</span><br><span class="line">        // 绘制当前位置及在 x、y 轴上的投影</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            // x</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(unrealPoint.X - 1, p[0].Y - 1, 2, 2));</span><br><span class="line">            // y</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(p[0].X - 1, unrealPoint.Y - 1, 2, 2));</span><br><span class="line">            // CurveMotion</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(unrealPoint.X - 2, unrealPoint.Y - 2, 4, 4));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们看一看这种非常符合直觉的方案的运行结果。</p>
<p><img src="/2021/01/02/UniformBezier/3.gif" alt="时钟周期法"></p>
<center>图 2-1 时钟周期法</center>

<p>很可惜，理想和现实还是有差距的，不难看出这种看似十分符合直觉的匀速化方法得到的曲线生成过程，或者说曲线运动，根本不是匀速的，而是两头慢，中间快（两头的生成点更加密集，速度更慢，中间生成点更加稀疏，速度更快）。</p>
<p>思考片刻，你或许会质疑：也许是 <code>timerHandlerThread</code> 的调用本身是不匀速的？你在不匀速调用的函数里累增恒定的 <code>timer1.Interval</code>，结果肯定不匀速啊！好，那我们就不增静态的周期值，而是每次调用时实时计算已流逝的时间取而代之再看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void timerHandlerThread()</span><br><span class="line">&#123;</span><br><span class="line">    // ts 在开始生成时初始化为 DateTime.Now - DateTime(1970, 1, 1, 0, 0, 0, 0)</span><br><span class="line">    TimeSpan ts2 = (DateTime.Now - new DateTime(1970, 1, 1, 0, 0, 0, 0)) - ts;</span><br><span class="line">    // 从开始运动到执行这条代码时经过的总时间</span><br><span class="line">    timeSigma = ts2.TotalMilliseconds;</span><br><span class="line">    // 设置计划花费 timeFull 的时间走完目的路径</span><br><span class="line">    if (timeSigma &lt;= timeFull)</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置一个点坐标，作为我们 t 时刻运动到的位置</span><br><span class="line">        Point unrealPoint = new Point();</span><br><span class="line">        // 贝塞尔时间域在 [0,1]，将当前经过的时间除以计划时间带入得当前位置坐标</span><br><span class="line">        unrealPoint = b3.b3_c(p, timeSigma / timeFull);</span><br><span class="line">        // 绘制当前位置及在 x、y 轴上的投影</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">            // x</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(unrealPoint.X - 1, p[0].Y - 1, 2, 2));</span><br><span class="line">            // y</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(p[0].X - 1, unrealPoint.Y - 1, 2, 2));</span><br><span class="line">            // CurveMotion</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(unrealPoint.X - 2, unrealPoint.Y - 2, 4, 4));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/02/UniformBezier/4.gif" alt="实时计时法"></p>
<center>图 2-2 实时计时法</center>

<p>可以看到，将策略改为实时计算当前时刻并不奏效，实际上和直接累增时钟周期的做法几乎没有差别。造成这种现象的根本原因在于输入时间的匀速与曲线上点的匀速压根不是一回事儿。</p>
<p>事实上，为了实现点的匀速行进，我们的关注点应该放在合速度关于时间的积分上。也即我之前在《贝塞尔曲线运动n阶追踪方程的数学原理及其匀速化方法和应用》一文中所提及的化曲为直的思想。只要我们求出贝塞尔曲线的总长度，就可以将其拉为一根直线，而后设置一个恒定的速度 $v$，这样就可以利用之前提到的 $\Delta x = v \Delta t$ 来靠谱地计算真正匀速情况下实体所处的位置了！</p>
<p>不过这个位置是将贝塞尔拉直放平后的那条线上的位置，我们将其记为 $X$，这样一来，我们只需求得一个参数 $t$ 使得贝塞尔曲线在 $[0,t]$ 上的弧长恰好等于或者相当接近于物体在拉直放平后贝塞尔上的直线位移 $X$ 即可，这个参数 $t$ 就是在特定时刻下匀速贝塞尔对应的真实的匀速的 $t$，我们记之为 $rt$（即 real time），也即找到一个 $rt$ 使得对于一个特定的 $t$ 满足：</p>
<script type="math/tex; mode=display">
\int_{0}^{rt} B_3(t) dt = vt</script><p>此时再回头看，你便会恍然大悟为什么之前匀速的时间得不到匀速的运动了，根本原因就在于之前的时钟周期法和实时计算法，都是误以为有下式成立：</p>
<script type="math/tex; mode=display">
\int_{0}^{t} B_3(t) dt = vt</script><p>即 $rt = t$，而实际上并不存在这一层关系。好，理清楚了之前的误区，那么问题来了，$vt$ 好算，但如何求 $\int_{0}^{rt} B_3(t) dt$？下式是三阶贝塞尔曲线方程，$t$ 为时间参数，$P$ 是控制点的坐标，如何求贝塞尔曲线的弧长？</p>
<script type="math/tex; mode=display">
B_3(t) = (1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3</script><h2 id="2-基于辛普森积分法的路径匀速化"><a href="#2-基于辛普森积分法的路径匀速化" class="headerlink" title="2. 基于辛普森积分法的路径匀速化"></a>2. 基于辛普森积分法的路径匀速化</h2><blockquote>
<p>辛普森积分法是一种用抛物线近似函数曲线来求定积分数值解的方法。把积分区间等分成若干段，对被积函数在每一段上使用辛普森公式，根据其在每一段的两端和中点处的取值近似为抛物线，逐段积分后加起来，即得到原定积分的数值解。辛普森积分法比梯形法则更精确，二者都是牛顿-柯特斯公式（Newton-Cotes）的特例。——百度百科</p>
</blockquote>
<p>要算贝塞尔曲线的弧长，我们可以尝试辛普森积分法。利用辛普森积分法，要求定积分 $\int_{a}^{b} f(x) dx (a&lt;b)$，</p>
<p>则将闭区间等分成 $2n$ 个小区间</p>
<script type="math/tex; mode=display">
[x_i, x_{i+1}]（x_i < x_{i+1}, x_0=a, x_{2n} = b, i \in {m \in N | m < 2n}）</script><p>在每个小区间上，将抛物线近似成函数$f(x)$的曲线。设$y_i = f(x_i)$，则可以得到近似值：</p>
<script type="math/tex; mode=display">
\int_{a}^{b}f(x) dx \approx \frac{b-a}{6n}[y_0 + y_{2n} + 4(y_1+y_2+···+y_{2n-1}) + 2(y_2+y_4+···+y_{2n-2})]</script><p>我们将生成曲线视作是运动的迹，那么求贝塞尔曲线的弧长自然要对贝塞尔曲线迹的速度求积分，也就是此处辛普森积分中的 $f(x)$ 为贝塞尔曲线的合速度方程。</p>
<p>不难推导三阶贝塞尔的方向速度函数为</p>
<script type="math/tex; mode=display">
v_x = -3P_{0x}(1-t)^2 + 3P_{1x}(1-t)^2 - 6P_{1x}t(1-t) + 6P_{2x}t(1-t) - 3P_{2x}t^2 + 3P_{3x}t^2</script><script type="math/tex; mode=display">
v_y = -3P_{0y}(1-t)^2 + 3P_{1y}(1-t)^2 - 6P_{1y}t(1-t) + 6P_{2y}t(1-t) - 3P_{2y}t^2 + 3P_{3y}t^2</script><p>进而合速度 $v = \sqrt{v_x^2 + v_y^2}$，有了速度方程，即可使用辛普森积分法求速度函数的积分，得 $t$ 时刻的近似弧长了！方向速度函数及合速度函数的编码较简单，这里给出辛普森积分部分的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 求 0~t 段的三阶贝塞尔曲线长度</span><br><span class="line">public double beze_length(Point[] p, double t)</span><br><span class="line">&#123;</span><br><span class="line">	int TOTAL_SIMPSON_STEP = 1000; // 总分段步数</span><br><span class="line">	int stepCounts;</span><br><span class="line">	int halfCounts;</span><br><span class="line">	int i = 0;</span><br><span class="line">	double sum1 = 0, sum2 = 0, dStep = 0;</span><br><span class="line">	// 总步数乘以当前时间(0~1)得到参数 t 对应的步数</span><br><span class="line">	stepCounts = (int)(TOTAL_SIMPSON_STEP * t);</span><br><span class="line">	if (stepCounts == 0)</span><br><span class="line">		return 0;</span><br><span class="line">	// 化为奇数</span><br><span class="line">	if (stepCounts % 2 == 0)</span><br><span class="line">		stepCounts++;</span><br><span class="line">	// 总步数的一半</span><br><span class="line">	halfCounts = stepCounts / 2;</span><br><span class="line">	// 每次递增的步数</span><br><span class="line">	dStep = t / stepCounts;</span><br><span class="line">	// 下面全部代码就是套辛普森积分公式的过程</span><br><span class="line">	while (i &lt; halfCounts)</span><br><span class="line">	&#123;</span><br><span class="line">		// t = (2 * i + 1) * dStep 时贝塞尔曲线的速度</span><br><span class="line">		sum1 += beze_speed(p, (2 * i + 1) * dStep);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	i = 1;</span><br><span class="line">	while (i &lt; halfCounts)</span><br><span class="line">	&#123;</span><br><span class="line">		// t = 2 * i * dStep 时贝塞尔曲线的速度</span><br><span class="line">		sum2 += beze_speed(p, 2 * i * dStep);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	return ((beze_speed(p, 0) + beze_speed(p, 1) + 4 * sum1 + 2 * sum2) * dStep / 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好！现在我们成功实现了贝塞尔曲线弧长函数，回头看看，我们的目标是解出</p>
<script type="math/tex; mode=display">
\int_{0}^{rt} B_3(t) dt = vt</script><p>下面的工作就很轻松了，对于一个目标弧长，我们想要求出一个 $rt$ 对应这个弧长，只需将 $rt$ 初始化为任意数，而后粗暴地二分即可！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double t2rt_by_baze_length(Point[] p, double length)</span><br><span class="line">&#123;</span><br><span class="line">	// 将 rt 初始化为 0</span><br><span class="line">	double realTime = 0;</span><br><span class="line">	// rt 对应的弧长初始化为 0</span><br><span class="line">	double rt_length = 0;</span><br><span class="line">	// 与真实弧长的差距</span><br><span class="line">	double deltaLength = 0;</span><br><span class="line">	// rt 的更新量</span><br><span class="line">	double deltaTime = 0;</span><br><span class="line">	// 界定二分上下限</span><br><span class="line">	double low = 0, high = 1;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		// 半分</span><br><span class="line">		if (deltaLength &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			// rt 对应的弧长太大了，减小 rt</span><br><span class="line">			realTime -= (double)(realTime - low) / 2;</span><br><span class="line">			// rt 更新幅度</span><br><span class="line">			deltaTime = realTime - low;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			// rt 对应的弧长太小了，增大 rt</span><br><span class="line">			realTime += (double)(high - realTime) / 2;</span><br><span class="line">			// rt 更新幅度</span><br><span class="line">			deltaTime = high - realTime;</span><br><span class="line">		&#125;</span><br><span class="line">		// 计算弧长差值</span><br><span class="line">		rt_length = beze_length(p, realTime);</span><br><span class="line">		deltaLength = rt_length - length;</span><br><span class="line">		// 更新二分上下限</span><br><span class="line">		if (deltaLength &gt; 0) high = realTime;</span><br><span class="line">		else low = realTime;</span><br><span class="line">		// 0.01 的误差已经很小了，可视为此时的 rt 就是真实的 rt</span><br><span class="line">		// 或者 rt 的更新量足够小时也应跳出，防止梯度消失造成死循环</span><br><span class="line">		&#125; while (Math.Abs(deltaLength) &gt; 0.01 &amp;&amp; deltaTime &gt;0.00000000000000001);</span><br><span class="line">		// 算法收敛</span><br><span class="line">		return realTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们可以将贝塞尔匀速运动直接视为极简的直线段上的匀速运动了，直接定义一个恒定的速率（由时钟周期体现），然后恒定地累增恒定的位移吧！将匀速变化的当前弧长传给 <code>t2rt_by_baze_length</code>，就能得到对应匀速化贝塞尔曲线的真实的参数 $rt$ 了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void timerHandlerThread()</span><br><span class="line">&#123;</span><br><span class="line">    if (timeSigma &lt;= timeFull)</span><br><span class="line">    &#123;</span><br><span class="line">        Point realPoint = new Point();</span><br><span class="line">        // ts 在开始生成时初始化为 DateTime.Now - DateTime(1970, 1, 1, 0, 0, 0, 0)</span><br><span class="line">    	TimeSpan ts2 = (DateTime.Now - new DateTime(1970, 1, 1, 0, 0, 0, 0)) - ts;</span><br><span class="line">    	// 从开始运动到执行这条代码时经过的总时间</span><br><span class="line">    	timeSigma = ts2.TotalMilliseconds;</span><br><span class="line">        lock (this)</span><br><span class="line">        &#123;</span><br><span class="line">        	// length由运动开始时直接调用三阶贝塞尔弧长计算函数，传入t=1得到，即总弧长</span><br><span class="line">        	double rt = b3.t2rt_by_baze_length(p, length * timeSigma / timeFull);</span><br><span class="line">        	realPoint = b3.b3_c(p, rt);</span><br><span class="line">            // x</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(realPoint.X - 1, p[0].Y - 1, 2, 2));</span><br><span class="line">            // y</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(p[0].X - 1, realPoint.Y - 1, 2, 2));</span><br><span class="line">            // CurveMotion</span><br><span class="line">            g.DrawRectangle(pen, new Rectangle(realPoint.X - 2, realPoint.Y - 2, 4, 4));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果见下图。至此，我们已经成功实现了曲线的匀速生成，即路径贝塞尔匀速化。</p>
<p><img src="/2021/01/02/UniformBezier/12.gif" alt="匀速化生成贝塞尔直线"></p>
<center>图 2-3 匀速化生成贝塞尔直线</center>

<p>现在改变贝塞尔控制点的坐标，可得本文算法在三阶曲线下的效果：</p>
<p><img src="/2021/01/02/UniformBezier/13.gif" alt="匀速化生成贝塞尔曲线"></p>
<center>图 2-4 匀速化生成贝塞尔曲线</center>

<p>可以看到，每个生成点在曲线上的间距（弧长）是一致的，且弧长误差控制在0.01内，精度已经相当高。接下来只需要加快速度（可由时钟周期与计划总时长共同控制），即可实现如 NPC 在曲线路径上匀速运动，且只需通过贝塞尔控制点来随意调节运动曲线，无需修改算法代码，如需得到逆向运动，只需反转贝塞尔点，即第 $i$ 个点作为第 $n-i-1$ 个点（$i=0,1,2,···$ 且 $i&lt;n$）。</p>
<p><img src="/2021/01/02/UniformBezier/15.gif" alt="调节控制点得到的任意贝塞尔曲线均已匀速化，且反转贝塞尔点即得逆向运动"></p>
<center>图 2-5 调节控制点得到的任意贝塞尔曲线均已匀速化，且反转贝塞尔点即得逆向运动</center>

<h2 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><p>具体应用我就不单独写了，以前面提到的 NPC 循环走路为例，即 NPC 巡逻，只需调整好 NPC 行动的贝塞尔曲线，而后 NPC 在到达目标点（$t=1$）时让其等待一会儿后逆转贝塞尔点，将 $t$ 重置为零即可实现简单的 NPC 巡逻，演示如下：</p>
<p><img src="/2021/01/02/UniformBezier/16.gif" alt="基于匀速贝塞尔的 NPC 循环匀速巡逻"></p>
<center>图 2-5 基于匀速贝塞尔的 NPC 循环匀速巡逻1</center>

<p><img src="/2021/01/02/UniformBezier/17.gif" alt="基于匀速贝塞尔的 NPC 循环匀速巡逻"></p>
<center>图 2-6 基于匀速贝塞尔的 NPC 循环匀速巡逻2</center>

<p><img src="/2021/01/02/UniformBezier/18.gif" alt="基于匀速贝塞尔的 NPC 循环匀速巡逻"></p>
<center>图 2-7 基于匀速贝塞尔的 NPC 循环匀速巡逻3</center>

<p>当然说到游戏，我猜想这些底层工作大多游戏引擎应该是会帮开发者封装好的，不过在游戏之外的其它场景若需要用到曲线路径匀速扫描的话，还是自己吃透原理才能得心应手。</p>
<p>好的，接下来让我们从另一个角度看看贝塞尔“匀速化”，或者说另一个层面的“匀速化”——贝塞尔缓动匀速化。</p>
<h1 id="三、缓动匀速化"><a href="#三、缓动匀速化" class="headerlink" title="三、缓动匀速化"></a>三、缓动匀速化</h1><h2 id="1-非匀速化的贝塞尔缓动"><a href="#1-非匀速化的贝塞尔缓动" class="headerlink" title="1. 非匀速化的贝塞尔缓动"></a>1. 非匀速化的贝塞尔缓动</h2><p>在缓动匀速化中，非匀速的情况与路径匀速化中的非匀速情况是完全一致的，不过此处我们的匀速化目标不再是路径生成的匀速化了，而是水平方向上的匀速化。让我们回顾一下非匀速化的情况：</p>
<p><img src="/2021/01/02/UniformBezier/3.gif" alt="非匀速缓动贝塞尔"></p>
<center>图 3-1 非匀速缓动贝塞尔</center>

<p>在缓动视角下的贝塞尔匀速化中，我们将一条贝塞尔曲线放在笛卡尔坐标系中，横轴记为时间比率（0~1），纵轴记为位移，即我们需要求得匀速化的时间比率变化（即均匀的横轴输入），进而映射出符合曲线的时间-位移映射。</p>
<p>在贝塞尔缓动中，因为我们将横轴视作是时间轴 $t$ 了，因此要得到匀速的贝塞尔也就是要得到匀速变化的横轴，而之所以出现“匀速化”的时间传入得不到均匀的横轴变化，归根结底是因为纯粹的贝塞尔横轴的意义压根就不是时间 $t$，而是前面我们在路径匀速化中所聊的路径贝塞尔中的“横坐标”。</p>
<p>因此要得到缓动视角下的匀速贝塞尔，你得尝试转换一下思维了。</p>
<h2 id="2-逼值法-二分法-实现缓动匀速化"><a href="#2-逼值法-二分法-实现缓动匀速化" class="headerlink" title="2. 逼值法(二分法)实现缓动匀速化"></a>2. 逼值法(二分法)实现缓动匀速化</h2><p>为了得到缓动贝塞尔视角下的匀速时间，你需要将平时意义下的匀速时间 $t$ 传入贝塞尔方程，求得一个横坐标 $x$，但是注意，这个 $x$ 是那一个世界的 “$t$”，并且经过贝塞尔函数的“扭曲”后，这个世界的匀速的 $t$ 在那个世界对应的 $x$ 并不是那个世界匀速的 $x$。这可能有点儿绕，不过仔细想一想还是很好理解的。</p>
<p>现在需要做的就是拿着手中现实意义的 $t$ 去寻找贝塞尔映射另一头 $x$ 对应的真正的匀速的 $t$，即这一头的对应那一头匀速 $x$ 的 $t$，同路径匀速化一样，我们也将其记作 $rt$（即real time）。</p>
<p>下面我们就通过二分法来实现 $t$ 到 $rt$ 的转换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double t2rt(Point[] p, double t)</span><br><span class="line">&#123;</span><br><span class="line">	// 定义真实时间与差时变量</span><br><span class="line">	double realTime, deltaTime = 0;</span><br><span class="line">	// 曲线上的 x 坐标</span><br><span class="line">	double bezierX;</span><br><span class="line">	// 计算 t 对应曲线上匀速的 x 坐标</span><br><span class="line">	double x = p[0].X + (p[3].X - p[0].X) * t;</span><br><span class="line">	double low = 0, high = 1;</span><br><span class="line">	realTime = 0.5;</span><br><span class="line">	int intT = 0;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		// 半分</span><br><span class="line">		if (deltaTime &gt; 0)</span><br><span class="line">			realTime -= (double)(realTime - low) / 2;</span><br><span class="line">		else</span><br><span class="line">			realTime += (double)(high - realTime) / 2;</span><br><span class="line">		// 计算本此 &quot;rt&quot; 对应的曲线上的 x 坐标</span><br><span class="line">		bezierX = b3(p, realTime);</span><br><span class="line">		// 计算差时</span><br><span class="line">		deltaTime = bezierX - x;</span><br><span class="line">		// 界定二分上下限</span><br><span class="line">		if (deltaTime &gt; 0) high = realTime;</span><br><span class="line">		else low = realTime;</span><br><span class="line">	&#125;</span><br><span class="line">	// 差时逼近为0时跳出循环</span><br><span class="line">	while (Math.Abs(deltaTime) &gt; 0.0000000000001);</span><br><span class="line">	return realTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样转换得到的 $rt$ 对应的就是匀速变化的 $x$ 了。有趣的是，如果你观察我们求出来的 $rt$ 的话，你会发现在我们这一头 $rt$ 压根就不匀速，可是一旦经贝塞尔映射后，就成为了匀速的 $x$，即另一个世界的匀速，请看：</p>
<p><img src="/2021/01/02/UniformBezier/7.gif" alt="匀速化后的缓动贝塞尔"></p>
<center>图 3-1 匀速化后的缓动贝塞尔</center>

<p>怎么样，是不是很有意思？我们成功得到了均匀的 $x$！不过现在的贝塞尔曲线是一条简单的直线，我们可以尝试改变贝塞尔曲线的控制点来看看真实曲线下的效果了：</p>
<p><img src="/2021/01/02/UniformBezier/8.gif" alt="匀速化后的缓动贝塞尔"></p>
<center>图 3-2 匀速化后的缓动贝塞尔</center>

<p>可以看到，水平输入仍旧是匀速的！而若我们将注意力放在纵轴上的生成点上，你会发现纵轴上点的生成密度与曲线斜率趋势完全一致，而<strong>横轴是均匀变化的，即纵轴的位移输出完全匹配了匀速时间对应的贝塞尔曲线。</strong>不过注意，这里的匀速是缓动匀速，不是真正意义上的匀速贝塞尔（即生成匀速化）。</p>
<p>不过在缓动领域中，这种匀速化才正是我们所需要的，利用匀速化后的缓动贝塞尔曲线，我们可以实现动效的轻松调整，下面是基于本篇缓动贝塞尔匀速化算法实现的缓动动效。</p>
<p><img src="/2021/01/02/UniformBezier/19.gif" alt="匀速化贝塞尔缓动"></p>
<center>图 3-3 匀速化贝塞尔缓动</center>

<p><img src="/2021/01/02/UniformBezier/20.gif" alt="匀速化缓动贝塞尔动效 Demo"></p>
<center>图 3-4 匀速化缓动贝塞尔动效 Demo</center>

<h2 id="3-应用实例-1"><a href="#3-应用实例-1" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><p>没错，下面几个丝滑无比的实例就都是基于匀速化后的缓动贝塞尔曲线的缓动动效，也是基于我正在开发的 Easecurve 缓动引擎项目构建的动效实例。</p>
<p><img src="/2021/01/02/UniformBezier/9.gif" alt="匀速化缓动贝塞尔实例1"></p>
<center>图 3-5 匀速化缓动贝塞尔实例1</center>

<p><img src="/2021/01/02/UniformBezier/10.gif" alt="匀速化缓动贝塞尔实例2"></p>
<center>图 3-6 匀速化缓动贝塞尔实例2</center>

<p><img src="/2021/01/02/UniformBezier/11.gif" alt="匀速化缓动贝塞尔实例3"></p>
<center>图 3-7 匀速化缓动贝塞尔实例3</center>

<h1 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h1><p>当然，将路径匀速化与缓动匀速化相结合也是极好的，即沿着贝塞尔路径做指定贝塞尔缓动，结合演示如图：</p>
<p><img src="/2021/01/02/UniformBezier/21.gif" alt="缓动贝塞尔+路径贝塞尔 = 贝塞尔缓动路径"></p>
<center>图 4-1 缓动贝塞尔+路径贝塞尔 = 贝塞尔缓动路径</center>

<p>这篇文章其实算是填了之前那篇的坑，在之前《贝塞尔曲线运动n阶追踪方程的数学原理及其匀速化方法和应用》中有许多实现细节聊地相当模糊，实现和应用部分一笔带过，也没有区分两种匀速化，除去推导出了 $n$ 阶通式之外算是写的相当失败了hhh，本文对贝塞尔曲线及其应用做了更加具体深入的展开和探究，其中缓动方面的匀速化在网上鲜有文章，但我觉得是大有用武之地的，至少目前是自家 Easecurve 项目的内核。本片应当与之前那篇合并起来，才能算是《贝塞尔曲线运动n阶追踪方程的数学原理及其匀速化方法和应用》的完全体。</p>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看隐藏内容</div><div class="spoiler-content"><p><a href="https://github.com/Sunwish/UniformBezier" target="_blank" rel="noopener">本文算法及演示程序源代码</a>(・∀・(・∀・(・∀・*)</p>
</div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Bezier</tag>
      </tags>
  </entry>
  <entry>
    <title>借助 ServerChan 实现个人微信通知推送</title>
    <url>/2020/06/21/wechat-notifier/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>个人微信通知，这个功能我不止一次想要实现了！并不是为别人，而是为了方便自己。因为一旦有了这个功能，太多需要自己花心思去关注的事情就都可以全权交给程序来监控，并在需要时向自己发送提醒，简直是大解放。这篇记录就是向你分享，我是如何借助 Server酱 来实现这个通知功能的，如果你觉得有用，也可以将其引入到你自己的项目中，从此享受自己订阅自己的轻松。</p>
</blockquote>
<p><img src="/2020/06/21/wechat-notifier/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、简单说明"><a href="#一、简单说明" class="headerlink" title="一、简单说明"></a>一、简单说明</h1><p>简单说两句，不知道各位有没有遇到这种境况，对于网络上某些需要持续关注的事情，可以通过程序来监控其变化，但是却苦于将捕获到的变化及时地让自己知道。</p>
<ul>
<li><p>例如对于考研人来说，通常需要在相关的时间段内关注相关高校的通知发布，但是时不时去刷官网又感觉让自己分心；</p>
</li>
<li><p>又如自己服务器或站点上有一些自己关心的数据出现或数据异常时，希望自己能够及时知悉；</p>
</li>
<li><p>再如一些需要花很长时间去跑的程序，肯定希望在程序跑完出结果后的第一时间就告诉你：“嘿，我完了！”/大雾。</p>
</li>
</ul>
<p>对于我们这些码农来说，实现这些信息的监控和收集通常来说非常容易，但好像并没有一个简单好用的办法能将这些我们关心的数据变动及时地推送给自己，而不仅仅是简单地通过一堆 log 记录下来而已。</p>
<p>而就在今天，我意外地发现了 Server酱(ServerChan) 这一个人通知推送神器，可以通过极简的一条 GET 请求完成消息推送，可谓简到了极致，简致了！本篇就是记录基于 ServerChan 的个人微信通知的封装。</p>
<p>至于 ServerChan 的具体介绍，大家可以自行去官网了解。</p>
<!--more-->
<blockquote>
<p>当然，你也可以选择邮件方式实现推送，但是显然没有 ServerChan 来的简单和通用。</p>
</blockquote>
<h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><h2 id="1-获取SCKEY"><a href="#1-获取SCKEY" class="headerlink" title="1. 获取SCKEY"></a>1. 获取SCKEY</h2><p>获取 SCKEY 的方法非常简单，进入 <a href="http://sc.ftqq.com/" target="_blank" rel="noopener">ServerChan</a> 后用 Github 帐号登录网站，即刻便可得到你的专属 SCKEY。</p>
<h2 id="2-绑定微信"><a href="#2-绑定微信" class="headerlink" title="2. 绑定微信"></a>2. 绑定微信</h2><p>点击导航栏的 [微信推送]，用微信扫描二维码关注公众号并在页面中 [检查结果并确认绑定] 即可。</p>
<h2 id="3-测试一下"><a href="#3-测试一下" class="headerlink" title="3. 测试一下"></a>3. 测试一下</h2><p>直接在 [发送消息] 页面的在线发送消息工具中填写标题和消息内容，点击发送消息就可以测试通知效果了。</p>
<p>或者直接将下面的 [你的SCKEY] 替换成你的 SCKEY 然后直接在浏览器中访问也可以测试，不出意外的话你的微信很快就收到测试消息了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://sc.ftqq.com/你的SCKEY.send?text=测试消息</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/21/wechat-notifier/2.png" alt="Title"></p>
<center>图1 ServerChan自带的在线测试工具</center>

<h1 id="三、封装一下"><a href="#三、封装一下" class="headerlink" title="三、封装一下"></a>三、封装一下</h1><p>这么好用的神器，肯定是造个轮子好上路了，这里我直接创建 .Net Standard 类库，方便以后在任何需要通知功能的项目中直接引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Net;</span><br><span class="line">using System.Text;</span><br><span class="line">namespace Sunwish.Notifier</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 籍由公众号向指定微信推送消息</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class WechatNotifier</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// Server酱 SCKEY，从 http://sc.ftqq.com/ 获取并绑定微信生效</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public string SCKEY &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">        readonly string baseUrl = @&quot;https://sc.ftqq.com/&quot;;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// </span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;SCKEY&quot;&gt;Server酱 SCKEY，从 http://sc.ftqq.com/ 获取&lt;/param&gt;</span><br><span class="line">        public WechatNotifier(string SCKEY)</span><br><span class="line">        &#123;</span><br><span class="line">            this.SCKEY = SCKEY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 推送通知</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;title&quot;&gt;通知标题&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;content&quot;&gt;通知正文&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        public bool SendNotifier(string title, string content)</span><br><span class="line">        &#123;</span><br><span class="line">            string url = BuildUrl(SCKEY, title, content);</span><br><span class="line">            string retnMessage = HttpGet(url);</span><br><span class="line">            return retnMessage.IndexOf(&quot;success&quot;) != -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private string BuildUrl(string sckey, string title, string content)</span><br><span class="line">        &#123;</span><br><span class="line">            return baseUrl + sckey + &quot;.send?text=&quot; + title + &quot;&amp;desp=&quot; + content;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 获取HTTP GET请求的返回文本</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;url&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        private string HttpGet(string url)</span><br><span class="line">        &#123;</span><br><span class="line">            string result = String.Empty;</span><br><span class="line">            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);</span><br><span class="line">            request.Method = &quot;GET&quot;;</span><br><span class="line">            HttpWebResponse response = (HttpWebResponse)request.GetResponse();</span><br><span class="line">            Stream stream = response.GetResponseStream();</span><br><span class="line">            if (stream != null)</span><br><span class="line">            &#123;</span><br><span class="line">                using (StreamReader reader = new StreamReader(stream, Encoding.GetEncoding(&quot;GB2312&quot;)))</span><br><span class="line">                &#123;</span><br><span class="line">                    result = reader.ReadToEnd();</span><br><span class="line">                    reader.Close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、再测一下"><a href="#四、再测一下" class="headerlink" title="四、再测一下"></a>四、再测一下</h1><p>随便打开一个项目，安装刚刚打包的 Nuget 包，然后在相关位置编码进行消息推送。经过几次实测，基本上每一次都在3秒以内就接收到了微信提醒，可以说推送的还是非常及时的。</p>
<p><img src="/2020/06/21/wechat-notifier/5.png" alt="Title"></p>
<center>图2 安装自己写的 Nuget 包</center>

<p><img src="/2020/06/21/wechat-notifier/6.png" alt="Title"></p>
<center>图3 在相关位置调用消息推送</center>

<p><img src="/2020/06/21/wechat-notifier/7.png" alt="Title"></p>
<center>图4 在微信收到了消息推送通知</center>

<p><img src="/2020/06/21/wechat-notifier/8.png" alt="Title"></p>
<center>图5 消息详情页</center>

<h1 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h1><p>Emmm，总的来说，这应该可以算是一个能够提升码农幸福感的小玩意儿吧hhh，毕竟很多时候功能本身是好实现的，但是总感觉你和你的程序之间是隔离的，它跑它的，你测你的，没有一种稳定的交互感，可一旦你的程序可以自动向你汇报时，一切就不一样了，好像瞬间多了一个知心小助手/捂脸。</p>
<div class="spoiler collapsed"><div class="spoiler-title">注意事项</div><div class="spoiler-content"><p>ServerChan 推送页面采用 <a href="https://github.com/erusev/parsedown" target="_blank" rel="noopener">Parsedown</a> 1.7.3 进行渲染，<a href="https://github.github.com/gfm/" target="_blank" rel="noopener">语法可以参考这里</a> 。在 Markdown 语法中，两个空行才是换行，所以在推送消息中，需要换行的地方需要两次换行的。</p>
</div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Notifier</tag>
        <tag>ServerChan</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Nginx 服务器配置 SSL 证书启用 HTTPS 连接</title>
    <url>/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本文记录了如何为 Nginx 服务器配置 SSL 证书，并让网站默认以 HTTPS 方式建立连接。</p>
</blockquote>
<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、购买-SSL-证书"><a href="#一、购买-SSL-证书" class="headerlink" title="一、购买 SSL 证书"></a>一、购买 SSL 证书</h1><p>可自行购买证书，或在阿里云申请免费 SSL 证书，每个阿里云帐号默认免费证书的配额是20个。</p>
<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl01.png" alt="Title"></p>
<center>图 1-1 购买 SSL 证书</center>

<h1 id="二、申请-amp-下载证书"><a href="#二、申请-amp-下载证书" class="headerlink" title="二、申请&amp;下载证书"></a>二、申请&amp;下载证书</h1><h2 id="1-填写证书申请信息"><a href="#1-填写证书申请信息" class="headerlink" title="1. 填写证书申请信息"></a>1. 填写证书申请信息</h2><p>证书申请部分按照个人信息填写就好。值得注意的是，如果你要绑定证书的域名是中文域名，那么需要先将你的域名经过 <a href="http://tools.jb51.net/punycode/" target="_blank" rel="noopener">Punycode 编码</a> 后再填入证书绑定域名一栏，否则会报域名格式错误，无法进行下一步。一般在证书申请提交后 30 分钟内就会完成签发。</p>
<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl001.png" alt="Title"></p>
<center>图 2-1 填写证书申请信息</center>

<h2 id="2-下载签发成功的证书"><a href="#2-下载签发成功的证书" class="headerlink" title="2. 下载签发成功的证书"></a>2. 下载签发成功的证书</h2><p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl02.png" alt="Title"></p>
<center>图 2-2 已签发证书</center>

<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl03.png" alt="Title"></p>
<center>图 2-3 下载 Nginx 服务器证书</center>

<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl04.png" alt="Title"></p>
<center>图 2-4 下载得到证书和密钥文件</center>

<h1 id="三、证书配置"><a href="#三、证书配置" class="headerlink" title="三、证书配置"></a>三、证书配置</h1><h2 id="3-1-开放-443（HTTPS）-端口"><a href="#3-1-开放-443（HTTPS）-端口" class="headerlink" title="3.1 开放 443（HTTPS） 端口"></a>3.1 开放 443（HTTPS） 端口</h2><p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl05.png" alt="Title"></p>
<center>图 3-1 在阿里云 ECS 安全组规则中快速添加访问规则</center>

<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl06.png" alt="Title"></p>
<center>图 3-2 在快速添加访问规则中勾选允许 HTTPS</center>

<h2 id="3-2-将证书文件上传至服务器"><a href="#3-2-将证书文件上传至服务器" class="headerlink" title="3.2 将证书文件上传至服务器"></a>3.2 将证书文件上传至服务器</h2><p>在 nginx.conf 同级目录下创建 cert 文件夹，并将之前下载的证书文件放入 cert 文件夹中完成证书文件的部署。</p>
<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl006.png" alt="Title"></p>
<center>图 3-3 部署证书文件</center>

<h2 id="3-3-配置-Nginx-SSL"><a href="#3-3-配置-Nginx-SSL" class="headerlink" title="3.3 配置 Nginx SSL"></a>3.3 配置 Nginx SSL</h2><p>在 Nginx 配置文件 nginx.conf 中找到或添加如下代码段，用于监听 HTTPS 443 端口，以下是你需要关心和修改的部分：</p>
<ul>
<li><strong>server_name</strong> 为你的证书申请时所绑定的域名；</li>
<li><strong>root</strong> 按照你自己站点的 server 节点值填写即可；</li>
<li><strong>ssl_certificate</strong> 填写 图2-4 处下载得到的证书文件名；</li>
<li><strong>ssl_certificate_key</strong> 填写 图2-4 处下载得到的证书密钥文件名；</li>
<li><strong>location /</strong> 按照你自己站点的 server 节点值填写即可；</li>
<li>如果你的站点还有其它配置，如其它 location 或配置之类的，原样填写即可。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HTTPS server</span></span><br><span class="line"><span class="comment"># 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;   <span class="comment">#SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。</span></span><br><span class="line">    <span class="attribute">server_name</span> your_domain_name;  <span class="comment">#将localhost修改为您证书绑定的域名，例如：www.example.com。</span></span><br><span class="line">    <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> cert/your_cert_name.pem;   <span class="comment">#将domain name.pem替换成您证书的文件名。</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> cert/your_cert_name.key;   <span class="comment">#将domain name.key替换成您证书的密钥文件名。</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;  <span class="comment">#使用此加密套件。</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;   <span class="comment">#使用该协议进行配置。</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;  </span><br><span class="line">	</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:8010;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-配置-Nginx-默认-HTTPS-连接"><a href="#3-4-配置-Nginx-默认-HTTPS-连接" class="headerlink" title="3.4 配置 Nginx 默认 HTTPS 连接"></a>3.4 配置 Nginx 默认 HTTPS 连接</h2><p>同样在 nginx.conf 文件中，找到你绑定证书的 <strong>域名对应的 server 处 (不是刚才添加的 443 端口 server 处)</strong>，无需做任何修改，直接添加如下 rewrite 行即可。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  your_domain_name;</span><br><span class="line">	    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;   <span class="comment">#将所有http请求通过rewrite重定向到https</span></span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-重新载入配置文件"><a href="#3-5-重新载入配置文件" class="headerlink" title="3.5 重新载入配置文件"></a>3.5 重新载入配置文件</h2><p>完成全部配置工作后，在终端执行下面代码行重新载入 nginx.conf 配置文件即可立即生效。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx</span> -s reload</span><br></pre></td></tr></table></figure>
<h1 id="四、开启效果"><a href="#四、开启效果" class="headerlink" title="四、开启效果"></a>四、开启效果</h1><p>可以看出，证书已经生效了，且不论是直接访问域名，还是手动以 HTTP 方式访问，都可以默认定向到 HTTPS 连接了。</p>
<p><img src="/2020/06/14/Aliyun-SSL-certificate-enables-HTTPS-connection-nginx/ssl08.png" alt="Title"></p>
<center>图 4-1 最终效果</center>

<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"><p><strong>为 Nginx 服务器配置 SSL 证书启用 HTTPS 连接：</strong></p>
<ol>
<li>购买、申请、下载证书；</li>
<li>开放服务器 443 端口；</li>
<li>将证书文件部署至 nginx.conf 同级 cert 目录下；</li>
<li>在 nginx.conf 中添加 443 端口监听及 SSL 相关配置；</li>
<li>在 nginx.conf 中自己站点的 server 段中添加 rewrite 重定向；</li>
<li>重启 nginx 或重新载入 nginx 配置文件。</li>
</ol>
</div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>HTTPS</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将 ASP.NET Core 项目部署到 Linux</title>
    <url>/2020/03/08/deploy-aspnetcore-app/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本文记录了如何为 Linux 服务器搭建 .Net Core 环境，并将 ASP.NET Core 网站项目部署到服务器上，并使用 Nginx 作为反向代理服务器，借助 Supervisor 实现项目的进程管理。</p>
</blockquote>
<p><img src="/2020/03/08/deploy-aspnetcore-app/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、项目配置与发布"><a href="#一、项目配置与发布" class="headerlink" title="一、项目配置与发布"></a>一、项目配置与发布</h1><h2 id="1-项目配置（可选）"><a href="#1-项目配置（可选）" class="headerlink" title="1. 项目配置（可选）"></a>1. 项目配置（可选）</h2><blockquote>
<p>ASP.Net Core 项目默认侦听 5000 端口，若出现端口占用，可进行此步骤来自定义端口。</p>
</blockquote>
<h3 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h3><p>在项目根目录下新增配置文件 hosting.json，其中 8080 为示例的自定义端口号：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server.urls"</span>: <span class="string">"http://*:8080"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-修改-Program-cs"><a href="#1-2-修改-Program-cs" class="headerlink" title="1.2 修改 Program.cs"></a>1.2 修改 Program.cs</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//CreateHostBuilder(args).Build().Run();</span></span><br><span class="line">            <span class="keyword">var</span> config = <span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">                .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class="line">                .AddJsonFile(<span class="string">"hosting.json"</span>, optional: <span class="literal">true</span>)</span><br><span class="line">                .Build();</span><br><span class="line">            WebHost.CreateDefaultBuilder(args)</span><br><span class="line">                .UseConfiguration(config)</span><br><span class="line">                .UseStartup&lt;Startup&gt;()</span><br><span class="line">                .Build()</span><br><span class="line">                .Run();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-项目发布"><a href="#2-项目发布" class="headerlink" title="2. 项目发布"></a>2. 项目发布</h2><p>在解决方案资源管理器中右键你的项目，选择 <strong>发布</strong>，使用文件夹模式进行发布，找到发布生成的 publish 文件夹，将其中的内容通过 Xftp 或其他方式上传至服务器上对应的项目空目录中。</p>
<p><img src="/2020/03/08/deploy-aspnetcore-app/3.png" alt="Title"></p>
<h1 id="二、搭建-Net-Core-环境"><a href="#二、搭建-Net-Core-环境" class="headerlink" title="二、搭建 .Net Core 环境"></a>二、搭建 .Net Core 环境</h1><h2 id="1-注册-Microsoft-签名密钥"><a href="#1-注册-Microsoft-签名密钥" class="headerlink" title="1. 注册 Microsoft 签名密钥"></a>1. 注册 Microsoft 签名密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm</span><br></pre></td></tr></table></figure>
<h2 id="2-安装-Net-SDK"><a href="#2-安装-Net-SDK" class="headerlink" title="2. 安装 .Net SDK"></a>2. 安装 .Net SDK</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">验证 yum</span></span><br><span class="line">sudo yum update</span><br><span class="line"><span class="meta">#</span><span class="bash">安装 .Net Core</span></span><br><span class="line">sudo yum install dotnet-sdk-3.1 -y</span><br></pre></td></tr></table></figure>
<h2 id="3-验证安装结果"><a href="#3-验证安装结果" class="headerlink" title="3. 验证安装结果"></a>3. 验证安装结果</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet --version</span><br></pre></td></tr></table></figure>
<p><img src="/2020/03/08/deploy-aspnetcore-app/2.png" alt="Title"></p>
<h1 id="三、Nginx-安装与配置"><a href="#三、Nginx-安装与配置" class="headerlink" title="三、Nginx 安装与配置"></a>三、Nginx 安装与配置</h1><blockquote>
<p>nginx 用来做反向代理，nginx 监听 80 端口，当通过 url 访问服务器请求 80 端口时，会通过 nginx 结合访问的域名来转发到对应项目的自定义端口。</p>
</blockquote>
<h2 id="1-安装-Nginx"><a href="#1-安装-Nginx" class="headerlink" title="1. 安装 Nginx"></a>1. 安装 Nginx</h2><p>点击链接 <a href="https://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-12.noarch.rpm" target="_blank" rel="noopener">epel-release-7-12.noarch.rpm</a> 直接下载，</p>
<p>或自己前往 <a href="https://dl.fedoraproject.org/pub/epel" target="_blank" rel="noopener">https://dl.fedoraproject.org/pub/epel</a> 下载需要的版本 epel 并上传到服务器，在存放 epel rpm 包的目录下依次使用以下命令完成安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装epel</span></span><br><span class="line">rpm -ivh epel-release-7-9.noarch.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装nginx</span></span><br><span class="line">yum install nginx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动nginx</span></span><br><span class="line">systemctl start nginx</span><br></pre></td></tr></table></figure>
<p>可使用下面的命令测试 Nginx 是否运行正常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1</span><br></pre></td></tr></table></figure>
<h2 id="2-配置-Nginx"><a href="#2-配置-Nginx" class="headerlink" title="2. 配置 Nginx"></a>2. 配置 Nginx</h2><p>Nginx 的配置文件默认位置为 /etc/nginx/nginx.conf，根据自身需要完成配置，下面是我的配置参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  此处为你的域名;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://localhost:此处为你的项目监听端口;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后重载配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<p>启用 nginx 开机自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx service</span><br></pre></td></tr></table></figure>
<h1 id="四、启动网站"><a href="#四、启动网站" class="headerlink" title="四、启动网站"></a>四、启动网站</h1><p>至此，你的网站已经可以启动并从外网访问了。关于启动方式，你可以在 Xshell 会话窗口中，进入之前发布到服务器上的项目目录，通过命令 <code>dotnet 你的项目名.dll</code> 来启动网站，但是这样只要 Ctrl + C 或断开会话连接，项目进程就被结束了，因此可以用来做临时测试。若要使网站持续运行下去，可以使用下面两种方法之一。</p>
<h2 id="nohup-启动"><a href="#nohup-启动" class="headerlink" title="nohup 启动"></a>nohup 启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup dotnet 你的项目名.dll</span><br></pre></td></tr></table></figure>
<p>这样一来你的网站就跑起来了，并且断开会话进程也不会被关闭，简单和无需进行配置就是它的优点，但若是想要关闭就麻烦了，需要 <code>ps -ef  | grep dotnet</code> 找到对应的进程 id 再将其 kill。另外一个缺点是，如果服务器重启，或者你的项目出现错误意外退出了，那么你的项目是不会自动重新启动的。因此你若介意的话，还是推荐下面一种方法。</p>
<h2 id="Supervisor-守护"><a href="#Supervisor-守护" class="headerlink" title="Supervisor 守护"></a>Supervisor 守护</h2><blockquote>
<p>Supervisor 是微软推荐的一个进程管理工具，可以让指定程序在后台运行，并且在进程异常退出时将自动重启它。</p>
</blockquote>
<h3 id="安装-supervisor"><a href="#安装-supervisor" class="headerlink" title="安装 supervisor"></a>安装 supervisor</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install python-setuptools</span><br><span class="line">easy_install supervisor</span><br></pre></td></tr></table></figure>
<h3 id="配置-supervisor"><a href="#配置-supervisor" class="headerlink" title="配置 supervisor"></a>配置 supervisor</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/supervisor</span><br><span class="line">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br><span class="line">mkdir /etc/supervisor/conf.d</span><br></pre></td></tr></table></figure>
<ul>
<li>修改 supervisor.conf 文件尾部的 include 部分如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;[include]</span><br><span class="line">;files = conf.d/*.conf</span><br></pre></td></tr></table></figure>
<ul>
<li>在 /etc/supervisor/conf.d 目录下为项目创建配置文件：<code>vim /etc/supervisor/conf.d/你的项目名.conf</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[program:你的项目名]</span><br><span class="line">command=dotnet 你的项目名.dll </span><br><span class="line">directory=你的项目目录</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/你的项目名.err.log</span><br><span class="line">stdout_logfile=/var/log/你的项目名.out.log </span><br><span class="line">environment=ASPNETCORE_ENVIRONMENT=Production </span><br><span class="line">user=root</span><br><span class="line">stopsignal=INT</span><br></pre></td></tr></table></figure>
<ul>
<li>启动配置文件：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>重载配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看守护的所有进程状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisorctl status all</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭所有守护进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">supervisorctl stop all</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>至此，ASP.NET Core 项目部署就完成了。</strong></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】一个成功的 Git 分支模型</title>
    <url>/2020/01/11/a-successful-branching-model/</url>
    <content><![CDATA[<blockquote>
<p>在这篇文章中，我将向你们介绍一个开发模型，早在差不多一年前，我已经将这个模型应用于我的多个项目，而事实证明，这个模型是非常成功的。其实这篇文章我早就打算写了，只是一直没有时间，直到现在。在这篇文章中我将不会谈及任何项目细节，分支策略和发布管理才是本文的核心内容。</p>
</blockquote>
<p><img src="/2020/01/11/a-successful-branching-model/1.png" alt="Title"></p>
<a id="more"></a>
<hr>
<blockquote>
<p>原文地址：<a href="https://nvie.com/posts/a-successful-git-branching-model/spoiler" target="_blank" rel="noopener">https://nvie.com/posts/a-successful-git-branching-model/spoiler</a><br>原文作者：Vincent Driessen<br>全文翻译：Sunwish</p>
</blockquote>
<h2 id="为什么是-Git"><a href="#为什么是-Git" class="headerlink" title="为什么是 Git"></a>为什么是 Git</h2><p>如果去深入地探讨网络上关于 Git 优缺点的分析，以及 Git 与其他的中心化源代码控制系统的对比，你就可以发现，大家对此都持有自己的观点和看法。就我而言，作为一名开发者，相比其他所有的同类工具，我都更喜爱 Git。毫不过分地说，Git 彻底地改变了我们开发者对于合并和分支操作的看法和感受。我作为一名从传统 CVS/SVN 转到 Git 的开发者，可以说曾经的合并和分支操作总是让人觉得有点可怕（每当合并过程产生了冲突，总让人感到害怕），并且也是一个短期内使用频率很低的操作。</p>
<p>但是来到 Git 这边，情况就完全不一样了。合并和分支操作作为 Git 当中简单轻松的操作，在开发者的日常工作流中往往是核心部分之一。这一点从两者的相关书籍中就可以看出，在 CVS/SVN 的书籍中，合并和分支往往在最后的章节（进阶部分）才抛头露面，而在几乎所有的 Git 书籍中，合并和分支则是在第三章（基础部分）就已经讨论过了。</p>
<p>正是由于这样的简单性与重复性，分支与合并再也不是什么令人害怕的东西了，版本控制工具也成功地成为了合并与分支管理的最佳助手。</p>
<p>讨论够了相关工具，下面就让我们开始进入开发模型的相关内容吧！我接下来介绍的开发模型，需要团队当中所有的开发人员共同遵循，以便使得软件管理可以进入正确的进程。</p>
<h2 id="去中心化的中心化"><a href="#去中心化的中心化" class="headerlink" title="去中心化的中心化"></a>去中心化的中心化</h2><p>使用我们这一分支模型的存储库有一个共同的特点，那就是它们都有一个“真正”的中心存储库，但是要注意的是，这个存储库所谓的中心仅仅是我们假想的（Git 作为一个去中心化的版本控制系统，在技术层面上来说并不存在所谓的中心），而这个中心存储库，正是为我们 Git 使用者们所熟知的 origin 存储库。</p>
<p><img src="/2020/01/11/a-successful-branching-model/2.png" alt="img"></p>
<p>每一个开发者都围绕着 origin 存储库进行着 pull 和 push 操作，这显示出了 origin 存储库的中心性，但是除此之外，每个开发人员都可以从其它对等方拉取他们的更改来组成子团队，这在开发人员过早地将自己进行的工作推送到主分支上之前，与两个或更多的开发者共同完成一个较大的新功能时是很有用的。正如上图所示，这几个开发成员之间可以很自然地形成很小的子团队： Alice 和 Bob，Alice 和 David，以及 Clair 和 David。</p>
<p>在技术层面上，这就好比 Alice 除了自己的存储库，还定义了一个名为 bob 的远程 Git，并且指向了 Bob 的存储库，反之亦然。</p>
<h2 id="主要分支（The-main-branches）"><a href="#主要分支（The-main-branches）" class="headerlink" title="主要分支（The main branches）"></a>主要分支（The main branches）</h2><p>我所要介绍的开发模型，其核心是在许多现有模型的启发下诞生的。我们模型的中心存储库，具有两条主要分支，这两条分支的生命线贯穿了我们整个存储库诞生和消亡，他们分别是：</p>
<ul>
<li>master</li>
<li>develop</li>
</ul>
<p><img src="/2020/01/11/a-successful-branching-model/3.png" alt="img"></p>
<p>在 <strong>origin</strong> 存储库中的 <strong>master</strong> 分支应当是面向所有 Git 用户的，在它旁边的另一条分支我们称之为 <strong>develop</strong> 分支。</p>
<p>在任何时候，<strong>origin/master</strong> 分支的 <strong>HEAD</strong>（最前端）所指向的源代码都应该处于可使用的、产品级的状态。</p>
<p>而 <strong>origin/develop</strong> 分支的 <strong>HEAD</strong> 则应指向开发人员为下一次发布版所做更改的最新源代码。有些人也称这一分支为 “integration branch（集成分支）”，所有的夜间自动构建正是从这一分支构建而来。</p>
<p>当 <strong>develop</strong> 分支中的代码逐渐完善，达到了足够稳定、可以准备发布的程度时，所有的修改就可以准备合并回 <strong>master</strong> 分支，打标签和发布版本号了。具体隐含在其中的内部细节将在后面谈及。</p>
<p>正如你所看到的，每当所做的修改完成了一次向 <strong>master</strong> 分支的合并请求，也就意味着一个全新的版本被定义和发布了。因此，我们往往对这一合并有着非常严格的要求，以至于我们会去使用一个名为 Git hook 的脚本，每当我们执行了一次面向 <strong>master</strong> 的 commit，都去全自动地构建与测试我们的软件，并将其部署到产品服务器上。</p>
<h2 id="支撑分支（Supporting-branches）"><a href="#支撑分支（Supporting-branches）" class="headerlink" title="支撑分支（Supporting branches）"></a>支撑分支（Supporting branches）</h2><p>紧挨着主要分支 <strong>master</strong> 和 <strong>develop</strong>，我们的开发模型引入了许多的支撑分支用于实现多个团队成员之间的平行开发、轻松地进行新功能的跟踪、产品发布版的准备以及协助快速修复线上产品的已知问题。不同于主要分支，这些支撑分支的生命周期都是很有限的，这就意味着当它们的使命完成后，其对应的分支就将被彻底地移除。</p>
<p>我们经常使用的支撑分支有以下几种：</p>
<ul>
<li>Feature branches（新功能分支）</li>
<li>Release branches（发布分支）</li>
<li>Hotfix branches（热修复分支）</li>
</ul>
<p>这些不同类型的分支都有着属于自己的使命，并且都受着各自分支规则的严格约束，例如有哪些分支才能够成为它们的源分支，又有哪些分支才是它们执行合并的目标分支等。接下来我们就花上几分钟的时间，来具体讨论一下这些分支各自的意义和相关规则。</p>
<p>另外提一点，其实在技术层面上来讲，并不存在什么“特殊”的分支，这些分支类型和标签仅仅是我们自己定义的，取决于我们自己想要如何使用它，在最原始的层面上来说，他们都只是普通的 Git 分支而已。</p>
<h3 id="Feature-branches（新功能分支）"><a href="#Feature-branches（新功能分支）" class="headerlink" title="Feature branches（新功能分支）"></a>Feature branches（新功能分支）</h3><p>可能的源分支：<br>    <strong>develop</strong><br>严格指定的合并分支：<br>    <strong>develop</strong><br>分支命名规范：<br>    所有除了 <strong>master</strong>, <strong>develop</strong>, <strong>release-*</strong>, <strong>hotfix-*</strong> 的形式均可</p>
<p>所有的 feature 分支（也有人称之为 topic branches，主题分支）都是用于开发下一个发布版的新功能，或是某个目标版本的新功能的，因为每当你开始了一个新功能的开发工作，这个功能究竟会在哪个版本当中发布，你或许并不能确定。一个 feature 分支在本质上其生命周期等同于这个功能的开发时长，但是最终并不一定会被合并到 <strong>develop</strong> 分支中（即成为下一个发布版本中的新特性），也可能由于测试的效果不理想而被直接抛弃。</p>
<p>Feature 分支通常只存在于软件开发者们的版本库中，而不会出现在 origin 版本库中。</p>
<p><img src="/2020/01/11/a-successful-branching-model/4.png" alt="img"></p>
<h4 id="创建一个-feature-分支"><a href="#创建一个-feature-分支" class="headerlink" title="创建一个 feature 分支"></a>创建一个 feature 分支</h4><p>当我们要开始着手一个新功能的开发时，首先应当从 <strong>develop</strong> 分支拆出一个新的分支，作为我们新功能开发的 feature 分支。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b myfeature develop</span><br><span class="line">Switched to a new branch &quot;myfeature&quot;</span><br></pre></td></tr></table></figure>
<h4 id="将开发完成的-feature-分支合并到-develop-分支中"><a href="#将开发完成的-feature-分支合并到-develop-分支中" class="headerlink" title="将开发完成的 feature 分支合并到 develop 分支中"></a>将开发完成的 feature 分支合并到 develop 分支中</h4><p>已经完成开发的新功能或许需要合并到 develop 分支中，成为下一个发布版本当的新功能之一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git check out develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff myfeature</span><br><span class="line">Updating ea1b82a..05e9557</span><br><span class="line">(Summary of changes)</span><br><span class="line">$ git branch -d myfeatrue</span><br><span class="line">Deleted branch myfeature (was 05e9557).</span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure>
<p>合并中的 —no—ff 标记可以强制为合并操作创建一个新的 commit 对象，将所有原来属于 feature 分支的 commit 记录打包进这个新的 commit 对象中，进而避免 Git 采用 fast-forward 方式进行分支合并，直接将 develop 指向 feature 造成原本属于 feature 分支上 commit 记录丢失（译注：也就是分不出哪些 commit 是原属于 feature 分支上的 commit 了），下面是采用 —no—ff 与 fast-forward 方式进行合并的对比图。</p>
<p><img src="/2020/01/11/a-successful-branching-model/5.png" alt="img"></p>
<p>在图中右边那种情况中，一旦完成合并，你将再也无法从 develop 的 Git 记录中分辨出哪些 commit 是来自 feature 分支中提交的修改和增加的新功能了，这意味着如果你想要找出这些 feature 的提交内容，你必须一条一条地在所有提交历史中去找到对应的提交记录。而在这种合并模式下，如果想要撤销整个新功能，那就够你头疼的了。如果你使用了 —no—ff 就可以完全避免这种合并，并且可以轻松地回退。</p>
<p>当然，这样的话将会创建一些空的 commit 对象，但是其带来的益处将远远超过多创建几个 commit 付出的代价。</p>
<h3 id="Release-branches（发布分支）"><a href="#Release-branches（发布分支）" class="headerlink" title="Release branches（发布分支）"></a>Release branches（发布分支）</h3><p>可能的源分支：<br>    <strong>develop</strong><br>严格指定的合并分支：<br>    <strong>develop</strong> 和 <strong>master</strong><br>分支命名规范：<br>    <strong>release-*</strong></p>
<p>Release 分支用于为即将发布的新版本做发布前的一些准备工作，你可以在 release 分支中为新版本的发布做最后的检查，以确保所有微小的细节都是完整且正确的。此外，你也可以在 release 分支中最后修补一些小bug，以及准备发布版的一些元数据（例如版本号、构建日期等）。当这些工作全部完成后，原来的 <strong>develop</strong> 分支也就准备好接收下一轮大更新的 feature 提交了。</p>
<p>从 <strong>develop</strong> 分支中拆分出一个 release 分支的合适时机在于，当开发已经（近乎完全）呈现出新版本所期待的状态时，至少新版本中所期望的全部功能应当完成了向 <strong>develop</strong> 分支的合并。当然，所有计划在未来（更后期）的版本中才发布的 feature 不应被合并，它们至少需要等到 develop 已经为马上到来的下一次更新分出用于发布准备的 release 分支后再请求合并。</p>
<p>另一个标志是，当即将发布的新版本被分配好了版本号时，就可以成为 release 分支的开始，至少这个起始点不应出现在版本号被分配之前。因为在那之前， <strong>develop</strong> 分支虽然展现出了为 “下一次发布版” 所做出的更改，但其实并不清楚这个所谓的 “下一次发布版” 最终会是 0.3 还是 1.0，直到 release 分支启动，才能够完全确定。也就是说，版本号的决定应在 release 分支的开始时做出，并遵循项目自身的版本号规则。</p>
<h4 id="创建一个-release-分支"><a href="#创建一个-release-分支" class="headerlink" title="创建一个 release 分支"></a>创建一个 release 分支</h4><p>Release 分支是从 <strong>develop</strong> 分支创建而来的。举个例子，产品当前的发布版本号是 1.1.5，并且接下来将有一次大的发布版更新。此时， <strong>develop</strong> 分支已经为 “下一次发布” 做好了准备，并且我们也决定好了下一个版本号是 1.2（而不是 1.1.6 或 2.0），此时，我们就可以开始创建分支，并根据新的版本号给出 release 分支的名称了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b release-1.2 develop</span><br><span class="line">Switched to a new branch &quot;release-1.2&quot;</span><br><span class="line">$ ./bump-version.sh 1.2</span><br><span class="line">Files modified successfully, version bumped to 1.2.</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2&quot;</span><br><span class="line">[release-1.2 74d9424] Bumped version number to 1.2</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(-)</span><br></pre></td></tr></table></figure>
<p>在此，我们创建了一个新的分支并切换过去修改了版本号。这里的 <strong>bump-version.sh</strong> 是一个虚拟的shell脚本（fictional shell script），用于修改工作副本中的一些文件以反映新版本。（当然，你也可以手动去做相关的修改）然后我们就将新的版本号 commit 了。</p>
<p>这个新的分支将会存在一小段时间，直到这个新版本被完全发布为止。在此期间，一些bug的修复工作就可以直接在这个 release 分支上进行了（而不是又返回 develop 分支去修复）。但是注意，这并不意味着你可以在这个 release 分支上去写新的 feature，因为正如之前所讲的，feature 必须合并到 develop 分支上，因此如果在 release 分支中又有了其它新功能的想法，就忍一忍，把它们留到下一次发布吧。</p>
<h4 id="完成-release-分支"><a href="#完成-release-分支" class="headerlink" title="完成 release 分支"></a>完成 release 分支</h4><p>当一个 release 分支已经达到了真正可以 release 的状态时，我们就要开展相关的工作了。首先要明确，我们的 release 分支要合并到 master 分支上（务必时刻牢记，每一个面向 master 的 commit 都代表着一个新版本的发布）。接下来，为向 master 发起的 commit 打上对应的 tag。最后，别忘了将 release 分支上做出的更改和变动合并回 <strong>develop</strong> 分支，以确保在以后的发布版中不会复现当前这个 release 分支上已经修复过的问题。</p>
<p>前两步的 Git 操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branche &apos;master&apos;</span><br><span class="line">$git merge --no--ff release-1.2</span><br><span class="line">Merge made by recursive</span><br><span class="line">(Summaru pf changes)</span><br><span class="line">$ git tag -a 1.2</span><br></pre></td></tr></table></figure>
<p>至此新版本发布就完成了，并且留下了标签以为将来备查。</p>
<blockquote>
<p>校订：你也可以使用 -s 或 -u 标记对标签进行加密签名。</p>
</blockquote>
<p>为了将 release 分支上所做的所有修改保留到以后的版本中，我们还需要将 release 分支合并回 develop 分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no-ff release-1.2</span><br><span class="line">Merge made by recursive</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure>
<p>上面的操作有可能会产生合并冲突，如果有的话那就处理一下然后提交就好了。</p>
<p>至此，release 分支的使命就完成了，下面我们就可以将其移除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d release-1.2</span><br><span class="line">Delete branch release-1.2 (was ff452fe)</span><br></pre></td></tr></table></figure>
<h3 id="Hotfix-Branches（热修复分支）"><a href="#Hotfix-Branches（热修复分支）" class="headerlink" title="Hotfix Branches（热修复分支）"></a>Hotfix Branches（热修复分支）</h3><p>可能的源分支：<br>    <strong>master</strong><br>严格指定的合并分支：<br>    <strong>develop</strong> 和 <strong>master</strong><br>分支命名规范：<br>    <strong>hotfix-*</strong></p>
<p>Hotfix 分支和 release 分支非常相像，它们都是为新版本发布而准备的分支，只不过 hotfix 分支并不是预先计划好的。当线上版本突然出现了某些非预期的问题，并且迫切需要得到修复时，就要启用 hotfix 分支了，而且 hotfix 分支的版本标识应当基于当前的 master 分支版本号。</p>
<p><img src="/2020/01/11/a-successful-branching-model/6.png" alt="img"></p>
<p>启用一条独立 hotfix 分支的好处在于，当一个开发者在准备线上产品的紧急修复时，完全不会影响到团队当中其它成员（例如在 develop 分支上开发新功能的成员）的工作。</p>
<h4 id="创建一个-hotfix-分支"><a href="#创建一个-hotfix-分支" class="headerlink" title="创建一个 hotfix 分支"></a>创建一个 hotfix 分支</h4><p>Hotfix 分支应当从 master 分支而来。在此我们举一个具体的例子吧，比如说当前的线上版本号是 1.2，而此时这个线上发布版由于相关服务的漏洞而产生了很严重的问题，但是此时的 develop 分支上还在开发新的功能，并且也完全还没达到准备好可以发布的状态，此时我们就要从当前运行的 master 分支中拆出一条热修复分支，针对当前的线上版本来修复相关问题了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hotfix-1.2.1 master</span><br><span class="line">Switched to a new branch &quot;hotfix-1.2.1&quot;</span><br><span class="line">$ ./bump-version.sh 1.2.1</span><br><span class="line">Files modified successfully, version bumped to 1.2.1</span><br><span class="line">$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;</span><br><span class="line">[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1</span><br><span class="line">1 files changed, 1 insertions(+), 1 deletions(1)</span><br></pre></td></tr></table></figure>
<p>创建 hotfix 分支后别忘了更新版本号！</p>
<p>接下来就可以开展修复工作了，修复过程中有可能会提交一个或多个 commit。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git commit -m &quot;Fixed server production problem&quot;</span><br><span class="line">[hotfix-1.2.1 abbe5d6] Fixed server production problem</span><br><span class="line">5 files changed, 32 insertions(+), 19 deletions(-)</span><br></pre></td></tr></table></figure>
<h4 id="完成-hotfix-分支"><a href="#完成-hotfix-分支" class="headerlink" title="完成 hotfix 分支"></a>完成 hotfix 分支</h4><p>当 hotfix 分支的相关工作做的差不多了，就可以准备将修复结果合并回 <strong>master</strong> 分支了，但是可别忘了，这些修复也必须要合并到 <strong>develop</strong> 分支上！否则 <strong>develop</strong> 分支没有得到更新，下一个发布版本中又会出现相同的问题。这个过程其实和 release 分支的收尾工作是完全一致的。</p>
<p>首先，我们先更新 <strong>master</strong> 分支并指定发布版本号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">$ git merge --no-ff hotfix-1.2.1</span><br><span class="line">Merge made by recursive.</span><br><span class="line">(Summary of changes)</span><br><span class="line">$git tag -a 1.2.1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>校订：你也可以使用 -s 或 -u 标记对标签进行加密签名。</p>
</blockquote>
<p>接下来，将修复的内容也合并到 <strong>develop</strong> 分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Swiched to branch &apos;develop&apos;</span><br><span class="line">$ git merge --no--ff hotfix-1.2.1</span><br><span class="line">Merge made by resursive.</span><br><span class="line">(Summary of changes)</span><br></pre></td></tr></table></figure>
<p>这里有一点需要特别注意，<strong>如果在 hotfix 分支完工的时刻存在 release 分支，那么你应该将修复合并到 release 分支中，而不是 develop 分支</strong>，因为 release 分支在完成的时候也会合并到 develop 分支上，因此直接 merge 到 release 上即可。（当然，如果热修复所针对的问题影响到了当下 develop 分支上的开发，没法等到 release 分支合并的那天，现在就得赶紧得到修复时，将 hotfix 分支直接合并回 develop 也是可以的。）</p>
<p>最后，hotfix 分支就可以被移除了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d hotfix-1.2.1</span><br><span class="line">Deleted branched hotfix-1.2.1 (was abbe5d6)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍完了这个分支模型，你会发现其实也没有什么令人称奇和大开眼界的地方，本文所讲述的模型在文章最开始的那张大图中有很清晰的展示，在大多数时候你参考那张图片就好了，它确实对我们的项目管理很有用，图示简洁优雅地阐述了这个分支模型，能够很好地帮助你的团队成员理解模型，并且在项目的分支管理和发布进程上达成一致的认识。</p>
<p>下面是本文原文的一份高质量 PDF 版本，你可以把他下载下来挂到你家的墙上，这样就可以在有不清楚地方的时候很方便地瞄两眼了（误(<em>/ω＼</em>)）。</p>
<p><strong>更新：</strong>如果有需要的话，可以来 <a href="http://github.com/downloads/nvie/gitflow/Git-branching-model-src.key.zip" target="_blank" rel="noopener">gitflow-model.src.key</a> 下载主图的源文件（Apple Keynote 格式）。</p>
<p><a href="https://nvie.com/files/Git-branching-model.pdf" target="_blank" rel="noopener">附件：Git-branching-model.pdf</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>初探 Java 中的异步 Socket</title>
    <url>/2019/10/10/Java-AsynchronousSocketChannels/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>阻塞模式下的 Socket 编程往往是非常低效的，然而 Java 中的典型 Socket 编程核心采用的正是这种模式。好在 Java 提供了另一种解决方案，通过 Socket Channel 技术实现了非阻塞的异步 Socket 编程。本文将以一个简单的同步 Socket Demo 切入，引出并介绍 Java 中的 Socket Channel 并完成一个 Asynchronous Socket 案例。</p>
</blockquote>
<p><img src="/2019/10/10/Java-AsynchronousSocketChannels/1.jpg" alt="文章头图"></p>
<a id="more"></a>
<blockquote>
<p><strong>友情提示</strong>：本文还没有写完，明天再说吧（我太难了5555）</p>
</blockquote>
<h1 id="一、Socket"><a href="#一、Socket" class="headerlink" title="一、Socket"></a>一、Socket</h1><p>在今天的软需分析课上，老师向我们展示了一段用 Java 编写的简单 Socket 通信例程，实现的是基础的 C/S 双向通信。我曾使用 Python 和其它语言开发过 Socket 项目，但为了熟悉 Java 便拿着老师给的代码照着码了一遍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> EOFException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server is listening on port 8080."</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>(</span><br><span class="line">                <span class="comment">// Create a socket server</span></span><br><span class="line">                ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">                <span class="comment">// Get server socket</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">// Get socket I/O stream</span></span><br><span class="line">                DataInputStream inputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">                DataOutputStream outputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">                <span class="comment">// Get Console buffered Reader</span></span><br><span class="line">                BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">// Input</span></span><br><span class="line">                    <span class="comment">// Receive message from clients</span></span><br><span class="line">                    String iString = inputStream.readUTF();</span><br><span class="line">                    <span class="comment">// Display message received</span></span><br><span class="line">                    System.out.println(<span class="string">"[Client] "</span> + iString);</span><br><span class="line">                    <span class="comment">// Output</span></span><br><span class="line">                    <span class="comment">// Get console input</span></span><br><span class="line">                    String aString = bufferedReader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(aString.equals(<span class="string">"bye"</span>))<span class="keyword">break</span>;</span><br><span class="line">                    outputStream.writeUTF(aString);</span><br><span class="line">                    outputStream.flush();</span><br><span class="line">                    System.out.println(<span class="string">"[Info] "</span> + aString + <span class="string">" has been sent."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException exp) &#123;</span><br><span class="line">                exp.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Client is running."</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span>(</span><br><span class="line">                    <span class="comment">// Socket connect</span></span><br><span class="line">                    Socket socket = <span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8080</span>);</span><br><span class="line">                    <span class="comment">// Get socket I/O stream</span></span><br><span class="line">                    DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line">                    DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line">                    <span class="comment">// Build a Console buffered Reader</span></span><br><span class="line">                    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">// Output</span></span><br><span class="line">                    <span class="comment">// Get console input</span></span><br><span class="line">                    String aString = bufferedReader.readLine();</span><br><span class="line">                    <span class="keyword">if</span>(aString.equals(<span class="string">"bye"</span>))<span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// Send message</span></span><br><span class="line">                    dataOutputStream.writeUTF(aString);</span><br><span class="line">                    dataOutputStream.flush();</span><br><span class="line">                    System.out.println(<span class="string">"[Info] "</span> + aString + <span class="string">" has been sent."</span>);</span><br><span class="line">                    <span class="comment">// Input</span></span><br><span class="line">                    <span class="comment">// Receive message from server</span></span><br><span class="line">                    String iString = dataInputStream.readUTF();</span><br><span class="line">                    <span class="comment">// Display message received</span></span><br><span class="line">                    System.out.println(<span class="string">"[Server] "</span> + iString);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(UnknownHostException exp)&#123;</span><br><span class="line">                exp.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException exp) &#123;</span><br><span class="line">                exp.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而运行结果不尽人意。C/S 之间确实可以相互收发，但彼此间的通信总是被“随机地” “延迟” 送达。课后重新调试时才发现，Java (Server)Socket 类中的 I/O 及 Client 连接均是阻塞的 Synchronous 实现。阻塞模式下的 Socket 编程往往是非常低效的，然而 Java 中的典型 Socket 编程核心采用的正是这种模式。</p>
<h1 id="二、Socket-Channel"><a href="#二、Socket-Channel" class="headerlink" title="二、Socket Channel"></a>二、Socket Channel</h1><h1 id="三、Asynchronous-Socket-Channel"><a href="#三、Asynchronous-Socket-Channel" class="headerlink" title="三、Asynchronous Socket Channel"></a>三、Asynchronous Socket Channel</h1><h1 id="四、构建一个简易的异步-Socket-演示"><a href="#四、构建一个简易的异步-Socket-演示" class="headerlink" title="四、构建一个简易的异步 Socket 演示"></a>四、构建一个简易的异步 Socket 演示</h1><h1 id="五、参考文章与推荐阅读"><a href="#五、参考文章与推荐阅读" class="headerlink" title="五、参考文章与推荐阅读"></a>五、参考文章与推荐阅读</h1><p>[1] <a href="https://www.codejava.net/java-se/networking/java-socket-server-examples-tcp-ip" target="_blank" rel="noopener">Java Socket Server Examples (TCP/IP)</a></p>
<p>[2] <a href="https://www.developer.com/java/data/understanding-asynchronous-socket-channels-in-java.html" target="_blank" rel="noopener">Understanding Asynchronous Socket Channels in Java</a></p>
<p>[3] <a href="http://www.java2s.com/Tutorials/Java/Java_Network/0080__Java_Network_Asynchronous_Socket_Channels.htm" target="_blank" rel="noopener">Java Network Tutorial - Java Asynchronous Socket Channels</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的数据成员远离 public/protected！</title>
    <url>/2019/09/28/donot-use-public-protected/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在面向对象的程序设计语言中，类的设计对软件的整体架构而言影响非常深远。类的封装作为面向对象的三大基石之首，几乎所有的主流 OOP 程序设计语言都为其提供了诸如 private、protected 和 public 这三种访问限定修饰符，其目的无非是为了帮助类更方便地与外界进行一些必要的交流和沟通。可是，对于类的数据成员而言，一旦你为其声明了 public/protected 的访问限定，那么这一举措对你的中大型程序构建而言将是灾难性的。</p>
<h1 id="一、数据的安全性引人忧虑"><a href="#一、数据的安全性引人忧虑" class="headerlink" title="一、数据的安全性引人忧虑"></a>一、数据的安全性引人忧虑</h1><p>要深刻理解为什么 public/protected 如何可怕，就要首先明白封装的意义何在。</p>
<p>在曾经主流的面向过程的程序开发当中，代码的复用是函数级的，而在每一个函数当中所实行的都是过程式编码，这也就意味着在主函数当中的函数调用式编程亦是过程式的。在作用域的约束之下，为了使得不同的函数域都能够访问同一个变量，达到函数职能效益的最大化，往往将其声明为全局变量。这直接导致了任何的函数都将能够对其进行读和写的操作，对于数据的安全性而言这简直是当头一棒！在小型程序开发者的眼里，这点风险根本不足为惧，可是对于大型程序开发者来说，变量值的修改将完全不再受到开发者的掌控，值异常现象将有可能由庞大代码量中的任何一个操作该变量的默默无闻的小角落中产生。如此一来，大型程序的开发与维护变得举步维艰。</p>
<a id="more"></a>
<h1 id="二、封装与-private-带来曙光"><a href="#二、封装与-private-带来曙光" class="headerlink" title="二、封装与 private 带来曙光"></a>二、封装与 private 带来曙光</h1><p>幸运的是，面向对象的编程范式应运而生了，类的封装不仅使得程序开发逻辑更加符合人的自然思考方式，代码也变得更加简洁、更具可读性了。更加重要的是，面向对象编程语言为我们提供了丰富的访问限定标识，数据的暴露与否终于不再非黑即白，而是变得更加可控了。开发人员终于可以在安全性与功能性之间找到平衡，男默女泪。</p>
<p>对于 private 而言，它绝对是帮助程序员编写稳固代码的最佳帮手。一旦你将类的某个数据成员声明为 private，也就对外宣布了主权：这个成员是我的私藏品，只有我才能够访问它！于此同时，你也可以通过为某一私有数据成员编写公有的 get/set 方法将其选择性地对外暴露，如此一来，你可以为你的数据成员对外创造出”不准访问“、”只读访问“和”读写访问“，你甚至还可以对外创造出一个”只写访问“的奇葩数据成员。</p>
<p>终于，你可以籍由 private 访问限定符随心所欲地将具有相关需求的数据成员对外暴露并且不必过分忧虑其安全问题，因为在访问限定的“继承体制”加持下，你的数据成员将一直保持着一个有所保留的矜持者形象，绝不允许被某些好心办坏事或是图谋不轨的不明代码肆意篡改。由此一来，每当你为你的数据成员显式地敲下私有的访问限定符，都是为将来维护阶段中无数个修 bug 的加班日夜争取了一些享受生活的美好时光。珍爱生命，我用 private。</p>
<h1 id="三、public-protected-是复辟者"><a href="#三、public-protected-是复辟者" class="headerlink" title="三、public/protected 是复辟者"></a>三、public/protected 是复辟者</h1><p>但是注意！不要因为 private 为我们带来一片利好，就不暇思索地也对其它访问限定符付出真心并委以重任，若如此你便身处险境了。事实上，在所有的访问限定修饰符当中，唯有 private 才是帮助开发人员维护代码稳定与数据安全的正规军，其它诸如 public 与 protected 等皆是旧制度下风险派的邪恶复辟者！这些囚徒们妄想冲出封装的牢笼，将你构建安全、稳定、低耦合代码的美梦砸个粉碎，并籍由编译器发声，在未来的某一天向你抛出一堆鲜红的 Errors 得意示威。</p>
<p>试想一下，如果你将一个数据成员的访问限定符声明为了 protected，这将意味着什么？这将意味着在未来，以这个类作为父类的所有派生类都将具有直接读写该成员的至高权利！你或许觉得“对啊，这正是我想要的，这对于我的开发而言应该是有利的吧“，因为你认为具有父子关系的两个类不再需要为安全性问题而夙夜忧患了，构建 get/set 围墙的工作好像失去了必要性。然而你所不知道的是，你的项目在你做出 protected 这一决定的时候已然搭上了贴有“维护困难”标签的班车，并且随着你敲下越来越多的 protected 关键字，你的项目也哼着小曲儿，随着你一起在驶向终点站 “无法维护” 的道路上所向睥睨。</p>
<p>在未来的某一天里，由于某些原因，被你指定为 protected 的那些数据成员需要转型为 private 时，所有继承并操作了这一成员的派生类就要喜提 Errors 了，因为它们无法再像以前一样直接操作这些数据，你需要将所有相关代码全部重写为以 get/set 的方式进行访问，甚至当这些数据成员被取消使用时，所有的访问代码都失去了意义。你看到了，一个基类 protected 数据成员的变更将破坏所有相关的派生类。而若你的数据成员声明的不是 protected 而是 public，又将有多少代码受到伤害？</p>
<p>对于数据成员而言，public/protected 在表面上光鲜亮丽，好像是”自由“与”开放“的崇尚者，然而实际上确实另一维度上的 “const”。可以说，它们不仅大大增加了代码修改与维护的难度，将数据与多个类使用胶水一般粘在了一起，还具有极其隐蔽的风险性，而规避这些问题最好的办法便是拒绝使用它们。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验心得</category>
      </categories>
  </entry>
  <entry>
    <title>VSCode + xUnit 编写 C# 单元测试</title>
    <url>/2019/09/26/vscode-xunit-unittest/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>什么是单元测试？为什么要写单元测试？如何写一个单元测试？实话实说，写单元测试是一件挺麻烦的事情，却又是你在软件开发的成长路上难以回避的一个问题。我个人在以前也并不喜欢单元测试，不过现在我的态度有所改观了。如果本文所写的内容可以让你理解单元测试的重要性，并且说服你在今后也开始尝试编写单元测试的话，那么这篇博文就是成功的。</p>
</blockquote>
<p><img src="/2019/09/26/vscode-xunit-unittest/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、什么是单元测试？"><a href="#一、什么是单元测试？" class="headerlink" title="一、什么是单元测试？"></a>一、什么是单元测试？</h1><blockquote>
<p>Having automated tests is a great way to ensure a software application does what its authors intend it to do. There are multiple types of tests for software applications. These include integration tests, web tests, load tests, and others. <strong>Unit tests</strong> test individual software components and methods. Unit tests should only test code within the developer’s control. They should not test infrastructure concerns. Infrastructure concerns include databases, file systems, and network resources.</p>
</blockquote>
<p>以上是微软在官方文档《<a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/" target="_blank" rel="noopener">.NET Core 和 .NET Standard 中的单元测试</a>》中对单元测试给出的描述。其中提到，单元测试用于测试个人软件组件或方法，单元测试仅应测试开发人员控件内的代码，它们不应测试基础结构问题。 基础结构问题包括数据库、文件系统和网络资源。也就是说单元测试的被测目标必须足够的“独立”，进而测试代码也应足够简洁。</p>
<p>按我的理解来说，单元测试就是一项验证一个类或方法是否能够正常执行并得到正确结果的测试工作，其中的类或方法就是被测试的单元。看完这些，你可能还是不能够清晰地理解单元测试，不过不要紧，在后面的分析中，相信单元测试的形象将会在你的脑海中逐渐清晰。</p>
<h1 id="二、为什么要写单元测试？"><a href="#二、为什么要写单元测试？" class="headerlink" title="二、为什么要写单元测试？"></a>二、为什么要写单元测试？</h1><p>实话实说，写单元测试是一件挺麻烦的事情，我个人在以前也并不喜欢单元测试，不过现在我的态度有所改观了。如果我之后写的内容可以让你理解单元测试的重要性，并且说服你在今后也开始尝试单元测试，那么这一小节就是成功的。</p>
<p>首先，在实际的开发过程中施行单元测试是一项非常有意义的事情，它既可以保证我们程序的健壮性，也可以在很大程度上帮助我们写出更稳定、低耦合的代码，进而在维护期保护了应用程序迭代更新的安全性与需求变动时的可拓展性。这是因为，一个优秀完备的单元测试往往能够覆盖类和方法的各种边界条件，进而在源头处破灭了许多bug诞生的梦想，由此各个单元都能够稳定正确地执行，整个程序的健壮性便得到了保障。</p>
<p>考虑一个简单的例子，你正在写一个求整型数组中最大元素的方法，下面是其实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace MyAlgorithm</span><br><span class="line">&#123;</span><br><span class="line">    public  class ArrayService</span><br><span class="line">    &#123;</span><br><span class="line">        public static int MaxItemValue(int[] arr)</span><br><span class="line">        &#123;</span><br><span class="line">            var maxValue = arr[0];</span><br><span class="line">            foreach(var item in arr)</span><br><span class="line">            &#123;</span><br><span class="line">                if(item&gt;maxValue)	maxValue = item;</span><br><span class="line">            &#125;</span><br><span class="line">            return maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，如果你直接着手实现的细节而开始写代码的话，你将难免忘记考虑一些边界条件，而程序在各种环境运行的过程中，情况往往丰富多变，这就导致所写出的程序往往在调试期间可以“正确运行”，可是一旦投入使用，各种灵异错误就接踵而来。上面的代码段作为一个错误的例子，相信你不难看出是有明显的问题的。在通常的输入下，它可以正常的执行，可是如果输入的数组为空呢？那就糟糕了，你绝对不想看到编译器给你抛出一堆鲜红的Errors，更不希望让用户看到错误警告。可是当你养成写单元测试的习惯时，你就会自然地为测试单元有意地设计各种看似“不合理”的输入，而一旦你的代码通过了严苛而险恶的单元测试，恭喜你，这个可靠的单元可以被你贴上”合格”的标签放心地使用了。</p>
<p>于此同时，单元测试帮助代码更稳定、低耦合是由于，一个与其它单元耦合度高又内部复杂的类或方法，我们几乎无法为其写出一个简明可行的单元测试，这就显示地要求开发者对当前过分复杂的“单元”进行拆分与解耦，以便为其书写单元测试，这也就促使程序变得更加模块化，更具可读性了。这对于一直想要写出更加优秀代码的你来讲简直是太棒了，不是吗？</p>
<p>由此可以发现，单元测试其实就是为组成我们程序的一个个小单元，可以是类或方法或是其它的组件，单独编写测试用例，以保证它们的正确性与可靠性。这既是单元测试的进一步阐述，也是你为什么要写单元测试的原因。</p>
<h1 id="三、如何创建单元测试？"><a href="#三、如何创建单元测试？" class="headerlink" title="三、如何创建单元测试？"></a>三、如何创建单元测试？</h1><p>了解了单元测试及其必要性，下面就来看一看如何写一个单元测试吧。在不同的编辑器或集成开发环境中为代码编写单元测试的方法不尽相同，本节中将演示如何在 VSCode 中使用 xUnit 为 C# 项目编写一个简单的单元测试。这一节演示将分为四个部分：创建项目、编写一个示例类、为示例类创建单元测试类，以及在单元测试类中为示例类的一个成员函数编写单元测试代码。</p>
<p>在演示中，我们将创建一个用于数字计算的 NumberCacluation 类，并实现该类的一个整数求和函数 add()，最后为该类创建单元测试类并为其成员函数 add() 编写单元测试代码。如果你使用的是 Visual Studio，那么网上也有很多针对 VS 的单元测试编写指导，在此就不多提了。下面就让我们开始吧！</p>
<h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><ol>
<li><p>在 VSCode 中打开一个文件夹，本例中新建并打开文件夹 MyProject。</p>
</li>
<li><p>打开终端，执行 <code>dotnet new sln</code> 来新建一个解决方案，此时你在 MyProject 文件夹中将得到一个 MyProject.sln 解决方案文件。</p>
</li>
<li><p>在 MyProject 文件夹下新建一个目录 MyMath，作为我们的数学计算类库文件夹。</p>
</li>
<li><p>在终端中进入 MyMath 目录，执行 <code>dotnet new classlib</code> 来对此类库文件夹进行初始化，你将在 MyMath 文件夹中得到 MyMath.csproj 与一个默认的 cs 文件 Class1.cs，在此我们将其改名为 NumberCalculation.cs，其代码结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace MyMath.Number</span><br><span class="line">&#123;</span><br><span class="line">    public class NumberCalculation</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，在终端中回到 MyProject 目录，执行 <code>dotnet sln add .\MyMath\MyMath.csproj</code> 来将 MyMath 添加到解决方案当中。至此，我们就完成了项目的创建。</p>
</li>
</ol>
<h2 id="2-编写示例类"><a href="#2-编写示例类" class="headerlink" title="2.编写示例类"></a>2.编写示例类</h2><p>打开 MyMath 目录下的 NumberCalculation.cs 文件，下面我们为其编写一个静态函数，用于求解两个整数求和计算的结果，实现代码非常简单，下面是完整的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace MyMath.Number</span><br><span class="line">&#123;</span><br><span class="line">    public class NumberCalculation</span><br><span class="line">    &#123;</span><br><span class="line">        public static int add(int a, int b)</span><br><span class="line">        &#123;</span><br><span class="line">            return a + b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-创建单元测试"><a href="#3-创建单元测试" class="headerlink" title="3.创建单元测试"></a>3.创建单元测试</h2><ol>
<li><p>我们先在终端 MyProject 目录下新建一个文件夹：MyMath.Tests，这个文件夹中用于存放 MyMath 的相关单元测试文件。</p>
</li>
<li><p>在终端中进入 MyMath.Tests 目录，执行 <code>dotnet new xunit</code> 来初始化 xunit，此命令会创建将 xUnit 用作测试库的测试项目。你将得到 MyMath.csproj 和 一个默认的单元测试类 UnitTest1.cs，我们将其改名为 MyMath.Tests.Number.cs，代码结构如下（记得为其手动添加 NumberCalculation 的命名空间引用<code>using MyMath.Number;</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Xunit;</span><br><span class="line"></span><br><span class="line">namespace MyMath.Tests.Number</span><br><span class="line">&#123;</span><br><span class="line">    public class UnitTest1</span><br><span class="line">    &#123;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test1()</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在终端 MyMath.Tests 目录下执行 <code>dotnet add reference ..\MyMath\MyMath.csproj</code> 来将 MyMath 引入到我们的单元测试项目中来。</p>
</li>
<li><p>最后在终端中回到 MyProject 目录，执行 <code>dotnet sln add .\MyMath.Tests\MyMath.Tests.csproj</code> 来将 MyMath.Tests 添加到解决方案中。至此，我们完成了 MyMath 类单元测试的创建与一些初始设置。</p>
</li>
</ol>
<h2 id="4-编写单元测试"><a href="#4-编写单元测试" class="headerlink" title="4. 编写单元测试"></a>4. 编写单元测试</h2><p>打开 MyMath.Tests 目录下的 UnitTest1.cs 文件，编写如下四个测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using Xunit;</span><br><span class="line">using MyMath.Number;</span><br><span class="line">namespace MyMath.Tests.Number</span><br><span class="line">&#123;</span><br><span class="line">    public class UnitTest1</span><br><span class="line">    &#123;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test1()</span><br><span class="line">        &#123;</span><br><span class="line">            Assert.True(NumberCalculation.add(0,2)==2, &quot;0 + 2 Should be 2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test2()</span><br><span class="line">        &#123;</span><br><span class="line">            Assert.True(NumberCalculation.add(1,2)==3, &quot;1 + 2 Should be 3&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test3()</span><br><span class="line">        &#123;</span><br><span class="line">            Assert.True(NumberCalculation.add(-1,2)==1, &quot;-1 + 2 Should be 1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        [Fact]</span><br><span class="line">        public void Test4()</span><br><span class="line">        &#123;</span><br><span class="line">            Assert.True(NumberCalculation.add(-1,-2)==-3, &quot;-1 + -2 Should be -3&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就完成了 add() 方法的简单单元测试示例。其中 <code>[Fact]</code> 标记指明下面的方法为测试方法，<code>Assert.True()</code> 函数中的第一项参数为实际值，其预期值为 <code>True</code>，当实际值与预期值一致时，该测试就可以通过，否则该测试不能通过，并将在终端中将参数二作为错误信息输出显示。</p>
<p>最后，在终端中 MyMath.Tests 文件夹下执行 <code>dotnet test</code> 即可运行单元测试。显然，我们之前编写的函数是可以正确计算所给用例的加法的，因此终端输出了如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\...\MyProject&gt; dotnet test</span><br><span class="line">已开始生成，请等待...</span><br><span class="line">Skipping running test for project C:\...\MyProject\MyMath\MyMath.csproj. To run tests with dotnet test add &quot;&lt;IsTestProject&gt;true&lt;IsTestProject&gt;&quot; property to project file.</span><br><span class="line">完成的生成。</span><br><span class="line"></span><br><span class="line">C:\...\MyProject\MyMath.Tests\bin\Debug\netcoreapp2.2\MyMath.Tests.dll 的测试运行(.NETCoreApp,Version=v2.2)</span><br><span class="line">Microsoft (R) 测试执行命令行工具版本 15.9.0</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">正在启动测试执行，请稍候...</span><br><span class="line"></span><br><span class="line">总测试: 4。已通过: 4。失败: 0。已跳过: 0。</span><br><span class="line">测试运行成功。</span><br><span class="line">测试执行时间: 2.4093 秒</span><br></pre></td></tr></table></figure>
<p>如果我们的 add() 方法编写有误，例如将 <code>return a + b;</code> 错误地修改为 <code>return b;</code>，再次执行 <code>dotnet test</code> 将得到如下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\...\MyProject&gt; dotnet test</span><br><span class="line">已开始生成，请等待...</span><br><span class="line">Skipping running test for project C:\...\MyProject\MyMath\MyMath.csproj. To run tests with dotnet test add &quot;&lt;IsTestProject&gt;true&lt;IsTestProject&gt;&quot; property to project file.</span><br><span class="line">完成的生成。</span><br><span class="line"></span><br><span class="line">C:\...\MyProject\MyMath.Tests\bin\Debug\netcoreapp2.2\MyMath.Tests.dll 的测试运行(.NETCoreApp,Version=v2.2)</span><br><span class="line">Microsoft (R) 测试执行命令行工具版本 15.9.0</span><br><span class="line">版权所有 (C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">正在启动测试执行，请稍候...</span><br><span class="line">[xUnit.net 00:00:01.04]     MyMath.Tests.Number.UnitTest1.Test4 [FAIL]</span><br><span class="line">[xUnit.net 00:00:01.07]     MyMath.Tests.Number.UnitTest1.Test2 [FAIL]</span><br><span class="line">[xUnit.net 00:00:01.07]     MyMath.Tests.Number.UnitTest1.Test3 [FAIL]</span><br><span class="line">MyMath.Tests.Number.UnitTest1.Test4 个失败</span><br><span class="line">错误消息:</span><br><span class="line"> -1 + -2 Should be -3</span><br><span class="line">Expected: True</span><br><span class="line">Actual:   False</span><br><span class="line">堆栈跟踪:</span><br><span class="line">   at MyMath.Tests.Number.UnitTest1.Test4() in C:\...\MyProject\MyMath.Tests\UnitTest1.cs:line 26</span><br><span class="line">MyMath.Tests.Number.UnitTest1.Test2 个失败</span><br><span class="line">错误消息:</span><br><span class="line"> 1 + 2 Should be 3</span><br><span class="line">Expected: True</span><br><span class="line">Actual:   False</span><br><span class="line">堆栈跟踪:</span><br><span class="line">   at MyMath.Tests.Number.UnitTest1.Test2() in C:\...\MyProject\MyMath.Tests\UnitTest1.cs:line 16</span><br><span class="line">MyMath.Tests.Number.UnitTest1.Test3 个失败</span><br><span class="line">错误消息:</span><br><span class="line"> -1 + 2 Should be 1</span><br><span class="line">Expected: True</span><br><span class="line">Actual:   False</span><br><span class="line">堆栈跟踪:</span><br><span class="line">   at MyMath.Tests.Number.UnitTest1.Test3() in C:\...\MyProject\MyMath.Tests\UnitTest1.cs:line 21</span><br><span class="line"></span><br><span class="line">总测试: 4。已通过: 1。失败: 3。已跳过: 0。</span><br><span class="line">测试运行失败。</span><br><span class="line">测试执行时间: 2.4545 秒</span><br></pre></td></tr></table></figure>
<p>可以看到，终端中明确输出了未通过测试的用例及其错误信息，这将帮助你很快地定位并修复相关错误。</p>
<h1 id="四、优化你的单元测试"><a href="#四、优化你的单元测试" class="headerlink" title="四、优化你的单元测试"></a>四、优化你的单元测试</h1><p>写出一个单元测试不是一件难事，但是写出一个好的单元测试也不是一件容易的事。就上一小结 <strong>编写单元测试</strong> 中给出的测试代码就是极度糟糕的代码的典范。为了使用 xUnit 写出基本还不错的测试代码，你需要了解 <a href="https://xunit.net/" target="_blank" rel="noopener">xUnit</a> 的一些其它属性。例如 <code>[Theory]</code> 表示执行相同的代码，但是使用不同的输入参数用来测试，并使用 <code>[InlineData]</code> 来指定这些参数的输入值。</p>
<p>由此改进后的单元测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UnitTest1</span><br><span class="line">    &#123;</span><br><span class="line">        [Theory]</span><br><span class="line">        [InlineData(0,2,2)]</span><br><span class="line">        [InlineData(1,2,3)]</span><br><span class="line">        [InlineData(-1,2,1)]</span><br><span class="line">        [InlineData(-1,-2,-3)]</span><br><span class="line">        public void Test1(int a, int b, int excepted)</span><br><span class="line">        &#123;</span><br><span class="line">            Assert.True(NumberCalculation.add(a,b)==excepted, $&quot;&#123;a&#125; + &#123;b&#125; Should be &#123;excepted&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了确保单元测试的正确性与轻便性，应当选取尽可能少且具有代表性的参数作为测试用例，否则过多的测试用例不仅有可能被人为地赋予错误期望造成单元测试失效（例如不小心将 [InlineData(-1,-2,-3)] 的期望输出写成了 3），也将增加每一次单元测试的时间开销。</p>
<p>针对 .NET Core 和 .NET Standard 单元测试的最佳做法与工程实施规范，微软在其官方文档中给出了详尽的说明，这些条款在单元测试的编写中具有很好的指导意义，可以帮助你写出更具规范与更易读的单元测试：<a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices" target="_blank" rel="noopener">《.NET Core 和 .NET Standard 单元测试最佳做法》</a>。</p>
<h1 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h1><ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/" target="_blank" rel="noopener">.NET Core 和 .NET Standard 中的单元测试</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-with-dotnet-test" target="_blank" rel="noopener">使用 dotnet test 和 xUnit 在 .NET Core 中进行 C# 单元测试</a></li>
<li><a href="https://deviq.com/explicit-dependencies-principle/" target="_blank" rel="noopener">The Explicit Dependencies Principle states</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.net</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Bcdedit 删除 Boot Menu 中的多余启动引导</title>
    <url>/2019/08/27/bcdedit-clean-bootmenu/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>在过去一篇博文《<a href="https://houkaifa.com/2019/08/15/ubuntu-uninstall/" target="_blank" rel="noopener">如何科学卸载 Ubuntu？</a>》中曾提到 Ubuntu 启动引导的删除，其中先后通过 EasyUEFI 与 diskpart 工具删除了 Ubuntu 的启动引导条目以及 Ubuntu 的 EFI 分区，但是仍有可能出现启动引导的残留，最直接的表现就是在开机的时候依旧没有正常进入系统而是进入了 GRUB 界面。本文以清理 Ubuntu 启动引导残留为例，演示如何借助 Bcdedit 移除固件应用程序，进而彻底清理启动引导残留，同理亦可以移除多系统下不需要的启动引导。</p>
</blockquote>
<p><img src="/2019/08/27/bcdedit-clean-bootmenu/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、找到固件GUID"><a href="#一、找到固件GUID" class="headerlink" title="一、找到固件GUID"></a>一、找到固件GUID</h1><p>在 PowerShell 中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /enum firmware</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">固件启动管理器</span><br><span class="line">---------------------</span><br><span class="line">标识符                  &#123;fwbootmgr&#125;</span><br><span class="line">displayorder            &#123;8729d185-7270-11e7-bd79-850bbbb583d1&#125;</span><br><span class="line">                        &#123;bootmgr&#125;</span><br><span class="line">timeout                 1</span><br><span class="line"></span><br><span class="line">Windows 启动管理器</span><br><span class="line">--------------------</span><br><span class="line">标识符                  &#123;bootmgr&#125;</span><br><span class="line">device                  partition=\Device\HarddiskVolume1</span><br><span class="line">path                    \EFI\MICROSOFT\BOOT\BOOTMGFW.EFI</span><br><span class="line">description             Windows Boot Manager</span><br><span class="line">locale                  zh-CN</span><br><span class="line">inherit                 &#123;globalsettings&#125;</span><br><span class="line">flightsigning           Yes</span><br><span class="line">default                 &#123;current&#125;</span><br><span class="line">resumeobject            &#123;8729d17d-7270-11e7-bd79-850bbbb583d1&#125;</span><br><span class="line">displayorder            &#123;current&#125;</span><br><span class="line">toolsdisplayorder       &#123;memdiag&#125;</span><br><span class="line">timeout                 30</span><br><span class="line"></span><br><span class="line">固件应用程序(101fffff)</span><br><span class="line">-------------------------------</span><br><span class="line">标识符                  &#123;8729d185-7270-11e7-bd79-850bbbb583d1&#125;</span><br><span class="line">device                  partition=\Device\HarddiskVolume1</span><br><span class="line">path                    \EFI\UBUNTU\SHIMX64.EFI</span><br><span class="line">description             ubuntu</span><br></pre></td></tr></table></figure>
<p>其中固件应用程序(101ffff)为我们要删除的 Ubuntu 启动引导：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">固件应用程序(101fffff)</span><br><span class="line">-------------------------------</span><br><span class="line">标识符                  &#123;8729d185-7270-11e7-bd79-850bbbb583d1&#125;</span><br><span class="line">device                  partition=\Device\HarddiskVolume1</span><br><span class="line">path                    \EFI\UBUNTU\SHIMX64.EFI</span><br><span class="line">description             ubuntu</span><br></pre></td></tr></table></figure>
<p>记下其标识符：{8729d185-7270-11e7-bd79-850bbbb583d1}</p>
<h1 id="二、删除对应固件条目"><a href="#二、删除对应固件条目" class="headerlink" title="二、删除对应固件条目"></a>二、删除对应固件条目</h1><p>1.通过 <strong>Bcdedit</strong> 保存一份电脑上现行的 bcd 文件副本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /export savebcd</span><br></pre></td></tr></table></figure>
<p>2.拷贝一份 savebcd 文件的副本用于协助 bcdedit 删除操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Copy savebcd newbcd</span><br></pre></td></tr></table></figure>
<p>3.枚举系统BCD存储中的固件命名空间对象并将输出结果保存到文本文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /enum firmware &gt; enumfw.txt</span><br></pre></td></tr></table></figure>
<p>4.使用记事本打开 enumfw.txt 文件，可以看到里面的内容与在 “一、找到固件GUID” 中是一致的，在输出的文本文件中找到要删除的 Ubuntu 启动引导对应的固件应用程序标识符：{8729d185-7270-11e7-bd79-850bbbb583d1}，复制备用。</p>
<p>5.在任意位置创建一个文本文档 RemoveDups.txt</p>
<p>6.使用记事本打开 RemoveDups.txt 并写入以下内容（其中GUID替换为你在上一步中复制的标标识符）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /store newbcd /delete GUID</span><br></pre></td></tr></table></figure>
<p>特别地，如果有多个要删除的固件应用程序的话，就将上面一行拷贝添加多行，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /store newbcd /delete GUID1</span><br><span class="line">Bcdedit /store newbcd /delete GUID2</span><br><span class="line">Bcdedit /store newbcd /delete GUID3</span><br><span class="line">Bcdedit /store newbcd /delete GUID4</span><br></pre></td></tr></table></figure>
<p><strong>注意：在EFI固件为本地设备初始化NVRAM条目的计算机上，如果需要，可以删除所有GUID条目。但不要删除的条目 {bootmgr}！</strong></p>
<p>7.在 RemoveDups.txt 的最后一行写入以下命令，通过使用/clean选项删除导入操作中的所有NVRAM条目来导入新的BCD文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bcdedit /import newbcd /clean</span><br></pre></td></tr></table></figure>
<p>8.保存 RemoveDups.txt 文件，并将其重命名为 RemoveDups.cmd，使其成为命令行文件。</p>
<p>9.将 RemoveDups.cmd 文件复制到 C:\Windows\system32 目录下，并在 PowerShell 中执行它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RemoveDups.cmd</span><br></pre></td></tr></table></figure>
<p>10.重新启动系统。在重新启动期间，EFI固件将使用与连接到系统的设备对应的固件对象 GUID 重新初始化 NVRAM。进入系统后，可使用 bcdedit /enum firmware 命令进一步验证是否已删除所有需要删除的固件条目。</p>
<p>参考文献：<a href="http://1t.click/SA8" target="_blank" rel="noopener">Remove Duplicate Firmware Objects in BCD and NVRAM</a></p>
<p>扩展阅读：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-vista/cc766450%28v%3dws.10%29" target="_blank" rel="noopener">Deploy to UEFI-based Computers</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>如何科学卸载 Ubuntu？</title>
    <url>/2019/08/15/ubuntu-uninstall/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇记录 Win10+Ubuntu 双系统下卸载 Ubuntu 的全步骤。由于磁盘空间告急，而且 Ubuntu 在近期内并没有使用需求，考虑到之前装的 Ubuntu 遇到的显卡驱动问题始终得不到解决，因此决定暂时将 Ubuntu 卸载以空出磁盘空间给 Win10 使用，下次需要 Ubuntu 时也方便重新安装，也期待下次安装时能够解决显卡驱动问题。</p>
</blockquote>
<p><img src="/2019/08/15/ubuntu-uninstall/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、删除Ubuntu启动引导-启动引导删不干净？戳我"><a href="#一、删除Ubuntu启动引导-启动引导删不干净？戳我" class="headerlink" title="一、删除Ubuntu启动引导 (启动引导删不干净？戳我)"></a>一、删除Ubuntu启动引导 (<a href="https://houkaifa.com/2019/08/27/bcdedit-clean-bootmenu/" target="_blank" rel="noopener">启动引导删不干净？戳我</a>)</h1><p>我的系统是 GTP+UEFI 的分区模式，因此选择 EasyUEFI 进行启动引导的删除。同时我的系统是 Win10 企业版，因此只能使用 EasyUEFI 的企业版进行操作。</p>
<p>选中启动序列中的 ubuntu 项，并在右侧操作栏中找到并点击<strong>删除选中项</strong>按钮，即可完成 Ubuntu 启动引导的删除。</p>
<blockquote>
<p>如果没有做此步骤的话，可能在重启之后无法直接进入 Win10 系统，而是进入了 GRUB 引导界面，这时只要在 GRUB 中键入 exit 并回车即可进入 Win10。</p>
</blockquote>
<p><img src="/2019/08/15/ubuntu-uninstall/2.jpg" alt="Title"></p>
<p><center>图1 在EasyUEFI中删除Ubuntu启动序列</center></p>
<h1 id="二、删除Ubuntu相关分区"><a href="#二、删除Ubuntu相关分区" class="headerlink" title="二、删除Ubuntu相关分区"></a>二、删除Ubuntu相关分区</h1><h2 id="删除主分区"><a href="#删除主分区" class="headerlink" title="删除主分区"></a>删除主分区</h2><p>在 Win10 系统下，使用快捷键 Win+X 打开磁盘管理，在窗口中找到安装 Ubuntu 的磁盘，并找到当时安装 Ubuntu 时创建的磁盘分区。依次选中这些分区，执行右键删除卷即可。</p>
<p><img src="/2019/08/15/ubuntu-uninstall/3.jpg" alt="1Title"></p>
<p><center>图2 在磁盘管理中删除Ubuntu主分区</center></p>
<h2 id="删除-EFI-分区"><a href="#删除-EFI-分区" class="headerlink" title="删除 EFI 分区"></a>删除 EFI 分区</h2><p>EFI 分区是无法直接删除的，在磁盘管理中右键 EFI 分区，删除卷的操作项是禁止态。这时就需要使用 diskpart 系统工具将 Ubuntu 的 EFI 分区转化为非 EFI 分区进而将其删除。下面我们来转换这个 EFI 分区。</p>
<blockquote>
<p>Win10 扩展卷的操作只有当未分配卷临靠于待分配卷的右侧才能执行，如下图所示，因为 114.52GB 的未分配卷与 F 盘之间隔了一个 488MB 的 Ubuntu EFI 分区，所以此时无法将 114.52GB 的磁盘空间分配给 F 盘，只能先将 EFI 分区删除。</p>
</blockquote>
<p><img src="/2019/08/15/ubuntu-uninstall/4.jpg" alt="Title"></p>
<p><center>图3 EFI分区无法被直接删除</center><br>1.在 cmd 中打开 diskpart</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diskpart</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/5.jpg" alt="Title"></p>
<p>2.列出计算机装配的磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list disk</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/6.jpg" alt="Title"></p>
<p>3.选择装有 Ubuntu 系统的磁盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sel disk 0</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/7.jpg" alt="Title"></p>
<p>4.列出磁盘分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list partition</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/8.jpg" alt="Title"></p>
<p>5.选择准备要删除的 Ubuntu EFI 分区（一定要看准了，不要错选成 Windows 的 EFI 分区）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sel partition 7</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/9.jpg" alt="Title"></p>
<p>6.设置分区id，复制下面的代码并回车，即可将选定分区转换为 FAT32 分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set id=ebd0a0a2-b9e5-4433-87c0-68b6b72699c7</span><br></pre></td></tr></table></figure>
<p><img src="/2019/08/15/ubuntu-uninstall/10.jpg" alt="Title"></p>
<p>这时我们重新进磁盘管理，可以看到分区已经被我们设置为了 FAT32 分区，现在即可正常右键删除卷。最后再在 F 盘上右键选择扩展卷，即可将之前 Ubuntu 的空间全部回收至 Win10 主分区中。</p>
<p><img src="/2019/08/15/ubuntu-uninstall/11.jpg" alt="Title"></p>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"><p>Ubuntu 卸载步骤小结（GTP+UEFI）：</p>
<ol>
<li>使用 EasyUEFI 删除 Ubuntu 启动引导；</li>
<li>在磁盘管理中删除 Ubuntu 主分区；</li>
<li>利用 diskpart 系统工具将 Ubuntu 的 EFI 分区转化为非 EFI 分区并删除；</li>
<li>将原 Ubuntu 系统空间回收扩展至 Win10 主分区。</li>
</ol>
</div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>由C++虚析构函数风险性产生的思考</title>
    <url>/2019/05/18/C-VirtualWarning/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>virtual 关键字作为 C++ 多态特性的表现载体，在多态 base class 的析构当中对内存泄漏的避免具有相当重要的意义，但是与此同时却也存在一些难以窥探到的风险性，如果在开发过程中对 virtual 的使用稍有疏忽就很有可能走上弯路，甚至造成一些不必要的麻烦。这些麻烦轻则导致程序运行质量的降低，耗费了更多的内存，重则造成更加严重的问题，产生内存泄漏、影响程序的移植性。</p>
</blockquote>
<p><img src="/2019/05/18/C-VirtualWarning/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h2 id="为多态基类声明虚析构函数"><a href="#为多态基类声明虚析构函数" class="headerlink" title="为多态基类声明虚析构函数"></a>为多态基类声明虚析构函数</h2><p>在许多程序当中需要使用到计时器，那么设计一个计时基类 Timer base class 及一些用来以不同的方式计时的派生类就显得十分正常。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timerbase</span>	// 时钟基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Timerbase();</span><br><span class="line">    ~Timerbase();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span> <span class="keyword">public</span> Timebase &#123;...&#125;;	<span class="comment">// 原子钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span>:</span> <span class="keyword">public</span> Timebase &#123;...&#125;;	<span class="comment">// 腕表</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果作为库程序的开发者，那么其用户通常不想关心库函数的具体实现，他们只是想要一个用以实现计时功能的计时器，那么一般情况下我们可以给出一个工厂函数（Factory），这个函数最终将返回一个被需求的计时器，一个  base class 指针，指向新生的派生对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Timerbase* <span class="title">makeTimer</span><span class="params">()</span></span>;	<span class="comment">// 以 Timerbase 为基类动态分配一个计时对象</span></span><br></pre></td></tr></table></figure>
<p>为了避免内存泄露，库程序的使用者就应该在计时对象使用完毕后通过 delete 将其销毁，以避免资源浪费。其中一个比较浅白的风险在于，makeTimer 函数返回一个指向派生对象的指针，最终却经由一个基类指针删除，而此时的基类中并未声明虚析构函数，这正是此风险的源头。因为在C++当中明确指出，一个派生对象经由一个基类指针 delete，而这个基类不存在一个虚的析构函数，那么此操作是无定义的，并且通常情况下派生对象并不会被销毁释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Timerbase* atomicClock = makeTimer();	<span class="comment">// 返回一个指向派生对象 AtomicClock 的指针</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> atomicClock;	<span class="comment">// 派生成分 AtomicClock 并未被销毁</span></span><br></pre></td></tr></table></figure>
<p>在通过无虚析构函数的基类指针销毁其派生类对象时，派生实例未被销毁，派生类的析构函数也未被执行，而其基类成分却被销毁了，这就产生了一个诡异的被“局部销毁”的对象，最终结果则是造成了资源泄露。</p>
<p>消除这一风险的办法很简单，将基类的析构函数定义为 virtual 即可，同时也可为基类的其他成员函数冠以 virtual 以实现派生对象的客制化。由此可见，对于一个除析构函数外拥有虚函数的类而言，将析构函数写作为虚析构函数这一举措是非常有必要的。</p>
<h2 id="只为多态基类声明虚析构函数"><a href="#只为多态基类声明虚析构函数" class="headerlink" title="只为多态基类声明虚析构函数"></a>只为多态基类声明虚析构函数</h2><p>通常情况下，一个不包含任何虚函数的类是不被希望作为基类的，那么将一个非基类的析构函数冠以 virtual 是否又合理呢？换句话说，为了避免多态特性下派生类的销毁带来的内存隐患，是否值得将所有类的析构函数都替为虚析构函数？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>	// <span class="title">Point</span> 是一个独立的类，并不意图作为其他任何类的基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    <span class="keyword">virtual</span> ~Point();	<span class="comment">// 但是却声明了 virtual 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_iX;</span><br><span class="line">    <span class="keyword">int</span> m_iY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>事实表明这种做法是比较糟糕的，就拿上面的 Point class 为例，在其析构函数还不是虚函数的情况下，其有两个 int 型成员，若 int 型在内存当中占用 32 bits，也就意味着一个 Point 对象是可以被装载进 64-bit 的缓存器中，甚至在考虑更广泛的情况下，这个对象可以被传给 C 或其他的语言所编写的函数。</p>
<p>可是如若 Point 的析构函数是虚函数，形式就产生了变化。为了实现虚函数带来的动态指向性，所有使用了 virtual 的类必然要携带一份 vptr，用以存放所有 virtual 函数的函数指针，以便于在编译时为编译器指明基类的成员函数被 call 时的实际被调函数。此处 vptr 的结构及其实现细节并不重要，重要的是 Point 携带了 vptr 后必然占有更大的空间，原本可以装载进 64-bit 缓存器的对象此时却可能需要 96 bits，这直接导致了 C++ 中的 Point 对象不再与 C 或其它语言内具有相同声明的结构相匹配了（因为其他语言当中并没有 vptr 的同型受体），也就意味着不能在其他语言直接进行 Point 对象的传递（与被传递），也就扼杀了 Point 本有的移植性。</p>
<blockquote>
<p>当然，如果非要这样做的话，可以在其他语言内手动填充 vptr 那部分细节，可这不是自找麻烦吗？</p>
</blockquote>
<p>由此可见，virtual 析构函数的使用是需要视具体情况而定的。</p>
<ul>
<li>如果正在编写的是带多态性质的 base class，在未来将派生出更多的类并加以控制，那么就需要一个虚析构函数；</li>
<li>如果正在编写的类不欲作为其他类的基类，那么就应具有一个普通的析构函数而不该拥有一个虚析构函数。</li>
</ul>
<p>总结为一句话就是，<strong>只为多态基类声明虚析构函数</strong>，只要遵循这一原则，就可以避免 virtual 带来的这部分麻烦。</p>
<h2 id="谨慎选择派生基类"><a href="#谨慎选择派生基类" class="headerlink" title="谨慎选择派生基类"></a>谨慎选择派生基类</h2><p>在确保只为多态基类声明虚析构函数的前提下，就不会产生任何问题了吗？问题依旧存在！就算为一个非多态类声明普通的析构函数，依旧有资源泄露的可能。<strong>问题就在于开发者是否错误地将一个非多态类作为 base class 并生成派生对象了。</strong>一般而言，这种错误可能会出现在合作开发或引用了外部库的情况下，无意间将带有非虚析构函数的类作为基类了，例如下面这种情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span>	<span class="comment">// 将 std::string 作为基类编写 MyString class</span></span><br><span class="line">&#123;</span><br><span class="line">	MyString();</span><br><span class="line">	~MyString();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，此处 std::string 具有非虚析构函数！那么就存在这样一种情况，如果在开发的过程中无意地将一个 MyString 类型指针转换成为了 string 类型的指针，不幸的是这又是合法的，而之后又将这个 string 指针 delete 了，那么就造成了 MyString 对象的部分销毁，产生了资源泄露。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyString* pMyString = <span class="keyword">new</span> MyString(<span class="string">"Hello World!"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pString;</span><br><span class="line">...</span><br><span class="line">pString = pMyString;	<span class="comment">// 不小心将派生类指针 MyString* 转换成了无虚析构函数的基类指针 std::string*！</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pString;	<span class="comment">// 将基类指针 delete，但 MyString 的析构函数未被调用，造成内存泄露。</span></span><br></pre></td></tr></table></figure>
<p>这主要提醒了一点：在进行派生类的编写时，基类的选择值得留心（有可能是选择库中的类，有可能是同事开发的类，也可能是很久以前自己编写的类），如果对所选择的基类是否具有多态性，是否具有虚析构函数并不明确的话，一定要加以考察和确认，以避免产生不必要的麻烦。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>务必为多态基类声明虚析构函数（避免内存泄露）；</li>
<li>且只为多态基类声明虚析构函数（减少内存占用，保护移植性）；</li>
<li>确保派生类的基类具有多态特性（避免内存泄露）。</li>
</ul>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（五）激活函数的选择 &amp; 浅层神经网络的梯度下降</title>
    <url>/2019/03/24/DeepLearning-05/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇中你将了解几种常见的激活函数，并看到在浅层神经网络中向后传播及梯度下降是如何进行的。</p>
</blockquote>
<p><img src="/2019/03/24/DeepLearning-05/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="5-0-上篇回顾"><a href="#5-0-上篇回顾" class="headerlink" title="5.0 上篇回顾"></a>5.0 上篇回顾</h1><p>在上一篇中，你见到了一个单输出的浅层（双层）神经网络是如何进行向前传播的，就同 Logistic 回归网络一样，不过多重复了几次单层网络的向前传播过程而已。</p>
<p>对于隐藏层而言，所有的隐藏单元与输入层都构成了简单的单层网络结构，所有的隐藏单元均进行一次向前传播（图1-0左），所有隐藏单元完成向前传播后，隐藏层的输出数据就作为输出层的输入数据，继续向前推进，完成输出层的向前传播（图1-0右）。</p>
<p><img src="/2019/03/24/DeepLearning-05/2a.jpg" alt="Title"></p>
<p><center>图 1-0 浅层神经网络的向前传播过程</center><br>如果你了解了 Logistic 回归的向前传播过程，那么浅层神经网络当中的向前传播是很好理解的。</p>
<p>还记得在上篇的末尾留下了一个问题，即激活函数的选择。在之前我们一直使用的是 sigmoid 函数：</p>
<script type="math/tex; mode=display">
\begin{equation}
\sigma(z) = \frac{1}{1+e^{-z}}
\end{equation}</script><p>sigmoid 函数帮助我们将 Logistic 线性回归值进行归一化处理，得到一个位于区间 $[0,1]$ 的概率输出。但在浅层神经网络以至于在深层神经网络当中，尽管 sigmoid 函数可以继续用于输出层，但往往不会作为隐藏层的激活函数，而是使用其它的一些函数，如 tanh、ReLU、Leaky ReLU 等，这是为什么？下面就来了解一下这些新奇的函数，以及为什么要使用这些函数而不是 sigmoid 函数吧。</p>
<h1 id="5-1-激活函数的选择"><a href="#5-1-激活函数的选择" class="headerlink" title="5.1 激活函数的选择"></a>5.1 激活函数的选择</h1><h2 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h2><p>tanh 函数是双曲函数中的一个，更准确的说是双曲正切函数。首先来看一看 tanh 函数，它的函数表达式是这样的：</p>
<script type="math/tex; mode=display">
\begin{equation}
\tanh(z) = \frac{e^{z} - e^{-z}}{e^{z} + e^{-z}}
\end{equation}</script><p>如果你对数学敏感的话，或许可以发现它与 sigmoid 函数的相似之处。如果观察图像的话，可以更加直观地看到，tanh 函数的形态与 sigmoid 函数是非常相似的，事实上 tanh 就是 sigmoid 函数的一个伸缩平移版本，两者是线性相关的。</p>
<p><img src="/2019/03/24/DeepLearning-05/3c.jpg" alt="Title"></p>
<p><center>图 1-1 tanh 函数图像及其梯度图像</center><br>你可能会疑惑，既然 tanh 函数与 sigmoid 函数形态如此相似，为什么不直接使用 sigmoid 函数而是要换用一个看上去更复杂的 tanh 函数？答案很简单，tanh 函数可以很好的规避 sigmoid 函数导致的 zigzag 现象。如果你观察 tanh 函数的值域的话，你会发现它处于区间 $[-1,1]$，并且其中心点在坐标原点处，这意味着 tanh 是 0 均值的，这对神经网络的训练很有帮助。</p>
<p><strong>零均值能避免 zigzag？能提高网络的训练效率？WHY？</strong></p>
<p>如果你对原理不感兴趣，只需要知道上面一行黑体字是结论就行了。不过如果感兴趣，我们来从根本上看一看 sigmoid 函数为什么效率上不如零均值的 tanh 函数吧。</p>
<p>最大的问题在于 sigmoid 函数的输出全部是非负的，这直接导致了下一层网络在反向传播的过程中同层同单元参数 $w$ 的更新梯度总是同向的。想一想这是为什么？又会导致什么后果？</p>
<p>公式(3) 给出了第 $l$ 层第 $i$ 个神经元中所有 $j$ 个参数 $w$ 反向传播的梯度通式：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{\partial J}{\partial w^{[l](j)}_i} = \frac{\partial J}{\partial z^{[l]}_i} \times a^{[l-1]}_i
\end{equation}</script><p>在第 $l-1$ 层采用 sigmoid 函数作为激活函数的情况下，你将发现第 $l$ 层同单元的梯度系数 $a^{[l-1]}_i$ 将是恒正的，这就意味着所有 $\frac{\partial J}{\partial w^{<a href="j">l</a>}_i}$ 的正负均取决于同一个值 $\frac{\partial J}{\partial z^{[l]}_i}$ 的正负。也就是说，同单元的 $w$ 无法通过各自合理的情况去独立地增大或减小，要增大只能一起增大，要减小只能一起减小，很大程度上限制了参数优化的自由度，影响了神经网络的训练效率。</p>
<p>而反观零均值的 tanh 函数输出有正有负，就可以在一定程度上避免这一缺陷，这也是使用 tanh 激活函数代替 sigmoid 函数能够得到更好训练效果的原因。</p>
<h2 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h2><p>ReLU（Rectified Linear Unit），又叫线性整流函数、线性修正单元，是进来神经网络的隐藏层中被普遍选用的激活函数，其表达式如公式(4)所示:</p>
<p>\begin{equation}<br>ReLU(z)=\left{<br>\begin{array}{rcl}<br>z &amp; &amp; {z&gt;0}\<br>0 &amp; &amp; {z&lt;0}<br>\end{array} \right.<br>\end{equation}</p>
<p>当然也有更简洁的表示方式：</p>
<p>\begin{equation}<br>ReLU(z)=max(0,z)<br>\end{equation}</p>
<p><img src="/2019/03/24/DeepLearning-05/4d.jpg" alt="Title"></p>
<p><center>图 1-2 ReLU 函数图像及其梯度图像</center><br>上图1-2严格上来说在横轴的零刻度处应当标注空心点，这也意味着 ReLU 函数在原点处是不可微的，尽管在实际情况下出现完全为零的前驱输入是概率很小的，但为了避免这种未定义在反向传播中造成错误，在实际的使用过程中通常手动为其原点处添加函数值定义及其导数定义。</p>
<p>\begin{equation}<br>ReLU(z)=\left{<br>\begin{array}{rcl}<br>z &amp; &amp; {z&gt;0}\<br>0 &amp; &amp; {z \leq 0}<br>\end{array} \right.<br>\end{equation}</p>
<p>如果你了解 tanh 与 sigmoid 作为隐藏层激活函数的通病的话，那么采用 ReLU 作为激活函数的优点就显而易见了。</p>
<p>虽然 tanh 缓解了 sigmoid 输出恒正造成的锯齿状梯度下降，但其同样具有“饱和区”，即当绝对值较大的数作为输入时，梯度会接近于零，这一点从二者的函数图像上显而易见，当输入 $x$ 趋近与无穷大/小时，图像基本上平了，这会导致梯度更新几乎失活。而 ReLU 函数则不同，在 $x&gt;0$ 的区域，ReLU 的导数具有一个恒定的值，可以保证梯度下降能够在大输入下依旧持续工作。</p>
<p><img src="/2019/03/24/DeepLearning-05/5b.jpg" alt="Title"></p>
<p><center>图 1-3 sigmoid、tanh、ReLU 的梯度函数图像对比</center><br><strong>你可能会疑问：可是 ReLU 函数和 sigmoid 函数一样，也是非零均值的？</strong></p>
<p>的确，使用 tanh 代替 sigmoid 就是为了提高其迭代效率，可是虽然 ReLU 也是非零均值函数，但是 ReLU 不需要求自然指数呀，因此其计算复杂度要远远小于 tanh，就算非零均值，小计算量也可以帮助 ReLU 的梯度快速收敛。总而言之，瑕不掩瑜。 </p>
<p>不过，ReLU 函数有一个问题——在负数区硬饱和。当输入落在小于零的区间时，ReLU 函数将直接输出零，这种现象被称作<strong>Dead ReLU</strong>，但这一特性也被列入 ReLU 的优势：</p>
<blockquote>
<p>仿生物学原理：相关大脑方面的研究表明生物神经元的信息编码通常是比较分散及稀疏的。通常情况下，大脑中在同一时间大概只有1%-4%的神经元处于活跃状态。使用线性修正以及正则化（regularization）可以对机器神经网络中神经元的活跃度（即输出为正值）进行调试；相比之下，逻辑函数在输入为0时达到  ，即已经是半饱和的稳定状态，不够符合实际生物学对模拟神经网络的期望。不过需要指出的是，一般情况下，在一个使用修正线性单元（即线性整流）的神经网络中大概有50%的神经元处于激活态。<br>——百度百科</p>
</blockquote>
<h2 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h2><p>如果你不希望看到 Dead ReLU 的情况，可以使用 Leaky ReLU 来代替 ReLU：</p>
<p>\begin{equation}<br>LeakyReLU(z)=\left{<br>\begin{array}{rcl}<br>z &amp; &amp; {z&gt;0}\<br>\alpha z &amp; &amp; {z&lt;0}<br>\end{array} \right.<br>\end{equation}</p>
<p>Leaky ReLU 与 ReLU 的区别仅仅在于当输入量小于零时，引入了一个极小的梯度 $\alpha$（图1-4中取值为0.05），使得神经元不至于被完全抑制，但是这种做法的优劣不好评定，在一些情况下，Leaky ReLU 可能表现更好，另一些情况下可能 ReLU 更胜一筹，谁知道呢。</p>
<p><img src="/2019/03/24/DeepLearning-05/6a.jpg" alt="Title"></p>
<p><center>图 1-4 Leaky ReLU 函数图像及其梯度图像</center></p>
<h1 id="5-2-浅层网络的向后传播"><a href="#5-2-浅层网络的向后传播" class="headerlink" title="5.2 浅层网络的向后传播"></a>5.2 浅层网络的向后传播</h1><p>聊完了几种常见的激活函数，现在回过神来，看一看浅层神经网络的向后传播吧。还记得在 Logistic 回归当中，向后传播的 $dz$ 直接一步到位用 $a-y$ 来表示了，这是默认将 sigmoid 作为激活函数后用链式法则求导化简后的结果。但现在我们知道了，激活函数的选择是多种多样的，那么在浅层神经网络当中隐藏层激活函数不确定的情况下，就不能够用沿用之前的结果了。</p>
<p>同样也是为了方便后续的深层神经网络叙述，下面将统一使用符号 $g^{[l]}$ 代表第 $l$ 层使用的激活函数，$dg^{[l]}$ 表示第 $l$ 层激活函数关于成本函数的导数。</p>
<h1 id="5-3-浅层网络的梯度下降"><a href="#5-3-浅层网络的梯度下降" class="headerlink" title="5.3 浅层网络的梯度下降"></a>5.3 浅层网络的梯度下降</h1><h1 id="5-4-浅层神经网络小结"><a href="#5-4-浅层神经网络小结" class="headerlink" title="5.4 浅层神经网络小结"></a>5.4 浅层神经网络小结</h1><div class="spoiler collapsed"><div class="spoiler-title">隐藏内容</div><div class="spoiler-content"><p>没有隐藏内容(・∀・(・∀・(・∀・*)</p>
</div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（四）浅层神经网络及其向量化</title>
    <url>/2019/03/23/DeepLearning-04/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇简要介绍浅层神经网络，并给出其向量化形式。</p>
</blockquote>
<p><img src="/2019/03/23/DeepLearning-04/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="4-0-Logistic-回顾"><a href="#4-0-Logistic-回顾" class="headerlink" title="4.0 Logistic 回顾"></a>4.0 Logistic 回顾</h1><p>在前三篇当中，我们见过了 Logistic 回归的相关内容，了解了向前传播、向后传播、梯度下降与向量化等重要概念，并结合一个实际例子在 Jupyter Notebook 环境下搭建了一个 Logistic 回归网络，成功实现了 72% 测试集准确率的猫图识别功能。</p>
<p><img src="/2019/03/23/DeepLearning-04/7.jpg" alt="Title"></p>
<p><center>图 1-0 Logistic 回归</center><br>虽然 Logistic 回归能够较好的学习线性函数，但是由于它太过简单，对于非线性的数据往往不能够很好地适应，而这一点在浅层神经网络当中将有所改善。在这一篇中将介绍浅层神经网络的一些内容，你将看到浅层神经网络是怎样向前传播的，以及如何对其进行向量化处理。</p>
<h1 id="4-1-浅层神经网络"><a href="#4-1-浅层神经网络" class="headerlink" title="4.1 浅层神经网络"></a>4.1 浅层神经网络</h1><p>下图1-1就是一个浅层神经网络的示例。</p>
<p><img src="/2019/03/23/DeepLearning-04/2.jpg" alt="Title"></p>
<p><center>图 1-1 浅层神经网络示例图</center><br>浅层神经网络是一个单隐层的神经网络，也是一个双层神经网络。对于上图的单输出情况而言，如果你遮住输入层不看的话，你会发现隐藏层与输出层所组成的结构与 Logistic 回归网络完全一致（图1-2左），事实上，如果你不遮住输入层，单看一个隐藏单元的话情况是一样的（图1-2右）。</p>
<p><img src="/2019/03/23/DeepLearning-04/3.jpg" alt="Title"></p>
<p><center>图 1-2 浅层神经网络是多个单层神经网络的堆叠</center><br>从这个层面上来讲，可以认为浅层神经网络就是多个 Logistic 回归的堆叠，更准确的说是多个单层神经网的堆叠，区别在于浅层神经网络具有隐藏层与输入层共两层，因此可以有不同的激活函数的选择，而在单层神经网络中，只能够为输出层选择一个激活函数。</p>
<h1 id="4-2-浅层网络的向前传播"><a href="#4-2-浅层网络的向前传播" class="headerlink" title="4.2 浅层网络的向前传播"></a>4.2 浅层网络的向前传播</h1><p>在前面你看到了一个单输出的浅层神经网络是什么样子的，其实就是多个单层网络的堆叠。下面来看一看浅层神经网络是怎样进行向前传播的。</p>
<p>为了方便描述，在浅层神经网络中所有第一层的参数我们都用方括号上标来表示，而该层中的某一个单元则用下标来表示，例如 图1-2右 中隐藏层的第一个单元，它作为一个独立的“单层网络”具有的参数 $w$ 和 $b$，就用符号 $w^{[1]}_1$ 和 $b^{[1]}_1$ 来表示，输出层只有一个单元，其参数就用 $w^{[2]}_1$ 和 $b^{[2]}_1$ 来表示。下面来看一看对于下图 图1-3 所显示的这个隐藏单元都经历了什么。</p>
<p><img src="/2019/03/23/DeepLearning-04/4.jpg" alt="Title"></p>
<p><center>图 1-3 单输出的浅层神经网络</center><br>与 Logistic 回归相同，每一个神经网络单元在向前传播中都分别完成线性计算与激活函数这两步，因此 $x<em>1 … x</em>{nx}$ 作为输入数据进入到了第一个隐藏单元中同样完成了这两步：</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{[1]}_1 = w^{[1]}_1x + b^{[1]}_1
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
a^{[1]}_1 = \sigma(z^{[1]}_1)
\end{equation}</script><p>隐藏层中的第二个隐藏单元也是同理：</p>
<p><img src="/2019/03/23/DeepLearning-04/5.jpg" alt="Title"></p>
<p><center>图 1-4 单输出的浅层神经网络</center><br>对于 $n<em>x$ 个输入 $x_1…x</em>{n_x}$，有</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{[1]}_2 = w^{[1]}_2x + b^{[1]}_2
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
a^{[1]}_2 = \sigma(z^{[1]}_2)
\end{equation}</script><p>第三个单元也是在做同样的计算，这里就不再写出了。</p>
<p>当隐藏层中所有的单元都完成了计算，也就完成了浅层神经网络中第一层的向前传播。现在，你的神经网络的向前传播正处在 图1-5 的情形：</p>
<p><img src="/2019/03/23/DeepLearning-04/6.jpg" alt="Title"></p>
<p><center>图 1-5 完成了第一层的向前传播</center><br>第一层完成了所有单元的激活函数的计算，现在所有的第一层单元作为第二层的输入，进行后续的传播，相信不难想到这一层的传播方程是公式 (5)(6) 所示了：</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{[2]}_1 = w^{[2]}_1a^{[1]} + b^{[2]}_1
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
\hat{y} = a^{[2]}_1 = \sigma(z^{[2]}_1)
\end{equation}</script><p>输出单元的计算结果 $a^{[2]}_1$ 即是整个网络的最终输出了，相信你还记得，这个输出用 $\hat{y}$ 来表示。至此，浅层神经网络就完成了一轮完整的向前传播。</p>
<p>下面，你就可以计算损失函数了：</p>
<script type="math/tex; mode=display">
\begin{equation}
L(\hat{y},y) = -[ ylog(\hat{y}) + (1-y)log(1-\hat{y}) ]
\end{equation}</script><p>在编写代码的过程当中，我们不希望看到显式的 for 循环降低神经网络计算的效率，因此下面来看一看浅层网络的向前传播如何用向量化的方式实现。</p>
<h1 id="4-3-浅层网络的向量化"><a href="#4-3-浅层网络的向量化" class="headerlink" title="4.3 浅层网络的向量化"></a>4.3 浅层网络的向量化</h1><p>对于隐藏层而言，结合公式(1)(2)(3)(4)不难得到其第 $i$ 个单元的计算通式：</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{[1]}_i = w^{[1]}_ix + b^{[1]}_i
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
a^{[1]}_i = \sigma(z^{[1]}_i)
\end{equation}</script><p>去除变量角标并大写即可得到向量化形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
Z^{[1]} = W^{[1]}x + b^{[1]}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
A^{[1]} = \sigma(Z^{[1]})
\end{equation}</script><p>其中大写的 $Z^{[1]}$、$A^{[1]}$、$W^{[1]}$ 是每个单元 $z_i$、$a_i$、$w_i$ 的纵向堆叠，其中 $n_x$ 表示输入个数，$n_1$ 表示隐藏层的单元个数：</p>
<script type="math/tex; mode=display">
\begin{equation}
Z^{[1]} = 
\begin{bmatrix}
z^{[1]}_1\\
z^{[1]}_2\\
{\vdots}\\
z^{[1]}_{n_0}
\end{bmatrix}
_{n_1 \times 1}
,
A^{[1]} = 
\begin{bmatrix}
a^{[1]}_1\\
a^{[1]}_2\\
{\vdots}\\
a^{[1]}_{n_0}
\end{bmatrix}
_{n_1 \times 1}
,
W^{[1]} = 
\begin{bmatrix}
{\cdots}&w^{[1]}_1&{\cdots}\\
{\cdots}&w^{[1]}_2&{\cdots}\\
{\cdots}&w^{[1]}_3&{\cdots}\\
\end{bmatrix}
_{n_1 \times n_x}
\end{equation}</script><p>对于输出层而言也是同理，将隐藏层的输出作为输出层的输入，可得向量化形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
Z^{[2]} = W^{[2]}A^{[1]} + b^{[2]}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
A^{[2]} = \sigma(Z^{[2]})
\end{equation}</script><p>单输出浅层神经网络成本函数的形式与 Logistic 回归中一致：</p>
<script type="math/tex; mode=display">
\begin{equation}
J = -(1/m)(YlogA^{[2]} + (1-Y)log(1-A^{[2]}))
\end{equation}</script><p>如果对向量化过程有任何疑问，可以回看<a href="/2019/03/03/DeepLearning-02/">深度学习（二）向量化 Logistic 回归及其梯度输出</a></p>
<p><strong>本篇小结</strong></p>
<p>至此，你已经完成了浅层神经网络的向前传播及其向量化，但是这个过程还是有值得改进的地方，主要在于公式(8)(10)，在目前为止的这几篇里在处理 $z$ 上一直使用的是 sigmoid 函数作为激活函数，事实上有其他更好的函数可供选择，而将其它这些函数作为隐藏层的激活函数所训练出的网络往往具有更好的效果。</p>
<p>关于激活函数的选择将在下篇中进行探讨，同时在下一篇中你将看到浅层神经网络的向后传播过程，并将对双层神经网络具有一个较为完整的认识。</p>
<div class="spoiler collapsed"><div class="spoiler-title">隐藏内容</div><div class="spoiler-content"><p>没有隐藏内容(・∀・(・∀・(・∀・*)</p>
</div></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Alterful：开启效率次元门！</title>
    <url>/2019/03/21/alterfulPost01/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>很难想象，一款曾经从未受我重视的，以为是可有可无、小众而不起眼的PC端效率工具，在今天竟已悄然融入了我的日常生活，成为了我电脑当中使用频率最高的软件之一，甚至成为了我电脑使用过程中无法割舍的一部分，以至于在我已经切身使用了一年多的时间后，再让我谈起这款软件，依旧难掩喜悦与激动之情。独乐乐不如众乐乐，在这里，我特别将这款效率工具推荐给广大朋友们，希望与你共享键盘增强带来的乐趣。</p>
</blockquote>
<p><img src="/2019/03/21/alterfulPost01/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h3 id="一、小众的烦恼，小众的软件"><a href="#一、小众的烦恼，小众的软件" class="headerlink" title="一、小众的烦恼，小众的软件"></a><strong>一、小众的烦恼，小众的软件</strong></h3><p>嘿，说实话，其实我完全可以直切主题的，我可以直接说 Alterful 这款软件是干嘛干嘛的，怎么样怎么样，但是接下来我并不会这样写。</p>
<p>这是因为如果我直接介绍这个软件有什么功能，应该怎么使用的话，相信我，我有十足的把握认为你会打心眼里觉得这个软件对你而言毫无意义：“这玩意有啥用？”、“shenmegui”…</p>
<p>况且，目前为止大多数人都对效率类软件并不重视，就像我第一次接触这类软件时一样，而直到当我真正用上了 Alterful，才发现键盘增强为我带来的效率提升有多大。所以我希望以循序渐进的方式，让你能够逐渐接受这类工具而不觉得突兀，并开始尝试 Alterful 的使用。</p>
<p><strong>为此，我强烈建议你先看看本文第四节（<a href="/2019/03/21/alterfulPost01/#%E5%9B%9B%E3%80%81Alterful%EF%BC%8C%E4%B8%8D%E6%AD%A2%E8%BF%99%E4%BA%9B">Alterful，不止这些</a>）的内容，在那一节里我放了一些 Alterful 独有的优秀功能的动态演示图，如卡片式截图、常引用搜索等。相信我，在直观了解了它的一些功能之后再回来，你会更有兴趣继续阅读。</strong></p>
<p>不知你发现到了没有，在低头族丛生的今天，作为使用电脑多于使用手机的你，已经逐渐成为了这个时代的“小众”。</p>
<p>而作为这个小众的一员，我相信有不少的PC用户都在过去的时间里有过一些类似的经历：</p>
<ul>
<li><p>想要打开一个软件，却因为没有保留桌面图标，忘记了安装路径而在此电脑中寻找花费了很多时间；</p>
</li>
<li><p>电脑因故障重装了系统，很多桌面图标都不见了，又得不耐烦的一个个找到、发送到桌面快捷方式；</p>
</li>
<li><p>随着学习的需要，安装的软件越来越多，桌面上的图标也越来越多，美美的壁纸被挡得没法看，无奈；</p>
</li>
<li><p>总是想要专注于眼前的工作，却时常在难以避免的桌面与软件的频繁切换中出戏；</p>
</li>
<li><p>遇到外文翻译不方便/站点搜索有点麻烦/找文件太繁琐/想要截图或取色还非得上QQ/…</p>
</li>
</ul>
<p>如果我没有猜错的话，我所提及的这几点，在大多数时候你可能并没有过多的留意和察觉，但是不可否认的是，这些问题总是在我们使用电脑的过程当中时不时地冒出来，或多或少地在默默影响着我们的体验。</p>
<p>如果你曾有过这些困惑，或者现在就正经历着这些坎坷的话，那么恭喜你，继续阅读，我将在下面逐步向你介绍 Alterful 这款软件，它不仅仅是一个效率工具，更是一个非常有趣的解决方案，能够让你摆脱所有类似的不快；</p>
<p>可是如果你从未遇到这些问题，不过在将来的学习工作中很有可能需要比较多地使用电脑的话，那么我也非常希望你能够继续阅读下去，因为下面的内容很有可能帮助你在一开始就绕过这些在未来可能困扰你的问题，让你从一开始就可以以更加优雅愉快地方式，使用你的电脑来工作和学习。</p>
<p><img src="/2019/03/21/alterfulPost01/1x.jpg" alt="Title"></p>
<h3 id="二、你的键盘，真的饱和了吗？"><a href="#二、你的键盘，真的饱和了吗？" class="headerlink" title="二、你的键盘，真的饱和了吗？"></a><strong>二、你的键盘，真的饱和了吗？</strong></h3><p>说到键盘，我们最容易联想到的就是打字和快捷键了。打字作为一种常规的输入操作，也是当下键盘的最基本功能。</p>
<p>而键盘饱和度，指的就是在这一基础功能上，所拓展出的更多键盘功能，将键盘利用率提升的程度。快捷键就是键盘的原生拓展功能。原本繁琐耗时的许多鼠标操作都可以用键盘上的Ctrl、Shift、Alt等功能键与其它键位进行组合，来快速而精准地实现。</p>
<p>例如我们熟知的一些快捷键：</p>
<ul>
<li><p>Win + D = 在桌面与窗口间切换</p>
</li>
<li><p>Win + M = 切换到桌面</p>
</li>
<li><p>Win + E = 打开资源管理器</p>
</li>
<li><p>Alt + Tab = 多任务视图</p>
</li>
<li><p>Alt + Shift = 切换输入语言</p>
</li>
<li><p>Ctrl + C/V = 复制/粘贴</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>还有一些你可能并不熟悉但是却骚气十足的快捷键，例如：</p>
<ul>
<li><p>Shift + 小键盘1 = 光标跳至本行最后</p>
</li>
<li><p>Ctrl + Win + D = 切换到新建桌面 (Win10系统)</p>
</li>
<li><p>Ctrl + Win + ←/→ = 左右切换桌面 (Win10系统)</p>
</li>
<li><p>右键压缩包 + E = 解压文件</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>可以说，你的键盘利用越完全，你的键盘饱和度也就越高，而对应的，你的日常工作效率也要比其他人要高出许多，这一点相信熟练使用键盘快捷键的朋友们都是深有体会的。</p>
<p>同样，在我们身边也能够发现这样的规律。看一个使用电脑快捷键熟练的人操作电脑，远比看一个复制文件都要右键、复制的人操作电脑要舒畅太多，而为我们提供这一便利的，就是系统级的键盘增强——快捷键。</p>
<p>但是既然有了快捷键，我又为何对 Alterful 这一第三方的键盘增强工具情有独钟呢？答案很简单，如果说快捷键以常数级地提升了键盘的利用率的话，那么 Alterful 就是指数级地放大了这一利用率，它向你打开了通往高效操作的新大门——效率次元门。</p>
<p>而无论你是否熟悉与熟练各式各样的快捷键，甚至即使在此之前你连一个快捷键都不知道，你也不必担心自己能否驾驭这一神奇的键盘增强工具，来提升你的工作效率。</p>
<p>因为打开这一效率次元门，你需要的仅仅只有一个快捷键——Alt + A。只要花费少量的时间沉下心继续阅读，你也可以一步到位，让你的键盘达到新的饱和。</p>
<h3 id="三、Alt-A-Everything"><a href="#三、Alt-A-Everything" class="headerlink" title="三、Alt + A = Everything"></a><strong>三、Alt + A = Everything</strong></h3><p>试想，给你一个快捷键，你能实现什么？</p>
<p>切换到桌面？打开一个软件？删除一个文件？还是复制粘贴？不不不，复制粘贴也不行了，因为它需要两个快捷键。</p>
<p>然而在 Alterful 的帮助下，你只需要记忆一个快捷键，就可以实现：</p>
<ul>
<li><p>快而准地打开任意你想要打开的软件、文件、文件夹；</p>
</li>
<li><p>快速定位到任意你想要的软件、文件的根目录；</p>
</li>
<li><p>用电脑上已安装的任意浏览器访问你想访问的网页；</p>
</li>
<li><p>一步到位地自动打开浏览器并自动在你想要的站点搜索显示你想搜索的内容；</p>
</li>
<li><p>一步到位地创建并打开一个临时记事本/任意文件；</p>
</li>
<li><p>打开画图/计算器/任务管理器/注册表/…</p>
</li>
<li><p>不用打开其它软件，快捷取色、卡片式截图；</p>
</li>
<li><p>在电脑任意窗口任意位置，选中英文/日文/法文等各国语言文本，自动显示翻译结果；</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>如果你觉得这一切不可思议的话，不用怀疑，这就是 Alterful 为你带来的全方位的键盘增强。你的键盘将不再只是用来打字了，而是指哪打哪，更好地协助你充分地利用你的电脑，极致地提升你的使用效率，并且在你没有意识的情况下，为你节约了大量的重复劳动时间，为你带来了键盘增强的乐趣。</p>
<p><strong>我该从哪开始？</strong></p>
<p>得益于 Alterful 的指令与可嵌套特性，这一无主界面的微型键盘增强工具的功能丰富而多彩，而面对这么多的功能，新手用户应该从何入手呢？</p>
<p>我想说最好的方法就是翻阅官方文档了，你正在阅读的这篇文章只是引起你对键盘增强工具的注意和兴趣，而官方的使用文档短小精悍，为你提供了详尽的功能说明与循序渐进式的上手引导。</p>
<p>整个文档分为入门篇与进阶篇，想要全面了解 Alterful 的朋友可以在官网找到软件的下载与帮助文档：<a href="https://alterful.com/" target="_blank" rel="noopener">Alterful | 键盘增强</a>。</p>
<p>在这里，我仅简单介绍一下如何使用 Alterful 最基础的功能——快速启动，其它有趣的功能大家可以自己探索与发现。</p>
<hr>
<ul>
<li>Step1. 在安装并至少运行过一次 Alterful 的电脑上，右键任意文件（可以是桌面的快捷方式、文件、文件夹等），选择“添加为 Alterful 启动项”</li>
</ul>
<p><img src="/2019/03/21/alterfulPost01/2.jpg" alt="添加为Alterful启动项"></p>
<ul>
<li>Step2. 在出现的添加启动项窗口中设置启动名，默认是你所右键文件的文件名</li>
</ul>
<p><img src="/2019/03/21/alterfulPost01/3.jpg" alt="设置启动名"></p>
<ul>
<li>Step3. 按下快捷键 Alt + A，键入启动名的前几个字母，Alterful 会为你自动补全，这时按下回车就可以打开对应的软件/文件/文件夹了，开始享受 Alterful 为你带来的键盘增强之快速启动吧！</li>
</ul>
<p><img src="/2019/03/21/alterfulPost01/4.gif" alt="自动补全启动名"></p>
<blockquote>
<p>如果你觉得你的桌面很乱的话，想要清理一下你的桌面，那么你就可以很好地利用一下这一功能，将你的软件和常用的文件夹们设置为 Alterful 启动项吧，之后就可以把你的桌面清空并通过 Alt + A 来快速启动了，不需要退回桌面寻找软件，不仅美观便利，而且充满极客感。</p>
</blockquote>
<hr>
<h3 id="四、Alterful，不止这些"><a href="#四、Alterful，不止这些" class="headerlink" title="四、Alterful，不止这些"></a><strong>四、Alterful，不止这些</strong></h3><p>Alteful 作为键盘增强工具，能为你带来的改变远不止这些。</p>
<p>就以上面例举的简单的快速启动功能为例，它还有诸如多项启动、参数启动、常引用启动等衍生功能，以及双击 Alt 键开启的全局划词翻译，这些功能更为强大，茶余饭后花费一些小时间学习并熟练使用这些功能，Alterful 为你带来的效率次元门才算真正打开，你也将真正享受到键盘增强为你带来的乐趣和快感。</p>
<p><strong>Alterful 经典功能：</strong></p>
<p><strong>1. 所见即所得，右键 + 左键拖拽 = 卡片式截图</strong><br><img src="/2019/03/21/alterfulPost01/7.gif" alt="卡片式截图"></p>
<p><strong>2. 所打即所搜，进阶篇之常引用搜索</strong><br><img src="/2019/03/21/alterfulPost01/8.gif" alt="常引用搜索"></p>
<p><strong>3. 所想即所记，宏指令创建临时文件</strong></p>
<p><img src="/2019/03/21/alterfulPost01/5.gif" alt="宏指令创建临时文本"></p>
<p><strong>4. 所划即所懂，双击 Alt 开/关全局划词翻译</strong></p>
<p><img src="/2019/03/21/alterfulPost01/6.gif" alt="全局划词翻译"></p>
<p><strong>5. ….</strong></p>
<h3 id="五、相关链接"><a href="#五、相关链接" class="headerlink" title="五、相关链接"></a><strong>五、相关链接</strong></h3><ol>
<li><a href="https://alterful.com/" target="_blank" rel="noopener">Alterful - 官方网站</a></li>
<li><a href="https://www.kancloud.cn/sunwish/alterful/468904" target="_blank" rel="noopener">Alterful - 使用文档</a></li>
<li><a href="https://www.kancloud.cn/sunwish/alterful/690564" target="_blank" rel="noopener">Alterful - 使用技巧</a></li>
<li><a href="https://www.kancloud.cn/sunwish/alterful/894211" target="_blank" rel="noopener">Alterful - 更新历史</a></li>
<li><a href="https://jq.qq.com/?_wv=1027&amp;k=5JIkL4A" target="_blank" rel="noopener">Alterful - 用户交流群</a></li>
<li><a href="https://www.kancloud.cn/sunwish/alterful/937091" target="_blank" rel="noopener">实用快捷键精选</a></li>
</ol>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习（三）实战：动手实现猫图识别</title>
    <url>/2019/03/05/DeepLearning-03/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇详细记录了如何使用 Python 语言基于 Logistic 回归搭建一个简单的单层神经网络，并实现猫图的识别。<br>本篇中的单层神经网络在训练集与测试集上分别获得了 95.7% 与 74.0% 的正确率。</p>
</blockquote>
<p><img src="/2019/03/05/DeepLearning-03/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<p>本篇将在 Jupyter Nootbook 中使用 Python 语言进行编程。</p>
<p>简单来说， <strong>Jupyter 是一个交互式笔记本</strong>，可以在一个 Jupyer 笔记本文件中同时记录 Markdown 笔记与添加可分段执行的代码块。</p>
<blockquote>
<p>Jupyter Notebook 是一个基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。（<a href="https://link.jianshu.com/?t=https%3A%2F%2Fjupyter-notebook.readthedocs.io%2Fen%2Fstable%2Fnotebook.html" target="_blank" rel="noopener">摘自官方介绍</a>）</p>
<p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。（<a href="https://baike.baidu.com/item/Jupyter/20423051?fr=aladdin" target="_blank" rel="noopener">摘自百度百科</a>）</p>
</blockquote>
<h1 id="3-0-数据导入"><a href="#3-0-数据导入" class="headerlink" title="3.0 数据导入"></a>3.0 数据导入</h1><p>本篇使用的数据摘自吴恩达深度学习课程，可以在本篇末尾获取下载。在搭建神经网络之前，不如先看一看数据是怎样的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lr_utils <span class="keyword">import</span> load_dataset</span><br><span class="line">train_X_orig, train_Y, test_X_orig, test_Y, classes = load_dataset()</span><br></pre></td></tr></table></figure>
<p>其中 load_dataset 就将数据进行了导入，如果你好奇数据是怎么导入的，可以点开下面的隐藏块查看代码细节，但是目前为止你并不需要关心数据是怎么导入的，以及数据来源是什么，因为这些都不是本篇的重点，你要关注内容的应该是神经网络在编程中到底是如何实现的，当你真正实现了你的神经网络之后，只需要将数据按照你的网络需要进行格式处理并输入就行了。在本篇当中你直接将数据下载下来并使用上面的一行代码导入进行使用即可。</p>
<div class="spoiler collapsed"><div class="spoiler-title">detail of load_dataset</div><div class="spoiler-content"><p><img src="/2019/03/05/DeepLearning-03/2.jpg" alt="Title"></p>
</div></div>
<p>导入数据后的第一件事情，应该关心数据的存储结构，下面几行代码输出了训练集输入（train_set_x_orig）、训练集输出（train_set_y）、测试集输入（test_set_x_orig）及测试集输出（test_set_y）的形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of train_set_x_orig: "</span> + str(train_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of train_set_y: "</span> + str(train_set_y.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of test_set_x_orig: "</span> + str(test_set_x_orig.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of test_set_y: "</span> + str(test_set_y.shape))</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Shape of train_X_orig: (209L, 64L, 64L, 3L)<br>&nbsp;&nbsp;&nbsp;&nbsp;Shape of train_Y: (1L, 209L)<br>&nbsp;&nbsp;&nbsp;&nbsp;Shape of test_X_orig: (50L, 64L, 64L, 3L)<br>&nbsp;&nbsp;&nbsp;&nbsp;Shape of test_Y: (1L, 50L)</p>
</blockquote>
<p>由此不难获得几点信息：</p>
<ul>
<li><p>训练集中有209个训练元素；测试集中有50个测试元素。<br>即 $m<em>{train} = 209$, $m</em>{test} = 50$。</p>
</li>
<li><p>训练集和测试集的图像宽高均为 $64 \times 64$。</p>
</li>
</ul>
<p>而 $3L$ 代表的是 $RGB$ 三通道。如果对图像在计算机当中的存储形式有所了解的话，应该对 $RGB$ 不陌生，电脑屏幕上的所有颜色，都由这红色(R)绿色(G)蓝色(B)三种色光按照不同的比例混合而成。</p>
<p>通过 matplotlib.pyplot 中提供的 imshow 函数可以将一幅 RGB 图像显示出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示训练集中的第 index 个训练图像</span></span><br><span class="line">index = <span class="number">102</span></span><br><span class="line">plt.imshow(train_set_x_orig[index])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y = "</span> + str(train_set_y[:, index]) + <span class="string">", it's a '"</span> + classes[int(train_set_y[:, index])] +  <span class="string">"' picture."</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/05/DeepLearning-03/3.jpg" alt="Title"></p>
<p><center>图 1-1 使用 imshow 函数显示图像</center><br>可以看到，在训练集中的第103个样本图像是一张猫图。其中输出的结果 “y = [1]” 表示这张图片的标注是 “1”，也就表示 “是” 的意思。不妨再看一看第104个样本，可以看到不是猫图，而对应的输出结果也变成了 “y = [0]”。</p>
<p><img src="/2019/03/05/DeepLearning-03/4.jpg" alt="Title"></p>
<p><center>图 1-2 使用 imshow 函数显示图像</center></p>
<h1 id="3-1-数据处理"><a href="#3-1-数据处理" class="headerlink" title="3.1 数据处理"></a>3.1 数据处理</h1><p>在前面已经完成了数据集的导入，并且查看了训练集当中的两个样本图像及对应的图像标注。但是这些数据目前为止还不方便我们使用，下面看一看如何将其调整为合适的格式。</p>
<p>对于单个训练样本而言，所有的输入按照列矩阵的形式传入网络，即输入 $x$ 的是 $n_x \times 1$ 维的矩阵，但是一幅 $64 \times 64$ 图像的在数据集中是以 $64 \times 64 \times 3$ 的矩阵形状进行存储的，为了满足神经网络的输入格式，在 Python 中可以使用 reshape 函数改变矩阵的形状，对于一个形状为 $(a,b,c,d)$ 的矩阵 $M_1$ 而言，通过 $M_1.reshape(M_1.shape[0],-1).T$ 就可以将其转换为形状为 $(b \times c \times d,a)$ 的矩阵了。</p>
<p>其中第一项参数 $M_1.shape[0]$ 表示的就是 $M_1$ 原来的第一维长度 $a$，第二项参数 $-1$ 表示将后面的所有维度堆叠成一个维度，这样就得到了一个形为 $(a,b \times c \times d)$ 的矩阵，再通过”.T”进行转置，就得到了 $a$ 个列矩阵堆叠得到的“向量化矩阵”。</p>
<p>使用这个方法就可以对数据集中的图像数据进行降维处理了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_set_x_flatten = train_set_x_orig.reshape(train_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</span><br><span class="line">test_set_x_flatten = test_set_x_orig.reshape(test_set_x_orig.shape[<span class="number">0</span>],<span class="number">-1</span>).T</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of train_set_x_flatten: "</span> + str(train_set_x_flatten.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Value of test_set_x_flatten: "</span> + str(test_set_x_flatten))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Shape of train_set_x_flatten: (12288L, 209L)<br>&nbsp;&nbsp;&nbsp;&nbsp;Value of test_set_x_flatten: [[158 115 255 …  41  18 133]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[104 110 253 …  47  18 163]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 83 111 254 …  84  16  75]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[173 171 133 … 183 144   5]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[128 176 101 … 141 137  22]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[110 186 121 … 116 108   5]]</p>
</blockquote>
<p>其中按列看，每一列代表一个样本图像的所有 $RGB$ 数值，共有209个训练样本，因此 train_set_x_flatten 有209列。</p>
<p><strong>数字 12288 是 RGB 全部铺平的数值总量</strong><br>因为图片是 $64×64$ 的，因此 $R、G、B$ 各有 $64×64=4096$ 个值，$RGB$ 共三层，$4096×3=12288$。</p>
<p><strong>单个样本的RGB颜色值在 flatten 当中应该是这样存放的：</strong></p>
<script type="math/tex; mode=display">
\begin{equation}
[R_1, R_2, ..., R_{4096}, G_1, G_2, ..., G_{4096}, B_1, B_2, ..., B_{4096}]^T
\end{equation}</script><p><strong>至此，我们完成了数据集的格式化处理，即 图1-3 中左侧RGB图像到右侧输入层的转换。</strong></p>
<p><img src="/2019/03/05/DeepLearning-03/5.jpg" alt="Title"></p>
<p><center>图 1-3 输入数据格式化</center><br><strong>不过，imshow()显示图像时对double型是认为在0~1范围内，因此再将颜色值全部除以255将值转换到0~1。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_set_x = <span class="number">1.0</span>*train_set_x_flatten/<span class="number">255</span></span><br><span class="line">test_set_x = <span class="number">1.0</span>*test_set_x_flatten/<span class="number">255</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Shape of train_set_x: "</span> + str(train_set_x.shape))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Value of test_set_x: "</span> + str(test_set_x))</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Shape of train_set_x: (12288L, 209L)<br>&nbsp;&nbsp;&nbsp;&nbsp;Value of test_set_x: [[0.61960784 0.45098039 1.         … &gt; &nbsp;&nbsp;&nbsp;&nbsp;0.16078431 0.07058824 0.52156863]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.40784314 0.43137255 0.99215686 … 0.18431373 0.07058824 0.63921569]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.3254902  0.43529412 0.99607843 … 0.32941176 0.0627451  0.29411765]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.67843137 0.67058824 0.52156863 … 0.71764706 0.56470588 0.01960784]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.50196078 0.69019608 0.39607843 … 0.55294118 0.5372549  0.08627451]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[0.43137255 0.72941176 0.4745098  … 0.45490196 0.42352941 0.01960784]]</p>
</blockquote>
<p>现在，整个数据集的输入数据都已经处理好了放在矩阵 train_set_x 与 test_set_x 当中，形式如下：</p>
<script type="math/tex; mode=display">
\begin{equation}
train\_set\_x = 
\begin{bmatrix}
R^{(1)}_1&R^{(2)}_1&{\cdots}&R^{(209)}_1\\
R^{(1)}_2&R^{(2)}_2&{\cdots}&R^{(209)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
R^{(1)}_{4096}&R^{(2)}_{4096}&{\cdots}&R^{(209)}_{4096}\\
G^{(1)}_1&G^{(2)}_1&{\cdots}&G^{(209)}_1\\
G^{(1)}_2&G^{(2)}_2&{\cdots}&G^{(209)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
G^{(1)}_{4096}&G^{(2)}_{4096}&{\cdots}&G^{(209)}_{4096}\\
B^{(1)}_1&B^{(2)}_1&{\cdots}&B^{(209)}_1\\
B^{(1)}_2&B^{(2)}_2&{\cdots}&B^{(209)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
B^{(1)}_{4096}&B^{(2)}_{4096}&{\cdots}&x^{(209)}_{4096}\\
\end{bmatrix}
_{12288 \times 209}
，
test\_set\_x = 
\begin{bmatrix}
R^{(1)}_1&R^{(2)}_1&{\cdots}&R^{(50)}_1\\
R^{(1)}_2&R^{(2)}_2&{\cdots}&R^{(50)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
R^{(1)}_{4096}&R^{(2)}_{4096}&{\cdots}&R^{(50)}_{4096}\\
G^{(1)}_1&G^{(2)}_1&{\cdots}&G^{(50)}_1\\
G^{(1)}_2&G^{(2)}_2&{\cdots}&G^{(50)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
G^{(1)}_{4096}&G^{(2)}_{4096}&{\cdots}&G^{(50)}_{4096}\\
B^{(1)}_1&B^{(2)}_1&{\cdots}&B^{(50)}_1\\
B^{(1)}_2&B^{(2)}_2&{\cdots}&B^{(50)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
B^{(1)}_{4096}&B^{(2)}_{4096}&{\cdots}&x^{(50)}_{4096}\\
\end{bmatrix}
_{12288 \times 209}
\end{equation}</script><p>如果你有些忘记了上面这个矩阵的行数、列数及每一个角标的意义的话，请回看上一篇向量化的第一节，里面有详细的解释，不过结合矩阵的角标你应该很好理解了。</p>
<p><strong>至此，训练和测试数据都有了并且都规范好了，正式开始搭建你的神经网络吧！</strong></p>
<h1 id="3-2-搭建神经网络"><a href="#3-2-搭建神经网络" class="headerlink" title="3.2 搭建神经网络"></a>3.2 搭建神经网络</h1><h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><p>在开始写代码之前，你需要先导入一下 numpy：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<p>numpy 是 Python 的一种开源的数值计算扩展，这种工具可用来存储和处理大型矩阵，在上一篇向量化当中所记录的是如何将 Logistic 回归向量化，即将循环代码转换为矩阵计算的形式，而 numpy 就可以帮助你实现矩阵的相关计算。</p>
<p>例如现在将定义一个函数 sigmoid 用于计算所有输入样本 $z$ 值的 $\sigma$ 函数值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sigmoid 函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    a = <span class="number">1.</span>/(<span class="number">1</span>+np.exp(-z))</span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<p>np.exp 是 numpy 提供的求自然指数的函数，对如输入参数为矩阵的时候，会对矩阵中的所有元素求自然指数，如果不使用 numpy 的话，你就要写一个大的 for 循环来遍历所有的数据并计算了，在上一篇中你已经看到了 for 循环的效率是很低的，这就是使用 numpy 的必要性，即向量化计算的落地实现。</p>
<h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><p>下面定义的函数 initialize_parameters 用于初始化参数 $w$ 和 $b$，传入输入的维数，返回一个值为 0 的 $b$ 及对应维数的 $w$。</p>
<blockquote>
<p>np.zeros((a,b))，用于生成一个形状为 $a \times b$ 的零矩阵。 </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize parameters</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">(dim)</span>:</span></span><br><span class="line">    w = np.zeros(shape=(dim, <span class="number">1</span>), dtype=np.float32)</span><br><span class="line">    b = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure>
<h2 id="向前-后传播"><a href="#向前-后传播" class="headerlink" title="向前/后传播"></a>向前/后传播</h2><p>下面定义的函数 propagate 将完成一次向前传播与向后传播。</p>
<p>如果对下面代码理解还有困难的话，其中向前传播的 Cost Function 见 <a href="/2019/03/02/DeepLearning-01/">第一篇</a> 中的1.2节，向后传播中 $dw$ 与 $db$ 见 <a href="/2019/03/02/DeepLearning-01/">第一篇</a> 中公式(24)(25)，对向量化形式的不清楚请回看 <a href="/2019/03/03/DeepLearning-02/">第二篇</a>。</p>
<blockquote>
<p>np.sum(M)，是 numpy 中的求和函数，可以对矩阵按行/列进行堆叠求和，参数 axis = 1 时表示按行求和。<br>np.dot(M1,M2)，是 numpy 中的点乘函数，用于对两个矩阵做点乘运算。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">propagate</span><span class="params">(w, b, X, Y)</span>:</span></span><br><span class="line">    </span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 向前传播</span></span><br><span class="line">    A = sigmoid(np.dot(w.T,X) + b)</span><br><span class="line">    </span><br><span class="line">    cost = (<span class="number">-1.</span>/m) * np.sum((Y*np.log(A) + (<span class="number">1</span>-Y)*np.log(<span class="number">1</span>-A)), axis = <span class="number">1</span>) <span class="comment"># axis = 1 代表按行求和</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 向后传播</span></span><br><span class="line">    dw = (<span class="number">1.</span>/m)*np.dot(X, ((A-Y).T))</span><br><span class="line">    db = (<span class="number">1.</span>/m)*np.sum(A-Y, axis = <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    cost = np.squeeze(cost) <span class="comment"># trans cost from matrix 1x1 into a real number</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dw, db, cost</span><br></pre></td></tr></table></figure>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>下面的函数 optimized 将实现梯度下降，参数 train_times 和 learning_rate 分别用于设定训练次数及学习率。变量 costs 用于记录参数 $w$、$b$ 对应的成本函数值，每训练100次记录一次成本，用于后期绘制 costs 关于训练次数的变化图像，以了解模型的学习情况。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimized</span><span class="params">(w, b, X, Y, train_times, learning_rate)</span>:</span></span><br><span class="line">    </span><br><span class="line">    costs = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(train_times):</span><br><span class="line">        </span><br><span class="line">        dw, db, cost = propagate(w, b, X, Y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 参数迭代</span></span><br><span class="line">        w = w - learning_rate * dw</span><br><span class="line">        b = b - learning_rate * db</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记录成本函数</span></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            costs.append(cost)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> w, b, costs</span><br></pre></td></tr></table></figure>
<h2 id="输入预测"><a href="#输入预测" class="headerlink" title="输入预测"></a>输入预测</h2><p>下面的函数 predict 用于输入预测，其实也就是计算一次向前传播，得到输出结果就是预测值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(w, b, X)</span>:</span></span><br><span class="line">    </span><br><span class="line">    m = X.shape[<span class="number">1</span>]</span><br><span class="line">    Y_prediction = np.zeros((<span class="number">1</span>,m))</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 确保矩阵维数匹配</span></span><br><span class="line">    w = w.reshape(X.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 计算 Logistic 回归</span></span><br><span class="line">    A = sigmoid(np.dot(w.T, X) + b)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 如果结果大于0.5，打上标签"1"，反之记录为"0"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(A.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> A[<span class="number">0</span>, i] &gt; <span class="number">0.5</span>:</span><br><span class="line">            Y_prediction[<span class="number">0</span>, i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Y_prediction[<span class="number">0</span>, i] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment"># 确保一下矩阵维数正确</span></span><br><span class="line">    <span class="keyword">assert</span>(Y_prediction.shape == (<span class="number">1</span>,m))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Y_prediction</span><br></pre></td></tr></table></figure>
<h2 id="模型封装"><a href="#模型封装" class="headerlink" title="模型封装"></a>模型封装</h2><p>在前面我们已经将模型的主体即向前传播向后传播和梯度下降都模块化地完成了，接下来把这些步骤拼接在一起得到最终的模型吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">TestMyModel</span><span class="params">(X_train, Y_train, X_test, Y_test, train_times = <span class="number">100</span>, learning_rate = <span class="number">0.005</span>)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化参数</span></span><br><span class="line">    w, b = initialize_parameters(X_train.shape[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 开始梯度下降训练</span></span><br><span class="line">    w, b, costs = optimized(w, b, X_train, Y_train, train_times, learning_rate)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 训练完成，测试一下效果</span></span><br><span class="line">    Y_prediction_train = predict(w, b, X_train)</span><br><span class="line">    Y_prediction_test = predict(w, b, X_test)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出效果</span></span><br><span class="line">    print(<span class="string">"Accuracy on train_set: "</span> + str(<span class="number">100</span> - np.mean(np.abs(Y_prediction_train-Y_train)) * <span class="number">100</span>) + <span class="string">"%"</span>)</span><br><span class="line">    print(<span class="string">"Accuracy on test_set: "</span> + str(<span class="number">100</span> - np.mean(np.abs(Y_prediction_test-Y_test)) * <span class="number">100</span>) + <span class="string">"%"</span>)</span><br><span class="line">    print(Y_prediction_test)</span><br><span class="line">    <span class="keyword">return</span> w, b, costs, Y_prediction_test</span><br></pre></td></tr></table></figure>
<h1 id="3-3-效果测试"><a href="#3-3-效果测试" class="headerlink" title="3.3 效果测试"></a>3.3 效果测试</h1><h2 id="数据集测试"><a href="#数据集测试" class="headerlink" title="数据集测试"></a>数据集测试</h2><p>至此，你已经完成了一个单层神经网络的构建，让我们来测试一下效果吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w, b, costs, Y_prediction_test = TestMyModel(train_set_x, train_set_y, test_set_x, test_set_y, <span class="number">2000</span>, <span class="number">0.002</span>)</span><br><span class="line">plot_costs = np.squeeze(costs)</span><br><span class="line">plt.plot(plot_costs)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>Accuracy on train_set: 95.69377990430623%<br>Accuracy on test_set: 74.0%<br>[[1. 1. 1. 1. 1. 0. 0. 1. 1. 1. 0. 0. 1. 1. 0. 1. 0. 1. 0. 0. 1. 0. 0. 1. 1. 1. 1. 0. 0. 1. 0. 1. 1. 0. 1. 0. 0. 1. 0. 0. 1. 1. 1. 0. 1. 0. 0. 1. 1. 0.]]</p>
</blockquote>
<p><img src="/2019/03/05/DeepLearning-03/6.jpg" alt="Title"></p>
<p><center>图 1-4 成本函数关于训练次数图像</center><br>可以看到，对于学习率 0.002，训练2000次可以在训练集与测试集上分别得到 95.69% 与 74% 的正确率！这对于一个如此简单的单层神经网络来说已经算是不错了。</p>
<p>看看测试集中预测与图片的对比：</p>
<p><img src="/2019/03/05/DeepLearning-03/7.jpg" alt="Title"></p>
<p><center>图 1-4 测试集中预测与图片的对比</center></p>
<h2 id="试试自己的数据"><a href="#试试自己的数据" class="headerlink" title="试试自己的数据"></a>试试自己的数据</h2><p>下面的函数 isCat 是对模型的进一步封装，用其来预测一张自定义的照片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCat</span><span class="params">(my_image = <span class="string">"my_image.jpg"</span>, dirname = <span class="string">"images/"</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化图片路径</span></span><br><span class="line">    fname = dirname + my_image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取图片</span></span><br><span class="line">    image = np.array(plt.imread(fname))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将图片转换为训练集一样的尺寸</span></span><br><span class="line">    num_px = train_set_x_orig.shape[<span class="number">2</span>]</span><br><span class="line">    my_image = skimage.transform.resize(image, output_shape=(num_px,num_px)).reshape((<span class="number">1</span>, num_px*num_px*<span class="number">3</span>)).T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 预测</span></span><br><span class="line">    my_predicted_image = predict(w, b, my_image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘图与结果输出</span></span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    print(<span class="string">"y = "</span> + str(int(my_predicted_image)) + <span class="string">", our neutral network predicts a \""</span> + classes[int(my_predicted_image),] +  <span class="string">"\" picture."</span>)</span><br></pre></td></tr></table></figure>
<p>接下来我们试试识别自己拍的照片吧！</p>
<p>下面是我自己拍摄的一张白猫的照片，可以看到我们搭建的网络得到了正确的识别结果：</p>
<p><img src="/2019/03/05/DeepLearning-03/8.jpg" alt="Title"></p>
<p><center>图 1-4 识别自己拍摄的照片</center><br><div class="spoiler collapsed"><div class="spoiler-title">附件</div><div class="spoiler-content"><p>链接: <a href="https://pan.baidu.com/s/1-38tRj_SRNNX3v9gs0keEQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1-38tRj_SRNNX3v9gs0keEQ</a> 提取码: uhf3</p>
</div></div></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DeepLearning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（二）向量化 Logistic 回归及其梯度输出</title>
    <url>/2019/03/03/DeepLearning-02/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇属于理论篇，你将了解什么是向量化、向量化对神经网络训练优化的重要性，以及如何向量化 Logistic 回归及其梯度输出。</p>
</blockquote>
<p><img src="/2019/03/03/DeepLearning-02/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="2-0-向量化概述"><a href="#2-0-向量化概述" class="headerlink" title="2.0 向量化概述"></a>2.0 向量化概述</h1><p>在前面，你已经认识了 Logistic 回归，并且对梯度下降以及梯度下降是如何工作的有了一个具体的认知。如果你有认真阅读第一篇的话，相信你还记得在第一篇中曾经提到过一个矩阵 $X$，它表示将所有的输入样本在水平方向上堆叠起来，也就是下面这个样子：</p>
<script type="math/tex; mode=display">
\begin{equation}
X = 
\begin{bmatrix}
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
x^{(1)}&x^{(2)}&{\cdots}&x^{(m)}\\
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
\end{bmatrix}
_{n_x \times m}
\end{equation}</script><p>为了在后面方便说明，这里将每一个输入样本的下标也标示出来，这样你将看到公式(1)更加完整的形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
X = 
\begin{bmatrix}
x^{(1)}_1&x^{(2)}&{\cdots}&x^{(m)}_1\\
x^{(1)}_2&x^{(2)}&{\cdots}&x^{(m)}_2\\
{\vdots}&{\vdots}&{\cdots}&{\vdots}\\
x^{(1)}_{n_x}&x^{(2)}_{n_x}&{\cdots}&x^{(m)}_{n_x}\\
\end{bmatrix}
_{n_x \times m}
\end{equation}</script><p>为了确保你明白公式(2)中每一个角标的含义，在这里特别说明一下，使用小括号括起来的上标表示的是样本的编号，而没有用括号括起来的下标代表的是样本的某一个输入，例如对于符号 $x^{(2)}<em>{n_x}$，它所代表的是训练集中第2个训练样本的第 $n_x$ 个输入，因为 $n_x$ 是指输入的总个数，所以 $x^{(2)}</em>{n_x}$ 表示的就是第2个训练样本的最后一个输入。</p>
<p>将原本独立的一个个样本组合在一起，构成一个新的矩阵，其实这就是向量化。你可能要问，在上篇中已经实现了 Logistic 回归，使用 $x$ 表示单个样本，在对所有样本逐个计算就足够了，为什么还要使用向量化引入一个样本矩阵 $X$？</p>
<h1 id="2-1-非向量化与向量化实例"><a href="#2-1-非向量化与向量化实例" class="headerlink" title="2.1 非向量化与向量化实例"></a>2.1 非向量化与向量化实例</h1><p>试想，如果给你一个给你 1000000 个数据 $a<em>1$~$a</em>{1000000}$，以及 1000000 个数据 $b<em>1$~$b</em>{1000000}$，要你求每一对 $a_i$ 和 $b_i$ 相乘的结果的总和$c$，你会怎么做？</p>
<p>在接触向量化之前，你应该会想到使用 for 循环，将 $a_i$ 与 $b_i$ 的乘积依次相加，就可以得到结果 $c$ 了，我们来试一下。</p>
<h2 id="使用-for-循环"><a href="#使用-for-循环" class="headerlink" title="使用 for 循环"></a>使用 for 循环</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 1000000 随机数据</span></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for 循环版本</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计时</span></span><br><span class="line">startTime = t.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环计算</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">    c += a[i]*b[i]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 停止计时</span></span><br><span class="line">deltaTime = t.time() - startTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果与耗时情况</span></span><br><span class="line">print(<span class="string">"计算结果："</span> + str(c) + <span class="string">", for 循环计算耗时："</span> + str(<span class="number">1000</span> * deltaTime) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure>
<p>以上是使用 for 循环完成要求计算的 python 代码，输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算结果：249879.05298545936, for 循环计算耗时：519.999980927ms</span><br></pre></td></tr></table></figure>
<h2 id="使用向量化"><a href="#使用向量化" class="headerlink" title="使用向量化"></a>使用向量化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向量化版本</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始计时</span></span><br><span class="line">startTime = t.time()</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵计算</span></span><br><span class="line">c = np.dot(a,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止计时</span></span><br><span class="line">deltaTime = t.time() - startTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果与耗时情况</span></span><br><span class="line">print(<span class="string">"计算结果："</span> + str(c) + <span class="string">", 矩阵计算耗时："</span> + str(<span class="number">1000</span> * deltaTime) + <span class="string">"ms"</span>)</span><br></pre></td></tr></table></figure>
<p>以上是使用向量化完成要求计算的 python 代码，输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算结果：249879.05298545936, 矩阵计算耗时：0.999927520752ms</span><br></pre></td></tr></table></figure>
<p>进行多次计算，可以绘制出 for 循环与向量化计算的耗时对比图：</p>
<p><img src="/2019/03/03/DeepLearning-02/2.jpg" alt="Title"></p>
<p><center>图 1-1 for 循环与向量化计算耗时对比</center><br>实在是令人惊喜，正如你所看到的，向量化版本没有使用 for 循环就正确完成了所有计算，并且计算的代码量只有一行，而仅针对简单的乘法与加法运算而言，向量化计算的效率就要比 for 循环高出 500 倍上下，在其他更加复杂的运算下，这个差距还会拉得更大。可以看到，无论从简洁性还是从效率的角度讲，向量化计算几乎是完美的。</p>
<p>因此，不管是在什么算法当中，如果能够不使用 for 循环就尽量不要使用 for 循环，其效率实在是太糟糕了。在神经网络的训练过程中，效率显得尤为重要，面对数量巨大的训练样本，向量化你的模型是非常有必要的，它能够大量地节约你的时间去做更多的训练，或是做参数的调整。</p>
<h1 id="2-2-向量化-Logistic-回归"><a href="#2-2-向量化-Logistic-回归" class="headerlink" title="2.2 向量化 Logistic 回归"></a>2.2 向量化 Logistic 回归</h1><p>在前面你已经见识到了向量化威力，通过向量化你能够实现数据的并发计算，进而为你节约大量的时间。下面，我将用伪代码给出 Logistic 回归非向量化版本，即使用 for 循环编码实现上一篇当中的理论模型，你可以直接阅读代码，并思考如何向量化这个过程。</p>
<h2 id="for-循环版本"><a href="#for-循环版本" class="headerlink" title="for 循环版本"></a>for 循环版本</h2><p>&nbsp;1&nbsp;&nbsp;| $for$ $i$ $=$ $1$ $to$ $m$</p>
<p>&nbsp;2&nbsp;&nbsp;| ${$</p>
<p>&nbsp;3&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$z^{(i)}$ $=$ $w^Tx^{(i)}$ $+$ $b$ # 计算线性输出</p>
<p>&nbsp;4&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$a^{(i)}$ $=$ $\sigma(z^{(i)})$ # 映射到 $[0,1]$</p>
<p>&nbsp;5&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$J$ $+=$ $L(a^{(i)},y^{(i)})$ # 记录 Loss Function 的累加</p>
<p>&nbsp;6&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$dz^{(i)}$ $=$ $a^{(i)}-y^{(i)}$ # 计算 $\frac{\partial L(a,y)}{\partial a} \frac{d\sigma(z)}{dz}$ (前两段”链条”的乘积)</p>
<p>&nbsp;7&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$for$ $j$ $=$ $1$ $to$ $n_x$</p>
<p>&nbsp;8&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$dw_j$ $+=$ $x^{(i)}_jdz$ # 累加 $dw$</p>
<p>&nbsp;9&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$db$ $+=$ $dz$ # 累加 $db$</p>
<p>10&nbsp;| $}$</p>
<p>11&nbsp;| $for$ $j$ $=$ $1$ $to$ $n_x$</p>
<p>12&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$dw_j$ $=$ $dw_j/m$ # 计算每个输入的 $dw$</p>
<p>13&nbsp;| $db$ = $db/m$ # 计算 $db$</p>
<p>14&nbsp;| $J$ = $J/m$ # 计算 $Cost Function$</p>
<hr>
<p>可以看到，在这段代码中出现了三个 for 循环，甚至出现了循环嵌套，这对算法效率的影响是很大的。如果你试着读上面的代码并结合注释，能够理解每一行代码在做些什么的话最好了。如果你觉得以你目前的思维将模型投射到代码还是有些困难也没有关系，我们来逐行解读代码，并一步步地将其向量化。</p>
<p>在这里，向量化的过程其实就是消除 for 循环的过程，我们从最里层的 for 循环开始。你看到了，最里层的 for 循环也就是 7 到 8 行，在 11 到 12 行也有一个小小的 for 循环，我们先从 7 到 8 行的 for 循环开始。</p>
<p>&nbsp;7&nbsp;&nbsp;| $for$ $j$ $=$ $1$ $to$ $n_x$</p>
<p>&nbsp;8&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$dw_j$ $+=$ $x^{(i)}_jdz$ # 累加 $dw$</p>
<p>如果你还是觉得这个通式太抽象地话，我们可以将这个 for 循环一条条详细地列出来：</p>
<script type="math/tex; mode=display">
dw_1 += x^{(i)}_1dz</script><script type="math/tex; mode=display">
dw_2 += x^{(i)}_2dz</script><script type="math/tex; mode=display">
\vdots</script><script type="math/tex; mode=display">
dw_{n_x} += x^{(i)}_{n_x}dz</script><p>仔细看一看，你有没有发现向量化的影子？</p>
<p><img src="/2019/03/03/DeepLearning-02/3.jpg" alt="for 循环展开"></p>
<p><center>图 1-1 for 循环展开</center><br>这简直就是天然的矩阵形式！我们只需将等式左侧的所有 $dw<em>{…}$ 封装进一个列矩阵 $dw$ 即可，等式的右侧也是同理，所有的 $x^{(i)}</em>{…}$ 可以封装进一个列矩阵 $x^{(i)}$，即：</p>
<script type="math/tex; mode=display">
\begin{equation}
dw = 
\begin{bmatrix}
dw_1\\
dw_2\\
{\vdots}\\
dw_{n_x}\\
\end{bmatrix}
_{n_x \times 1}
,
x^{(i)} = 
\begin{bmatrix}
x^{(i)}_1\\
x^{(i)}_2\\
{\vdots}\\
x^{(i)}_{n_x}\\
\end{bmatrix}
_{n_x \times 1}
\end{equation}</script><p>这时你会惊喜地发现，整个循环操作直接被简化成为了一行极其简短的矩阵运算！</p>
<script type="math/tex; mode=display">
\begin{equation}
dw += x^{(i)}dz
\end{equation}</script><p>至此，我们已经迈出了向量化的第一步，成功消除了代码中的一个 for 循环。下面我们继续看一看第二个即代码中 11 到 12 行的 for 循环。使用同样的方法，如果将其展开的话，你会发现这个 for 循环其实在做如下的重复性劳动：</p>
<script type="math/tex; mode=display">
dw_1 = dw_1/m</script><script type="math/tex; mode=display">
dw_2 = dw_2/m</script><script type="math/tex; mode=display">
\vdots</script><script type="math/tex; mode=display">
dw_{n_x} = dw_{n_x}/m</script><p>我相信这一次你已经可以一眼看出如何将其向量化了，你会发现这个过程其实真的很简单，只需要将等式左侧的循环变量封装进一个列矩阵 $dw = [dw<em>1,dw_2,\cdots,dw</em>{n_x}]^T$，这个循环就被简化成为了下面一行代码：</p>
<script type="math/tex; mode=display">
\begin{equation}
dw = dw/m
\end{equation}</script><p>不知道你发现没有，到现在为止，我们已经完成了所有输入的向量化，我们没有使用一个 for 循环就处理了所有输入系数 $w$ 的 $dw$ 计算，<strong>如果你觉得自己对 for 循环向量化的过程已经有所领会的话，建议你到此停下来，自己尝试将第一层也是最大的一层 for 循环也完成向量化，如果你能做到的话，你就实现了不使用一个 for 循环并一口气完成所有样本的训练。</strong></p>
<hr>
<p>下面我们来看最外一层的样本循环，首先第一条是线性组合的计算：</p>
<p>&nbsp;3&nbsp;&nbsp;| $z^{(i)}$ $=$ $w^Tx^{(i)}$ $+$ $b$</p>
<p>先等一下，你可能会像之前一样将循环展开来看一看，之后得到封装的矩阵，最后用矩阵去替换原来的整列。但是其实你会发现你需要做的仅仅是将所有的循环变量替换掉，而不需要每一次都展开来看了。就比如上面这个第 3 行代码，它的循环变量是 $z^{(i)}$ 与 $x^{(i)}$，识别的方法就是它们带有这一层循环的变量 $i$，将其直接替换为 $Z$ 与 $X$，你就得到了最终结果：</p>
<script type="math/tex; mode=display">
\begin{equation}
Z = w^TX + b
\end{equation}</script><p>你只需要在心里记得与明白， $Z$ 和 $X$ 是循环产生的列就好(公式(7))，也就是 图1-1 那样的形式，那是它的由来，但在实际向量化的过程中，你并不需每次都像那样展开一下再去替换，只要你对这个过程明了，那么直接写出结果就行了。</p>
<script type="math/tex; mode=display">
X = 
\begin{bmatrix}
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
x^{(1)}&x^{(2)}&{\cdots}&x^{(m)}\\
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
\end{bmatrix}
_{n_x \times m}
,
\begin{equation}
Z = 
\begin{bmatrix}
z^{(1)}&z^{(2)}&{\cdots}&z^{(m)}\\
\end{bmatrix}
_{1 \times m}
\end{equation}</script><p>同理，第 4、5、6 行的向量形式应该分别是公式(8)(9)(10)所示：</p>
<script type="math/tex; mode=display">
\begin{equation}
A = \sigma(Z)
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
J = -(1/m)(YlogA + (1-Y)log(1-A))
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
dZ = A - Y
\end{equation}</script><p>其中：</p>
<script type="math/tex; mode=display">
\begin{equation}
A = 
\begin{bmatrix}
a^{(1)}&a^{(2)}&{\cdots}&a^{(m)}\\
\end{bmatrix}
_{1 \times m}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
Y = 
\begin{bmatrix}
y^{(1)}&y^{(2)}&{\cdots}&y^{(m)}\\
\end{bmatrix}
_{1 \times m}
\end{equation}</script><p>至此，整个 for 循环版本都被我们向量化了，下面你看到的就是 Logistic 回归及其梯度输出的向量化版本：</p>
<h2 id="向量化版本"><a href="#向量化版本" class="headerlink" title="向量化版本"></a>向量化版本</h2><p>&nbsp;1&nbsp;&nbsp;| $Z$ = $w^TX$ $+$ $b$</p>
<p>&nbsp;2&nbsp;&nbsp;| $A$ = $\sigma(Z)$</p>
<p>&nbsp;3&nbsp;&nbsp;| $J$ = $-(1/m)(YlogA$ $+$ $(1-Y)log(1-A))$</p>
<p>&nbsp;4&nbsp;&nbsp;| $dZ$ = $A$ $-$ $Y$</p>
<p>&nbsp;5&nbsp;&nbsp;| $dw$ = $(1/m)XdZ^T$</p>
<p>&nbsp;6&nbsp;&nbsp;| $db$ = $(1/m)dZ^T$</p>
<p>甚至，由于你在写代码的过程中并不需要将中间量写出来，因此你可以得到下面这个更简的版本：</p>
<p>&nbsp;1&nbsp;&nbsp;| $A$ = $\sigma(w^TX$ $+$ $b)$</p>
<p>&nbsp;2&nbsp;&nbsp;| $J$ = $-(1/m)(YlogA$ $+$ $(1-Y)log(1-A))$</p>
<p>&nbsp;3&nbsp;&nbsp;| $dw$ = $(1/m)X(A$ $-$ $Y)^T$</p>
<p>&nbsp;4&nbsp;&nbsp;| $db$ = $(1/m)(A$ $-$ $Y)^T$</p>
<p>你没看错，只有短短的四行！并且这四行精简的代码是一次性并行完成整个数据集上所有样本的训练！现在你可以想象，假如没有经过向量化操作，直接用嵌套的 for 循环去训练基数庞大的海量数据，不仅代码繁杂，效率上更将是多么可怕的一件事。向量化技术极大的提升了神经网络的训练的效率，也正因如此，向量化才在神经网络与深度学习当中具有重要的意义。</p>
<h1 id="2-3-本篇小结"><a href="#2-3-本篇小结" class="headerlink" title="2.3 本篇小结"></a>2.3 本篇小结</h1><p>经过向量化后的 Logistic 回归，并没有使用一个 for 循环，我们只用四行极简的代码，抽象了上一篇中上万字的复杂过程，我想你也不得不为向量化与矩阵运算的强大而感慨了。</p>
<p>至此，你已经完成了向量化的理论部分学习，在下一篇里，你将在实战中看到向量化 Logistic 回归及其梯度输出的落地实现，即猫图的识别。你将看到单层神经网络的模块化开发与如何一步步编写代码，动手搭建一个自己的神经网络，并使它完整的工作起来。</p>
<p>在进入下一篇之前，你可以试着先思考以下几个问题，这些是本篇当中的核心内容：</p>
<blockquote>
<ol>
<li>在第一篇中已经建立了 Logistic 回归模型，还有必要做向量化工作吗？（<font color="#fff">有必要</font>）</li>
<li>向量化后的 Logistic 回归能够一次性完成所有样本的一次训练，并完成参数的一次迭代，正确或错误？（<font color="#fff">正确</font>）</li>
<li>下面是向量化版本的 Logistic 回归与梯度输出，其中哪几行实现的是向前传播？哪几行实现的是向后传播？（<font color="#fff">向前1、2行；向后3、4行</font>）<br>&nbsp;1&nbsp;&nbsp;| $A$ = $\sigma(w^TX$ $+$ $b)$<br>&nbsp;2&nbsp;&nbsp;| $J$ = $-(1/m)(YlogA$ $+$ $(1-Y)log(1-A))$<br>&nbsp;3&nbsp;&nbsp;| $dw$ = $(1/m)X(A$ $-$ $Y)^T$<br>&nbsp;4&nbsp;&nbsp;| $db$ = $(1/m)(A$ $-$ $Y)^T$</li>
<li>试用向量化技术将下面代码简化成一行，其中 $Fun(a,b) = a + b$，$k_i$ 与 $\mu_i$ 是维度相同的矩阵（<font color="#fff">$var=(1/n)(k+\mu)$</font>）<br>&nbsp;1&nbsp;&nbsp;|$for$ $i$ $=$ $1$ $to$ $n$<br>&nbsp;2&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$var_i$ $+=$ $Fun(k_i,\mu_i)$<br>&nbsp;3&nbsp;&nbsp;|$for$ $i$ $=$ $1$ $to$ $n$<br>&nbsp;4&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$var_i$ $=$ $var_i/n$</li>
</ol>
<p>使用鼠标选中括号内容以查看答案。</p>
</blockquote>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"><p><strong>向量化的意义</strong>：实现循环操作的并行化。</p>
<p><strong>向量化后的 Logistic 回归模型及其梯度输出：</strong></p>
<p>$A = \sigma(w^TX + b)$<br>$J = -\frac{1}{m}(YlogA + (1-Y)log(1-A))$<br>$dw = \frac{1}{m}X(A - Y)^T$<br>$db = \frac{1}{m}(A - Y)^T$</p>
</div></div>
<!--

# 三、实战 - 识别猫图

# 3.0 上篇回顾

# 3.1 数据格式化

# 3.2 模块化

## sigmoid 函数

## 参数的初始化

## 向前与向后传播

## 梯度下降

## 识别函数

# 3.3 模块封装与测试

# 3.4 识别自定图片

# 3.5、本篇小结

--><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（一）Logistic 回归与梯度下降</title>
    <url>/2019/03/02/DeepLearning-01/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇属于理论篇，介绍了针对二元分类问题的 Logistic 回归与梯度下降，以及 Logistic 回归当中的梯度下降是如何进行参数优化的。</p>
</blockquote>
<p><img src="/2019/03/02/DeepLearning-01/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="1-0-Logistic-回归概述"><a href="#1-0-Logistic-回归概述" class="headerlink" title="1.0 Logistic 回归概述"></a>1.0 Logistic 回归概述</h1><p>Logistic 回归是一种广义上的线性回归，也是一个用在监督学习当中的学习算法，一般用于输出值为0或1，即”是”或”不是”的问题当中，这就是二元分类问题。</p>
<p>例如给定一个 $x$，假设这个 $x$ 是一张图片，你想要识别它是不是一张猫的图片，如果是猫的图片就输出1，如果不是就输出0，那么这就是一个典型的二元分类问题，你需要一个算法使得对于输入 $x$，能够得出一个预测值 $\hat{y}$，或者说对于二元分类问题而言，$\hat{y}$ 需要是一个概率值，位于区间 $[0,1]$ 当中，代表分类的倾向。</p>
<p>就拿猫图识别来说，如果输入一张图片得到的输出 $\hat{y}=0.83$ 的话，由于这个概率大于 50%，因此你可以认为它有可能是一张猫图。</p>
<p><img src="/2019/03/02/DeepLearning-01/2.jpg" alt="识别是不是猫图是一个二元分类问题"></p>
<p><center>图1-1 识别是不是猫图是一个二元分类问题</center><br>假设你有一个需要预测的内容，要通过三个输入，$x_1$、$x_2$ 和 $x_3$ 的某种线性组合来预测某个问题，或者说知道某件事情发生的概率 $z$ 的话，那么用 logistic 回归来表达就是</p>
<script type="math/tex; mode=display">
\begin{equation}
z = w_1x_1 + w_2x_2 + w_3x_3 + b
\end{equation}</script><p>但是为了简洁与方便计算，一般单样本的输入与参数都写作列矩阵的形式，第 $i$ 个样本的各项输入用矩阵 $x^{(i)}$ 来表示，各项输入的系数用矩阵 $w$ 来表示。例如对于第 $i$ 个样本 $x$ 而言它有 $n_x$ 个输入，那么它就对应一个 $n_x \times 1$ 的列矩阵 $x^{(i)}$，这样就得到了 Logistic 回归的矩阵形式，也是你常见到的形式：</p>
<script type="math/tex; mode=display">
\begin{equation}
z^{(i)} = w^Tx^{(i)} + b
\end{equation}</script><p>公式(2)表示的是单个样本的计算，在大多数情况下我们会将许多样本按行堆叠在一起，放在一个更大的矩阵当中，并用相应的大写字母来表示这个数据的样本集合，例如对于一个有 $n_x$ 个输入，$m$ 个样本的训练集合来说，一般使用大写字母 $X$ 来表示：</p>
<script type="math/tex; mode=display">
\begin{equation}
X = 
\begin{bmatrix}
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
x^{(1)}&x^{(2)}&{\cdots}&x^{(m)}\\
{\vdots}&{\vdots}&{\vdots}&{\vdots}\\
\end{bmatrix}
_{n_x \times m}
,
w = 
\begin{bmatrix}
w_1\\
w_2\\
{\vdots}\\
w_{n_x}\\
\end{bmatrix}
_{n_x \times 1}
\end{equation}</script><p>如果你学过线性代数的话也许能够理解上面公式的意义，这种表示形式更像是一种技术，使用这种表示形式在深度学习当中是非常重要的，它能够在很大程度上提高我们模型的训练效率。</p>
<p>如果你不理解我所说的话也不用着急，在第二篇当中你将详细地认识这门技术，并且为其精妙而感叹。在本篇当中我们只考虑单个样本的情况，因此你可以选择暂时忽略公式(3)。例如对于这个三个输入问题的单个样本而言，$x$ 与 $w$ 就分别是下面这样的 $3 \times 1$ 矩阵：</p>
<script type="math/tex; mode=display">
\begin{equation}
x = 
\begin{bmatrix}
x_1\\
x_2\\
x_3\\
\end{bmatrix}
, 
w = 
\begin{bmatrix}
w_1\\
w_2\\
w_3\\
\end{bmatrix}
\end{equation}</script><p>用图像可以将这个单样本的 Logistic 回归过程更加直观地表示出来，其中 $\hat{y}$ 就是输出值 $z$。</p>
<p><img src="/2019/03/02/DeepLearning-01/3.jpg" alt="Logistic 回归过程"></p>
<p><center>图1-2 Logistic 回归过程</center></p>
<h1 id="1-1-sigmoid-激活函数"><a href="#1-1-sigmoid-激活函数" class="headerlink" title="1.1 sigmoid 激活函数"></a>1.1 sigmoid 激活函数</h1><p>在前面你已经了解了什么是二元分类问题，知道了 Logistic 回归是一种可以用于处理二元分类问题的学习算法，但是如果真正要做二元分类，你会发现 Logistic 回归的输出值 $z$，是关于输入层 $x$ 的线性组合，所以 $z$ 的数值范围是不确定的。你更希望得到一个介于0和1之间的概率值，而不是一个可能大到非常大，小可以小到很小的不确定的数字。Sigmoid 函数就可以帮助你将输入 $z$ 转换到区间 $[0,1]$ 上，使你可以根据输入 $x$ 得到的输出概率更好进行分类。Sigmoid 函数表达式与其在 $[-10,10]$ 上的图像见 公式(5) 与 图1-3：</p>
<script type="math/tex; mode=display">
\begin{equation}
\sigma(z) = \frac{1}{1+e^{-z}}
\end{equation}</script><p><img src="/2019/03/02/DeepLearning-01/4.jpg" alt="sigmoid 函数图形"></p>
<p><center>图1-3 sigmoid 函数图形</center></p>
<ul>
<li>当 $z$ 越来越小时，$e^{-z}$ 就会越来越大，对应的表达式的分母就会越来越大，使得 $\sigma(z)$ 逐渐趋于0；</li>
<li>当 $z$ 越来越大时，$e^{-z}$ 就会越来越小并趋近于0，对应的表达式的分母就会越来越趋近于1，使得 $\sigma(z)$ 逐渐趋于1。</li>
</ul>
<p>这样，通过 $\sigma(z)$ 函数的转换和帮助，你可以用 Logistic 回归来得到一个概率输出了。一般我们将 Logistic 的计算结果用小写字母 $z$ 来表示，而通过 $\sigma(z)$ 函数映射后得到的最终概率输出，用小写字母 $a$ 来表示。</p>
<p>现在，我们可以得到改造后的 Logistic 二元分类回归过程了（图1-4）</p>
<p><img src="/2019/03/02/DeepLearning-01/5.jpg" alt="二元分类问题的 Logistic 回归"></p>
<p><center>图1-4 二元分类问题的 Logistic 回归</center><br>你可能有注意到，图1-4 当中的 Output 并不是写的 $a$，而是 $\hat{y}$，这是为了将最终输出与隐藏层当中的量区分开来。</p>
<p>如果你不知道什么是隐层的话，图1-4 中间的圆圈（Logistic/Sigmoid），在神经网络当中就被称作<strong>隐层(Hidden layer)</strong>，也被叫做<strong>隐藏层</strong>。</p>
<p>之所以要这么叫它，是因为通常我们只在意输入的数据通过隐层后得到了怎样的输出，而并不在意其中的数值以及在内部所做的计算，在神经网络运行的过程当中我们也无法看到其中的细节，因此将其称作隐层。</p>
<p>你可能不会相信，这就是一个简单的神经网络了，只不过它只有一个隐藏层，看上去非常的简单简洁。这样只有一个隐层的神经网络又被称作<strong>单层神经网络(Single-layer neural network)</strong>（输入层与输出层是不计入神经网络的层数的），在今后我们会看到更加复杂的网络。</p>
<h1 id="1-2-Logistic-回归损失函数"><a href="#1-2-Logistic-回归损失函数" class="headerlink" title="1.2 Logistic 回归损失函数"></a>1.2 Logistic 回归损失函数</h1><h2 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h2><p>在前面你已经认识了 sigmoid 函数，知道了借助于 sigmoid 函数我们可以将 Logistic 回归的计算结果映射到区间 $[0,1]$ 上以表示一个概率。至此，我们已经可以通过 Logistic 回归得到关于输入 $x$ 的一个预测输出 $\hat{y}$ 了。接下来想一想，我们需要怎样来衡量这个预测值 $\hat{y}$ 的准确度？ 我猜你一定想到了一种常用的度量方法，那就是<strong>距离(Distance)</strong>。</p>
<p>在很多情况下，我们使用距离公式来衡量两个量之间的差距，对于 Logistic 回归而言，如果关于 $x$ 的正确输出是 $y$ 的话，那么使用距离来衡量预测差距的公式就是：</p>
<script type="math/tex; mode=display">
\begin{equation}
D(\hat{y},y) = (\hat{y}-y)^2
\end{equation}</script><p>这个公式看上去非常的简洁，但是在神经网络，或者说在深度学习当中，我们不会选用这个函数，而是使用另一个名为<strong>损失函数(Loss function)</strong>的函数来衡量，这个函数的表达式是这样的：</p>
<script type="math/tex; mode=display">
\begin{equation}
L(\hat{y},y) = -[ ylog(\hat{y}) + (1-y)log(1-\hat{y}) ]
\end{equation}</script><p>我们先来看一看这个看上去很复杂的 Loss Function 能否起到衡量输出准确的作用，为了使得输出尽可能准确，我们要做的就是使得损失函数尽可能小：</p>
<p>1.当正确输出 $y=0$ 时，表达式变成了公式(8)，为了使得 $L(\hat{y},y)$ 尽可能小，$log(1-\hat{y})$ 就要尽可能大，也就是 $1-\hat{y}$ 要尽可能大，最终结果是 $\hat{y}$ 要尽可能小，而 $\hat{y} \in [0,1]$，因此 $\hat{y}$ 需要尽可能接近于0，也就是正确输出 $y$。</p>
<script type="math/tex; mode=display">
\begin{equation}
L(\hat{y},y) = -log(1-\hat{y})
\end{equation}</script><p>2.当正确输出 $y=1$ 时，表达式变成了公式(9)，为了使得 $L(\hat{y},y)$ 尽可能小，$log(\hat{y})$ 就要尽可能大，最终结果是 $\hat{y}$ 要尽可能大，而 $\hat{y} \in [0,1]$，因此 $\hat{y}$ 需要尽可能接近于1，也就是正确输出 $y$。</p>
<script type="math/tex; mode=display">
\begin{equation}
L(\hat{y},y) = -log(\hat{y})
\end{equation}</script><p>看来，通过 Loss Function 我们确实可以使得 $\hat{y}$ 与 $y$ 向同一趋势靠近，可是为什么有简单的距离函数不用，却要用这个看上去更复杂的损失函数呢？</p>
<p>这是因为如果使用距离函数 $D(\hat{y},y)$，那么对应的 Cost 函数 $J(w,b)$ 将是非凸的，这会产生许多的局部最小值，导致在梯度下降的过程当中难以找到全局最优解。而损失函数是凸的，这就有利于我们在后面进行梯度下降。如果你看不懂上面这段话也不用担心，因为在后面你将会明白其中的原因。</p>
<p>至此，你已经完成了 Logsitic 回归单层神经网络的一半内容，对于 Logistic 回归来说，我们在1.1节的 图1-4 中已经看过他的计算流程了，这一从输入 $x$ 到完成 $L(\hat{y},y)$ 计算的过程被称作<strong>向前传播(Forward-propagation)</strong>，图1-5 给出的就是这个过程。</p>
<p><img src="/2019/03/02/DeepLearning-01/8.jpg" alt="Logistic 回归的向前传播过程"></p>
<p><center>图1-5 Logistic 回归的向前传播过程</center></p>
<h2 id="Cost-Function"><a href="#Cost-Function" class="headerlink" title="Cost Function"></a>Cost Function</h2><p>在前面你已见过了损失函数 Loss Function，并且知道了通过 Loss Function 可以了解 Logistic 回归的预测输出 $\hat{y}$ 相对于正确输出的偏差程度。现在你将见到 Cost Funtion，这个函数同样也可以叫做损失函数，不过它和 Loss Function 有些不同，一般称其为<strong>成本函数</strong>(Cost Function)，我们来看一看。</p>
<p>相信你已经发现了，Loss Funtion 的输入参数是，$\hat{y}$ 和 $y$，这说明了 Loss Function 是用于衡量单个样本的预测输出与正确输出的差距的。相信你之前了解过，深度学习需要巨大的数据集进行神经网络的训练，可是，单个样本的损失函数不能代表整体，一个样本预测的准确，不能代表在整个数据集上表现良好。</p>
<p>因此 Cost Funtion 就是用来衡量参数 $w$ 和 $b$ 对所有样本的适应情况的，这样你应该能够很好的理解，Cost Funtion 就是的对所有样本 Loss Funtion 的均值：</p>
<script type="math/tex; mode=display">
\begin{equation}
J(w,b) = \frac{1}{m}\sum_{i=1}^m L(\hat{y},y) = -\frac{1}{m}\sum_{i=1}^m [ ylog(\hat{y}) + (1-y)log(1-\hat{y}) ]
\end{equation}</script><p>正如你看到的，Cost Funtion 一般用 $J(w,b)$ 来表示，这应该不难理解，Cost Funtion 就是用来衡量 $w$、$b$ 两个参数的全局表现的。</p>
<p><img src="/2019/03/02/DeepLearning-01/6.jpg" alt="当w、b是实数时，J(w,b)函数的图形"></p>
<p><center>图1-6 当 $w$、$b$ 是实数时，$J(w,b)$ 函数的图像</center></p>
<h1 id="1-3-梯度下降法"><a href="#1-3-梯度下降法" class="headerlink" title="1.3 梯度下降法"></a>1.3 梯度下降法</h1><p>在前面你已经完成了 Logistic 回归的向前传播，认识了损失函数 Loss Function 和 Cost Funtion，它们中的前一个是衡量我们的神经网络模型对单个样本的预测情况，后一个是前一个在数据集上的均值，衡量我们的神经网络模型在整个数据集上的表现。下面，我们可以开始看看怎样调节参数 $w$ 和 $b$，来优化我们的神经网络了。</p>
<p>为了使得模型的效果更好，我们需要着眼的是怎样调节 $w$ 和 $b$，使得 Cost Function $J(w,b)$ 尽可能小。</p>
<p>在 图1-6 中你看到了当 $w$ 和 $b$ 是实数情况下的 $J(w,b)$ 函数图像，为了方便起见，我们暂时忽略 $b$，只看 $w$ 对 $J(w)$ 的影响，你将在 图1-7 看到它的形态。</p>
<p><img src="/2019/03/02/DeepLearning-01/7.jpg" alt="当w是实数时，J(w)函数的图形"></p>
<p><center>图1-7 当 $w$ 是实数时，$J(w)$ 函数的图像</center><br>可以看到函数 $J(w)$ 是一个凸函数，如果你绘制出 $J(b)$ 图像你将发现它也是凸函数，这也就回答了在1.2节当中的问题，即我们选用 Loss Function 而不是形式更简单的距离函数的原因，距离函数就不是这样的凸函数，它有许多的局部最小值，这不便于我们寻找全局的最优解。</p>
<p>现在假设我们的 $w$ 取在了最低点的右侧，那么你会发现它的斜率是大于零的，也就是公式(11)</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{dJ(w)}{dw}>0
\end{equation}</script><p>那么为了减小 $w$，你应该用将 $w$ 减去一个常数去乘以这个导数：</p>
<script type="math/tex; mode=display">
\begin{equation}
w_{new} = w_{old} - \alpha \frac{dJ(w)}{dw}
\end{equation}</script><p>这个常数被称作<strong>学习率(Learning rate)</strong>，一般记作 $\alpha$，用来控制每次更新的步幅。而如果我们的 $w$ 偏小了，即取在了最低点的左侧，你会发现它的斜率是小于零的，那么用公式(12)来更新 $w$ 就会使得 $w$ 变大，因此无论 $w$ 偏小还是偏大，我们都可以只使用公式(12)就能够不断地优化 $w$，使得 $J(w)$ 越来越小。是不是感觉很神奇?这是使用 $- \alpha \frac{dJ(w)}{dw}$ 作为更新量的一个好处。</p>
<p>另一个好处是，在学习率 $\alpha$ 大小合适的前提下，当初始的 $w$ 差的太远时，因为远处的斜率非常的大，在更新量的促使下 $w$ 会很快被更新到最优点的附近。但这个好处同样也是坏处，当 $w$ 距离最优点很近的时候，$\frac{dJ(w)}{dw}$会趋于零，$w$ 的更新会变得非常慢。</p>
<p>对于参数 $w$，我们使用公式(12)进行更新，对于参数 $b$ 我不想在这里多写，因为两者是同理的，你不难理解参数 $b$ 的更新公式应该是公式(13)所写的样子，和公式(12)相比就是将所有的 $w$ 换成了 $b$，其它保持不变。</p>
<script type="math/tex; mode=display">
\begin{equation}
b_{new} = b_{old} - \alpha \frac{dJ(b)}{db}
\end{equation}</script><p>值得注意的是，对于梯度下降法而言，学习率 $\alpha$ 的选择是至关重要的，一个过小的 $\alpha$ 会使得 $w$、$b$ 更新的过慢，而太大的 $\alpha$ 将导致梯度下降难以收敛。在许多情况下，学习率通常初始设置在 $10^{-2}$~$10^{-4}$ 数量级之间，通过实际的训练情况再进行细微调整，在后面你将看到学习率 $\alpha$ 对整个模型精确度的影响之深。</p>
<h1 id="1-4-Logistic-回归中的梯度下降法"><a href="#1-4-Logistic-回归中的梯度下降法" class="headerlink" title="1.4 Logistic 回归中的梯度下降法"></a>1.4 Logistic 回归中的梯度下降法</h1><p>在前面你已经了解了梯度下降法，知道了梯度下降法进行参数优化的原理，即利用损失函数 $J(w,b)$ 是凸函数的特性，通过梯度(斜率)特征调节参数 $w$ 和 $b$，并结合学习率 $\alpha$ 控制更新步幅，以引导 $J(w,b)$ 走向全局最低点 。下面我们来看看在 Logistic 回归当中的梯度下降法到底是怎样工作的。</p>
<p>梯度下降法更新参数的核心你一定还记得，我们把它摘抄过来并稍作修改：</p>
<script type="math/tex; mode=display">
\begin{equation}
w := w - \alpha \frac{\partial J(w, b)}{\partial w}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
b := b - \alpha \frac{\partial J(w, b)}{\partial b}
\end{equation}</script><p>如果你将上面两个公式与1.3节中给出的更新公式做对比的话，你会发现有两点修改。首先此处使用了 “:=” 符号，如果你之前没有见过这个符号的话也不用担心，它只是表示数据更新，这样就不需要像公式(12)与公式(13)那样总是带着 $<em>{new}$ 和 $</em>{old}$ 的角标了。</p>
<p>第二点就是导数符号都修正成了偏导数，因为1.3节当中为了方便讨论所以只考虑了一个量而有意地忽略了另一个量，但实际情况是 $J(w, b)$ 是一个二元函数，对其一个参量求导应该写成偏导的形式。这是对公式(12)和公式(13)的两点修改，希望你能理解。</p>
<p>为了更新参数，我们需要的只是 $\frac{\partial J(w, b)}{\partial w}$ 和 $\frac{\partial J(w, b)}{\partial b}$，学习率 $\alpha$ 是我们自己设置的，而 $J(w, b)$ 正是 $L(\hat{y},y)$ 的均值，如果你熟悉链式法则的话，你不难发现实际上我们只需要计算 $\frac{\partial L(\hat{y}, y)}{\partial w}$ 与 $\frac{\partial L(\hat{y}, y)}{\partial b}$ 即可，而本小节的核心正是求解这两个量。</p>
<p>如果你精通微积分，相信你可以很快写出这两偏导数的答案，但是为了便于理解，我们还是在此采用链式法则将求解步骤进行拆分，这也便于引出本小节中的一个重要概念。如果你学过微积分，那么下面的推导过程你应该不难理解，要是你看不懂下面的一堆算式，一头雾水也不用太担心，记住最终的结论也是可以的，这些推导的过程对你在编程实践环节不会造成什么困扰。</p>
<blockquote>
<p>为了确保你对链式法则不会太陌生，这里简单地举一个例子：<br>如果有一串函数，$a = F_1(x), b = F_2(a), c = F_3(b)$，此时你想要求 $x$ 关于 $F_3(b)$ 的导数 $\frac{dF_3(b)}{dx}$，那么你需要遵循链式法则：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{dF_3(b)}{dx} = \frac{dF_3(b)}{db} \frac{dF_2(a)}{da} \frac{dF_1(a)}{dx}
\end{equation}</script><p>如果你不太理解的话，尝试把公式(16)分母中 $b$、$a$ 的值用对应的函数带入：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{dF_3(b)}{dx} = \frac{dF_3(b)}{dF_2(a)} \frac{dF_2(a)}{dF_1(x)} \frac{dF_1(a)}{dx}
\end{equation}</script><p>你会发现中间的微分项全部都约掉了，最后得到 $\frac{dF_3(b)}{dx} = \frac{dF_3(b)}{dx}$ 的恒等式，这也说明链式法则是有效的。</p>
</blockquote>
<p>首先我们计算一下 $a$ 对于损失函数 $L(a,y)$ 的偏导数 $\frac{\partial L(a,y)}{\partial a}$：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{\partial L(a,y)}{da} = -\frac{\partial}{da}[yloga + (1-y)log(1-a)]\\
= -\frac{y}{a}+\frac{1-y}{1-a}
\end{equation}</script><p>我们完成了第一步计算，将这个计算在图中标注出来。在下图（图1-8）当中这个计算的结果使用符号 $dL/da$ 来表示，向后的弧形箭头表示从当前单元向后计算输入单元的(偏)导数。</p>
<p><img src="/2019/03/02/DeepLearning-01/9.jpg" alt="计算图"></p>
<p><center>图1-8 向后计算 $\frac{\partial L(a,y)}{da}$</center><br>下面类似计算 $\frac{d\sigma(z)}{dz}$ 即 $\frac{da}{dz}$，和 $\frac{\partial z(w,b)}{\partial w}$、$\frac{\partial z(w,b)}{\partial b}$</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{d\sigma(z)}{dz} = -\frac{d}{da}(\frac{1}{1+e^{-a}})
= a(1-a)
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
\frac{\partial z(w,b)}{\partial w} = -\frac{\partial}{\partial w}(w^Tx+b)
= x
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
\frac{\partial z(w,b)}{\partial b} = -\frac{\partial}{\partial b}(w^Tx+b)
= 1
\end{equation}</script><p>最后通过链式法则计算 $\frac{\partial L(\hat{y}, y)}{\partial w}$ 与 $\frac{\partial L(\hat{y}, y)}{\partial b}$：</p>
<script type="math/tex; mode=display">
\begin{equation}
\frac{\partial L(\hat{y}, y)}{\partial w} = \frac{\partial L(a,y)}{\partial a} \frac{d\sigma(z)}{dz} \frac{\partial z(w,b)}{\partial w}
= x(a-y)^T
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
\frac{\partial L(\hat{y}, y)}{\partial b} = \frac{\partial L(a,y)}{\partial a} \frac{d\sigma(z)}{dz} \frac{\partial z(w,b)}{\partial b}
= (a-y)^T
\end{equation}</script><p>这样就可以得到我们的目标 $\frac{\partial J(w, b)}{\partial w}$ 和 $\frac{\partial J(w, b)}{\partial b}$ 了，它们就是公式(22)和公式(23)在数据集上的均值，一般使用 $m$ 表示训练集的大小，就有下式：</p>
<script type="math/tex; mode=display">
\begin{equation}
dw = \frac{\partial J(w, b)}{\partial w}
= \frac{1}{m} \sum_{i=1}^{m}\frac{\partial L(\hat{y}^{(i)}, y^{(i)})}{\partial w}
= \frac{1}{m} \sum_{i=1}^{m}[x^{(i)}(a^{(i)}-y^{(i)})^T]
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
db = \frac{\partial J(w, b)}{\partial b}
= \frac{1}{m} \sum_{i=1}^{m}\frac{\partial L(\hat{y}^{(i)}, y^{(i)})}{\partial b}
= \frac{1}{m} \sum_{i=1}^{m}(a^{(i)}-y^{(i)})^T
\end{equation}</script><p>在写代码的时候，为了简化变量名，通常使用 $dw$ 与 $db$ 来代表 $\frac{\partial J(w, b)}{\partial w}$ 和 $\frac{\partial J(w, b)}{\partial b}$。</p>
<p>如果你学过高等数学的话，我十分建议你动笔自己来算一算，这个计算的过程很有趣，看似复杂的表达式，最终却能够得到如此简洁的结果，实则美妙。</p>
<p>到目前为止，我们已将完成了每一个“链条”的求解，如果在图像上标示出来，这个过程就是 图1-9 的上半部分，而 图1-9 的下半部分就是通过链式法则将各“链条”相乘得到最终的计算结果，整个 图1-9 的过程被称作<strong>向后传播(Back-propagation)</strong>，又叫反向传播。</p>
<p><img src="/2019/03/02/DeepLearning-01/10.jpg" alt="Logistic 回归的向后传播过程"></p>
<p><center>图1-9 Logistic 回归的向后传播过程</center><br>梯度下降的核心在于参量的更新，也就是更新量的求解。现在，我们已经计算得到了答案（公式(24)和公式(25)），Logistic 回归中的梯度下降法最终被归纳为下面两行：</p>
<script type="math/tex; mode=display">
\begin{equation}
w := w - \alpha dw
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
b := b - \alpha db
\end{equation}</script><p>重申一次，如果你对上面的推导过程感到很头疼的话，不用过于担心，记住最后的结论也是没有问题的。</p>
<h1 id="1-5-本篇小结"><a href="#1-5-本篇小结" class="headerlink" title="1.5 本篇小结"></a>1.5 本篇小结</h1><p>很棒，你的单层神经网络已经完成了一轮训练！即一次完整的向前传播（图1-5）、向后传播（图1-9）与参数更新（公式(26)(27)）。在实际的神经网络训练过程当中就是通过重复这个过程来不断地迭代参数 $w$ 和 $b$ 使得全局损失函数 $J(w, b)$ 尽可能小，达到“学习”优化的目的。</p>
<p>至此，你已经完成了 Logistic 回归的理论部分学习，在下一篇中你将了解到向量化的相关内容，你将发现在神经网络当中向量化的重要性，以及如何向量化 Logistic 回归、如何向量化 Logistic 回归的梯度输出。<br>在进入下一篇之前，你可以试着先思考以下几个问题，这些是本篇当中的核心内容：</p>
<blockquote>
<ol>
<li>二元分类问题中的 Logistic 回归是怎样的流程？（<font color="#fff">图1-9</font>）</li>
<li>为什么要引入 Sigmoid 激活函数？（<font color="#fff">将 $z=w^Tx+b$ 映射为区间 $[0,1]$ 上的一个概率</font>）</li>
<li>Logistic 回归中使用什么作为损失函数？（<font color="#fff">Loss Function / Cost Function</font>）</li>
<li>梯度下降法的“下降”核心可以分为哪两部份？（<font color="#fff">学习率 $\alpha$ 与 梯度(斜率)</font>）</li>
<li>Logistic 回归中参数 $w$ 与 $b$ 的迭代公式是？（<font color="#fff">公式(14)(15) 或 公式(26)(27)</font>）</li>
</ol>
<p>使用鼠标选中括号内容以查看答案。</p>
</blockquote>
<div class="spoiler collapsed"><div class="spoiler-title">点击查看本篇总结</div><div class="spoiler-content"><p><strong>Logistic 回归</strong>：Logistic 回归是一种广义上的线性回归，常用于处理二元分类问题。</p>
<p><strong>Sigmoid 函数</strong>：Sigmoid 函数将 $z=w^Tx+b$ 映射到区间 $[0,1]$ 上，便于将其视为概率来进行分类。</p>
<p><strong>损失函数</strong>：Loss Function 代表单样本损失，Cost Function 代表整体损失均值，用于衡量预测精确度。</p>
<p><strong>梯度下降法</strong>：利用损失函数是凸函数的特性，通过梯度(斜率)特征来更新参数 $w$ 和 $b$，并结合学习率 $\alpha$ 控制更新步幅，以引导损失函数 $J(w,b)$ 走向全局最低点。</p>
<p><strong>Logistic 回归中对于单样本的参数更新公式</strong>：</p>
<script type="math/tex; mode=display">
w := w - \alpha x(a-y)^T</script><script type="math/tex; mode=display">
b := b - \alpha (a-y)^T</script><p><strong>对于单样本在向前传播中计算了</strong>：预测值 $a = \sigma(z)$ 与 损失函数 $L(a,y)$。</p>
<p><strong>对于单样本在反向传播中计算了</strong>：参数 $w$ 和 $b$ 的更新梯度 $x(a-y)^T$ 与 $(a-y)^T$。</p>
</div></div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 Windows 系统焦点光标的监控尝试</title>
    <url>/2019/02/25/WindowsInputCursor/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>研究这个主要是为了进一步完善当前的自用软件 Alterful 的激活流程，实现“无热键”键盘增强。<br>虽然最终没能得到接近完美的解决办法，不过也在这个尝试的过程中取得了一些进展，故简单地记录一下。</p>
</blockquote>
<p><img src="/2019/02/25/WindowsInputCursor/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<p>其实所研究这个问题的本质就是希望能够实时监测系统当中是否有输入焦点，也就是在文本框中输入内容时一闪一闪的光标，更准确地说应该是叫输入焦点，或者说“插入符”。</p>
<p>归纳了一下，主要有两种办法可以基本实现这一点。</p>
<h1 id="一、GetGUIThreadInfo"><a href="#一、GetGUIThreadInfo" class="headerlink" title="一、GetGUIThreadInfo"></a>一、GetGUIThreadInfo</h1><p>作为处于待输入状态的控件，其父窗口一般来讲是当前时刻的顶级窗口，因此考虑通过函数 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getguithreadinfo" target="_blank" rel="noopener">GetGUIThreadInfo</a> 来获得顶层窗口的相关信息，进而判断顶层窗口是否含有输入焦点来确定系统全局是否含有输入焦点。</p>
<p>下面是 C++ 中 GetGUIThreadInfo 的函数原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL GetGUIThreadInfo(</span><br><span class="line">  DWORD          idThread,</span><br><span class="line">  PGUITHREADINFO pgui</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="参数一"><a href="#参数一" class="headerlink" title="参数一"></a>参数一</h2><p>其中参数 idThread 是欲取得信息的GUI线程id，如果是要获取一个指定窗口的Info的话，那么可以通过 GetWindowThreadProcessId 来得到其 idThread 值，其函数原型如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DWORD GetWindowThreadProcessId(</span><br><span class="line">HWND hWnd,</span><br><span class="line">LPDWORD lpdwProcessId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>不过我们只是要取的顶级窗口的信息，幸运的是 idThread 接受 NULL，并且当传入 NULL 时将默认认为目标窗口就是顶级窗口，因此此处直接传NULL即可，还是很方便的。</p>
<h2 id="参数二"><a href="#参数二" class="headerlink" title="参数二"></a>参数二</h2><p>第二个参数 pgui 是一个 <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagguithreadinfo" target="_blank" rel="noopener">PGUITHREADINFO</a> 类型的结构体指针，在微软官方文档当中给出的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagGUITHREADINFO &#123;</span><br><span class="line">  DWORD cbSize;</span><br><span class="line">  DWORD flags;</span><br><span class="line">  HWND  hwndActive;</span><br><span class="line">  HWND  hwndFocus;</span><br><span class="line">  HWND  hwndCapture;</span><br><span class="line">  HWND  hwndMenuOwner;</span><br><span class="line">  HWND  hwndMoveSize;</span><br><span class="line">  HWND  hwndCaret;</span><br><span class="line">  RECT  rcCaret;</span><br><span class="line">&#125; GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;</span><br></pre></td></tr></table></figure>
<p>其中对此处比较有用的就是 flags、hwndFocus 以及 hwndCaret 这三个数据成员，其中 hwndFocus 表示具有键盘焦点的窗口的句柄，hwndCaret 表示显示插入符的窗口的句柄，而 flags 表征的是线程的状态。flag 一共有 5 个可取值，具体见下图：</p>
<p><img src="/2019/02/25/WindowsInputCursor/2.jpg" alt="Title"></p>
<p>当 flags == 1 时，说明当前窗口中有闪烁的插入符，也就说明当前系统具有输入焦点，处于可输入状态。</p>
<p>相应的，此时就可以通过 hwndCaret 来知道具体的焦点控件句柄。（不过针对此处需要，这些信息都不用管，不过对大多数其它情况和需求而言，这些数据都是有意义的，所以还是提一下）</p>
<h1 id="二、GetCaretPos"><a href="#二、GetCaretPos" class="headerlink" title="二、GetCaretPos"></a>二、GetCaretPos</h1><p>GetCaretPos 函数其实是用来获取当前的光标位置的，不过从其函数原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL GetCaretPos(</span><br><span class="line">  LPPOINT lpPoint</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以看到返回值是布尔型，因此也可以用来判断是否存在输入光标。</p>
<p>很明显 GetCaretPos 函数相比 GetGUIThreadInfo 而言要简洁得多，这也是由函数的使命所决定的。</p>
<blockquote>
<p>从 GetCaretPos 你只能得到 “是否有光标？” 以及 “光标坐标是什么？” 这两个问题的答案，而 GetGUIThreadInfo 可以得到的信息要丰富得多。</p>
</blockquote>
<p>函数 GetCaretPos 不需要任何有意义的输入参数，只需要一个 LPPOINT 指针用于接受光标的客户坐标。</p>
<p>如果当前屏幕有光标，那么函数返回 true，如果屏幕没有光标，那么函数返回 flase，并且可以通过 <a href="https://msdn.microsoft.com/zh-cn/d852e148-985c-416f-a5a7-27b6914b45d4" target="_blank" rel="noopener">GetLastError</a> 来取得错误信息。</p>
<h1 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h1><p>测试效果在概述当中已经说了，不尽理想。在目前已经试过的所有原生窗口（如记事本、资源管理器等）当中可以正常得到光标信息，</p>
<p>但是在大部分基于ATL或WTL开发的DirectUI窗口（如QQ、WPS、迅雷）和几乎所有的浏览器当中，GetCaretPos 始终返回 true，lpdwProcessId 的 flags 始终为 0，也就是说都无法得到光标信息。</p>
<p>在网上找了一天也没能找到这个问题的原因，虽然有一些相关的提问，但是都没有结帖，并且都是10年前左右的问题，年代久远，也就是目前为止都没有找到有效的解决办法。这一问题只能暂时告一段落了，如果以后有闲情继续研究，会尝试钻研一些开源输入法光标跟踪原理，若取得进展，再回到本篇继续更新。</p>
<p>下面是对有效情况的测试图：</p>
<p><img src="/2019/02/25/WindowsInputCursor/3.gif" alt="Title"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>QT（四）：事件与事件过滤器</title>
    <url>/2019/02/22/LearningNotes-QT-04/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇介绍 QT 中的事件与事件过滤器，并制作一个简单经典的恶搞小程序。<br>环境：Win10 + QT Creator4.4.1 + QT5.9.2。<br>实现内容：一个看得到点不到的按钮。</p>
</blockquote>
<p><img src="/2019/02/22/LearningNotes-QT-04/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、QT-中的事件与事件过滤器"><a href="#一、QT-中的事件与事件过滤器" class="headerlink" title="一、QT 中的事件与事件过滤器"></a>一、QT 中的事件与事件过滤器</h1><p>事件是个好东西，有了事件，我们就可以在特定的情形做特定的事情，而不用关心这个情形什么时候发生。</p>
<p>在 <a href="/2019/02/18/LearningNotes-QT-01/">QT（一）：信号与槽</a> 当中曾经写过这样一段话：</p>
<blockquote>
<p>信号与槽是 QtGui 开发当中事件的表示形式，信号即是事件的触发条件，槽即是信号所触发的事件处理函数。</p>
</blockquote>
<p>当时为了方便快速建立熟悉感而做的类比，放现在看来，其实是有大问题的。</p>
<p>信号/槽并算不上是 Qt 中事件的表示形式，顶多可以说是事件的一种特殊实例，其特殊在于信号/槽系统属于程序主动可控可发起的事件。除其之外，还有诸如鼠标、键盘等诸多设备消息，都会相对被动的触发各种事件。</p>
<p>例如鼠标左键按下、鼠标左键放开、键盘按键按下乃至鼠标的移动等等，都会产生相应的事件。那么这些事件是如何在 QT 当中传播？又该如何监听特定的事件？</p>
<p><strong>事件走向</strong></p>
<p>纷繁复杂的事件不断地的输入到我们的程序里，无一例外走的同一条道路：</p>
<p><img src="/2019/02/22/LearningNotes-QT-04/2.jpg" alt="Title"></p>
<p>事件首先进入到事件过滤器当中，再将放行的事件投递到事件分发器中，最后通过事件分发器将事件分发到对应的处理函数去执行相关事物。</p>
<p><strong>事件监听</strong></p>
<p>如果要监听某个对象的若干个事件，可以从事件过滤器入手，也可从事件分发器入手。</p>
<p>区别在于如果从事件过滤器入手，所监听的事件将是安装了过滤的对象所收到的全部事件，而从事件分发器入手，则不一定能得到所有的事件，因为有部分事件可能在事件过滤器中被截获并拒绝放行了。下面只谈事件过滤器。</p>
<p>要对一个对象进行事件过滤，首先需要在其上安装事件过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QObject::installEventFilter(QObject *filterObj)</span><br></pre></td></tr></table></figure>
<p>其在官方手册中的描述如下：</p>
<blockquote>
<p>Installs an event filter filterObj on this object. For example:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">monitoredObj-&gt;installEventFilter(filterObj)</span><br></pre></td></tr></table></figure></p>
<p>An event filter is an object that receives all events that are sent to this object. The filter can either stop the event or forward it to this object. The event filter filterObj receives events via its eventFilter() function. The eventFilter() function must return true if the event should be filtered, (i.e. stopped); otherwise it must return false.<br>If multiple event filters are installed on a single object, the filter that was installed last is activated first.</p>
</blockquote>
<p>从中可以看到，在事件过滤器中我们不仅能得到事件接收到的全部事件，还能通过在过滤函数中返回true将指定事件不放行，进而间接使得对应的处理函数失效。</p>
<p>eventFilter() 与 event() 函数都是定义在 QObject 类中的虚函数，用于事件的过滤和分发。在安装事件过滤器后，我们只需要在对应的 QObject 类的衍生类当中将其重写就可以了， eventFilter() 函数的声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool QObject::eventFilter(QObject *watched, QEvent *event)</span><br></pre></td></tr></table></figure>
<p>其在官方手册中的描述如下：</p>
<blockquote>
<p>Filters events if this object has been installed as an event filter for the watched object.<br>In your reimplementation of this function, if you want to filter the event out, i.e. stop it being handled further, return true; otherwise return false.</p>
</blockquote>
<p>由此可以看出，参数 watched 是<strong>被安装事件过滤器的对象</strong>，参数 event 是<strong>该对象接收到的事件</strong>。</p>
<p>其中参数 event 类型 QEvent 是 Qt 当中所有事件类型的基类，其不仅包含了事件的类型，也携带了事件的相关参数，因此我们完全可以在过滤事件时就将需要的事件处理掉。</p>
<p>当 Qt 的主事件循环（QCoreApplication::exec()）从事件队列中提取本机窗口系统事件后，就会将其转换为qEvents，并将转换后的事件发送到qObjects，进而送入到该对象所安装的过滤器当中。</p>
<p><img src="/2019/02/22/LearningNotes-QT-04/3.jpg" alt="Title"></p>
<h1 id="二、小例子：简单恶搞小程序"><a href="#二、小例子：简单恶搞小程序" class="headerlink" title="二、小例子：简单恶搞小程序"></a>二、小例子：简单恶搞小程序</h1><blockquote>
<p>目标效果：界面上显示标签：你爱学习吗？并显示两个按钮“爱”与“不爱”，其中”不爱”按钮不允许被鼠标指到。</p>
</blockquote>
<p><strong>建立 Qt Gui 项目，并完成界面的简单搭建：</strong></p>
<p><img src="/2019/02/22/LearningNotes-QT-04/4.jpg" alt="Title"></p>
<p><strong>在主界面类构造函数中为”不爱”按钮（pushButton_2）安装事件过滤器：</strong></p>
<p><img src="/2019/02/22/LearningNotes-QT-04/5.jpg" alt="Title"></p>
<p><strong>在主界面类头文件中声明事件过滤函数：</strong></p>
<p><img src="/2019/02/22/LearningNotes-QT-04/6.jpg" alt="Title"></p>
<p><strong>实现事件过滤函数</strong></p>
<p><img src="/2019/02/22/LearningNotes-QT-04/7.jpg" alt="Title"></p>
<blockquote>
<p>其中 QEvent::Enter 代表 Qt 当中的鼠标进入事件，例如对此处的按钮而言，当鼠标移入按钮的瞬间，该事件被触发。<br>QEvent::Enter 的数据类型为 Type，代表事件类型，是定义在 QEvent 类中的枚举，其中 QEvent::Enter 在该枚举中的定义：<br><img src="/2019/02/22/LearningNotes-QT-04/8.jpg" alt="Title"><br>其它的事件类型可以在官方手册的 QEvent 类中很容易地找到。</p>
</blockquote>
<p><strong>F5调试效果：</strong></p>
<p><img src="/2019/02/22/LearningNotes-QT-04/9.gif" alt="Title"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT（三）：浅探 QTimer 类</title>
    <url>/2019/02/20/LearningNotes-QT-03/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇介绍了 QTimer 类的基本用法，并应用该类制作了一个简单的倒计时程序。<br>环境：Win10 + QT Creator4.4.1 + QT5.9.2。<br>实现内容：通过按钮触发一个简单的倒计时并在屏幕上显示，时间耗尽后弹出提示框。</p>
</blockquote>
<p><img src="/2019/02/20/LearningNotes-QT-03/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、QTimer-类浅述"><a href="#一、QTimer-类浅述" class="headerlink" title="一、QTimer 类浅述"></a>一、QTimer 类浅述</h1><p>QTimer 类是 QT 为我们提供的一个时钟类，可以通过创建 QTimer 的实例，并将周期信号连接到适当的槽，来方便地实现周期性的函数调用。以下是官方手册中给出的描述：</p>
<blockquote>
<p>The QTimer class provides repetitive and single-shot timers.<br>The QTimer class provides a high-level programming interface for timers. To use it, create a QTimer, connect its timeout() signal to the appropriate slots, and call start(). From then on, it will emit the timeout() signal at constant intervals.</p>
</blockquote>
<p><strong>如何使用</strong></p>
<p>为了使用 QTimer 类，必须包含相应的头文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;QTimer&gt;</span><br></pre></td></tr></table></figure>
<p>完成头文件包含后，就可以通过 new 关键字来得到一个 QTimer 类的实例指针：</p>
<blockquote>
<p>其中 QTimer 类的非空构造函数的参数指明了时钟绑定的对象，一般写 this，便于和主窗口的槽建立连接。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QTimer timer = new QTimer(this); // 创建时钟</span><br></pre></td></tr></table></figure>
<p>时钟生成后，就可以通过成员函数：QTimer::start(int msec)、QTimer::stop()来控制时钟的开始与停止了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timer.start(100); // 以 100ms 为时钟周期启动时钟</span><br><span class="line">timer.stop(); // 停止时钟</span><br></pre></td></tr></table></figure>
<p>当然，start 函数的参数列表是可空的，因此也可通过成员函数 QTimer::setInterval(int msec) 来只设定时钟的周期，在合适的时机通过 QTimer::start(null) 单独启动时钟，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QTimer timer = new QTimer(this); // 创建时钟</span><br><span class="line">timer.setInterval(200); // 设置时钟周期</span><br><span class="line">...</span><br><span class="line">timer.start(); // 启动时钟</span><br></pre></td></tr></table></figure>
<p><strong>信号的接受</strong></p>
<p>时钟开始运转后，每当到达了设定的时间，就会自动触发 QTimer::timeout() 信号，通过 connect 函数将信号与槽函数相关联，就可以定时收到“时钟消息”了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QTimer timer = new QTimer(this); // 创建时钟</span><br><span class="line">timer.setInterval(200);	// 设置时钟周期为 200 ms</span><br><span class="line">connect(timer, SIGNAL(timeout()), this, SLOT(update())); // 将到时信号与主窗口的update槽关联</span><br><span class="line">...</span><br><span class="line">timer.start(); // 启动时钟</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二、小例子：简单倒计时"><a href="#二、小例子：简单倒计时" class="headerlink" title="二、小例子：简单倒计时"></a>二、小例子：简单倒计时</h1><blockquote>
<p>目标效果：在文本框内输入时间(秒)，按下倒计时按钮，程序开始倒计时，并在屏幕上显示剩余的秒数，当时间耗尽时弹出信息框给出相应提示。</p>
</blockquote>
<p><strong>首先创建一个 Qt GUI 项目，并简单搭建一下界面：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/2.jpg" alt="Title"></p>
<p><strong>定义一下 timer 与剩余时间：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/3.jpg" alt="Title"></p>
<p><strong>完成 pushButton 的 clicked 槽实现，点击按钮启动时钟：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/4.jpg" alt="Title"></p>
<p><strong>别忘了定义槽啊大兄弟：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/5.jpg" alt="Title"></p>
<p><strong>最后在.cpp中把槽实现就O98K了：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/6.jpg" alt="Title"></p>
<p><strong>运行起来的效果是这样的：</strong></p>
<p><img src="/2019/02/20/LearningNotes-QT-03/7.gif" alt="Title"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT（二）：简单多窗口程序</title>
    <url>/2019/02/19/LearningNotes-QT-02/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇记录如何通过 QT Creator 开发一个简单的多窗口程序。<br>环境：Win10 + QT Creator4.4.1 + QT5.9.2。<br>实现内容：在主窗口中输入指定的口令，点击按钮载入另一个窗口，并给出了子窗口只允许同时载入一次的三种方法。</p>
</blockquote>
<p><img src="/2019/02/19/LearningNotes-QT-02/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、建立-QT-项目"><a href="#一、建立-QT-项目" class="headerlink" title="一、建立 QT 项目"></a>一、建立 QT 项目</h1><p><strong>打开 QT Creator，新建 Qt Widget Application 项目。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/2.jpg" alt="Title"></p>
<p><strong>设置项目名称，一直下一步完成项目创建。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/3.jpg" alt="Title"></p>
<p><strong>下图是初始的工程结构：</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/4.jpg" alt="Title"></p>
<h1 id="二、添加新的GUI文件"><a href="#二、添加新的GUI文件" class="headerlink" title="二、添加新的GUI文件"></a>二、添加新的GUI文件</h1><p><strong>在项目目录中选中 Forms 右键，添加新文件。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/5.jpg" alt="Title"></p>
<p><strong>在新建文件窗口中选择 Qt 类，Qt 设计师界面类，确定。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/6.jpg" alt="Title"></p>
<p><strong>按照实际需要选择界面模板，此处选择的依旧是 Main Window，下一步。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/7.jpg" alt="Title"></p>
<p><strong>默认的类目还是 MainWindow，为了避免与主窗口冲突，重新选择类名，一路下一步，完成。</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/8.jpg" alt="Title"></p>
<p><strong>新的 Qt 设计器界面类创建完成后的工程结构：</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/9.jpg" alt="Title"></p>
<h1 id="三、窗口载入的实现"><a href="#三、窗口载入的实现" class="headerlink" title="三、窗口载入的实现"></a>三、窗口载入的实现</h1><p><strong>打开主窗口的.ui文件，添加一个 lineEdit 和一个 pushButton 做一个简陋的界面意思一下，其中 lineEdit 设置了显示方式为 Password，并设置了默认文本：</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/10.jpg" alt="Title"></p>
<p><strong>运行起来的效果是这样的：</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/11.gif" alt="Title"></p>
<p><strong>接下来我们要实现的是，当文本框中的内容为指定内容，如 Houkaifa 时，点击确认按钮载入窗口 ChildWindow。</strong></p>
<p><strong>首先，我们在主窗口的.h文件中添加对子窗口的头文件包含：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;childwindow.h&gt;</span><br></pre></td></tr></table></figure>
<p><strong>并在主窗口类中定义一个子窗口类的私有成员：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br><span class="line">    ChildWindow *cw;</span><br></pre></td></tr></table></figure>
<p><strong>完整的代码看上去是这样的：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;childwindow.h&gt;</span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">private:</span><br><span class="line">    ChildWindow *cw;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<p><strong>emmm，还是放图片看起来清楚些：</strong></p>
<p><img src="/2019/02/19/LearningNotes-QT-02/12.jpg" alt="Title"></p>
<center><font size="2" color="#bbbbbb">立个小flag，找时间一定给博客的代码做一下高亮支持（小声BB，你们看不到你们看不到）</font></center>
**下面，我们为主窗口的 pushButton 添加 clicked 信号的槽函数，用以判断口令是否正确。**

![Title](13.jpg)

**在口令正确的情况下，如何载入子窗口 cw？**
在主窗口类中我们定义了 ChildWindow 类的一个私有成员，只需在合适的位置将其实例化，并调用show()函数进行显示即可，具体代码如图：

![Title](14.jpg)

**当然，不将子窗口类定义为类成员，直接在需要的时候创建临时变量也是可行的，例如删除 cw 的成员声明，而在上图的注释(// Load ChildWindow)处直接添加如下代码：**

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChildWindow *cw = new ChildWindow(this);</span><br><span class="line">cw-&gt;show();</span><br></pre></td></tr></table></figure>

**F5调试程序，测试效果：**

- 输入错误口令，点击确认按钮，提示口令错误。

![Title](15.gif)

- 输入正确口令，点击确认按钮，载入 ChildWindow。

![Title](16.jpg)

<center>--- END（假的） ---</center>
--------------------

**此时你会发现，多次点击确认按钮，会载入多个 ChildWindow，如果不希望子窗口被多次同时载入，可以：**

- 方法一：在子窗口载入完成后将主窗口隐藏：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cw-&gt;show();	// 显示子窗口</span><br><span class="line">this-&gt;hide();	// 隐藏主窗口</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

- 方法二：将 ChildWindow 改装成单例类。

- 方法三：像本例一样将 ChildWindow 定义为主窗口的类成员，并在子窗口被关闭后将指针置空，在点击确认按钮时验证指针状态，即可知道窗口是否已创建，详细见下文：

**如何在子窗口关闭后将指针置空？**
**答：重写 closeEvent 事件函数。**
> closeEvent 是 QCloseEvent 类中的虚函数，其原型为：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void closeEvent(QCloseEvent* event);</span><br></pre></td></tr></table></figure>

> 在窗口关闭时被触发，将该类包含在子窗口的头文件中，并对 closeEvent 函数进行重写，即可实现在子窗口关闭时进行自定义操作。

![Title](17.jpg)

**接下来在子窗口的.cpp文件中对 closeEvent 函数进行实现，直接发送信号：**

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ChildWindow::closeEvent(QCloseEvent* event)</span><br><span class="line">&#123;</span><br><span class="line">    emit windowClosed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**最后补全主窗口的代码即可：**

![Title](18.jpg)

**效果：**

![Title](19.gif)

<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>QT（一）：信号与槽</title>
    <url>/2019/02/18/LearningNotes-QT-01/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>分别通过 QT Designer 与 connect 函数添加(绑定)信号与槽。<br>环境：Win10 + VS2017 + QT5.9.2。<br>实现内容：点击按钮退出程序、点击按钮弹出信息框。</p>
</blockquote>
<p><img src="/2019/02/18/LearningNotes-QT-01/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h1 id="一、建立-QT-项目"><a href="#一、建立-QT-项目" class="headerlink" title="一、建立 QT 项目"></a>一、建立 QT 项目</h1><p><strong>打开 Visual Studio 2017，新建 QT GUI Application。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/2.jpg" alt="Title"></p>
<p><strong>一路 Next，Finish。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/3.jpg" alt="Title"></p>
<p><strong>下图是初始目录结构：</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/4.jpg" alt="Title"></p>
<p><strong>F5调试程序，看到初始的GUI界面：</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/5.jpg" alt="Title"></p>
<h1 id="二、使用-QT-Designer-添加信号与槽"><a href="#二、使用-QT-Designer-添加信号与槽" class="headerlink" title="二、使用 QT Designer 添加信号与槽"></a>二、使用 QT Designer 添加信号与槽</h1><p><strong>在解决方案中，找到默认生成的.ui文件，双击以在 QT Designer 中打开。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/6.jpg" alt="Title"></p>
<p><strong>在 Widget Box 中拖拽 Push Button 到主窗口上。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/7.jpg" alt="Title"></p>
<p><strong>在属性编辑器中修改 objectName、text 的值为 “closeButton”。</strong></p>
<blockquote>
<p>其中 objectName 是 Widget 组件的组件名，text 是显示在按钮上的标题。text 值还可以通过双击添加的按钮来快速修改。</p>
</blockquote>
<p><img src="/2019/02/18/LearningNotes-QT-01/8.jpg" alt="Title"></p>
<p><strong>随后在信号/槽编辑器中添加信号槽。</strong></p>
<p>发送者为按钮 closeButton，信号为 clicked() 即鼠标左键单击信号(事件/event)，接收者为 QtGuiApplicationClass，槽为 close()，即 QtGuiApplicationClass 的销毁函数。</p>
<p><img src="/2019/02/18/LearningNotes-QT-01/9.jpg" alt="Title"></p>
<p><strong>Ctrl+S 保存修改，回到 VS2017，F5调试程序，点击 closeButton 按钮，程序退出。</strong></p>
<blockquote>
<p>信号与槽是 QtGui 开发当中事件的表示形式，信号即是事件的触发条件，槽即是信号所触发的事件处理函数。<br>在 Qt Designer 中可以通过信号/槽编辑器方便地添加一些原生的信号槽。后文描述了如何添加自定义的槽。</p>
</blockquote>
<h1 id="三、通过-connect-函数绑定自定义槽"><a href="#三、通过-connect-函数绑定自定义槽" class="headerlink" title="三、通过 connect 函数绑定自定义槽"></a>三、通过 connect 函数绑定自定义槽</h1><p><strong>在 QT Designer 中添加一个新的按钮，相关属性修改为 MessageButton，现在我们有了两个按钮。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/10.jpg" alt="Title"></p>
<p><strong>回到 VS2017，转到.h文件中，添加槽的定义。</strong></p>
<p>其中函数名及返回值类型是固定的格式：<strong>void on_WidgetName_Event()。</strong><br>此处 WidgetName 是 MessageButton，对应的事件是 clicked，因此可以在下图中看到，完整函数声明是：</p>
<blockquote>
<p>void on_MessageButton_clicked();</p>
</blockquote>
<p><img src="/2019/02/18/LearningNotes-QT-01/11.jpg" alt="Title"></p>
<blockquote>
<p>如果.h文件中出现 ui_*.h文件的包含错误，如下图：<br><img src="/2019/02/18/LearningNotes-QT-01/13.jpg" alt="Title"><br>只需在 VS2017 的 QT VS Tools 菜单栏中选择 Convert Project to QMake Generated Project 即可解决。<br><img src="/2019/02/18/LearningNotes-QT-01/14.jpg" alt="Title"></p>
</blockquote>
<p><strong>之后就可以跳转到对应的.cpp文件添加函数的实现了。</strong></p>
<p>这里使用了 QMessageBox 类中的 warning 函数，用以显示警告信息框。在 QMessageBox 头文件中提供了丰富的信息框样式，<strong>对应的调用其中的信息框需要在.h文件中包含其头文件。</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;QMessageBox.h&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/02/18/LearningNotes-QT-01/12.jpg" alt="Title"></p>
<p><strong>截至目前，我们添加了一个按钮 MessageButton，定义并实现了其一个槽函数（on_MessageButton_clicked）。</strong></p>
<p>但是现在我们运行程序，单击 messageButton 按钮是不会有任何反应的，因为我们只完成了槽函数的定义和实现，下面我们在 QtGui 类的构造函数处，将信号与槽通过 connect 函数进行连接。</p>
<p><img src="/2019/02/18/LearningNotes-QT-01/15.jpg" alt="Title"></p>
<blockquote>
<p>此处 connect 函数的原型如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal,</span><br><span class="line">                        const QObject *receiver, const QMetaMethod &amp;method,</span><br><span class="line">                        Qt::ConnectionType type = Qt::AutoConnection);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>至此，F5调试程序，按下按钮可以看到弹出了信息框。</strong></p>
<p><img src="/2019/02/18/LearningNotes-QT-01/16.jpg" alt="Title"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年猴开发博客更新计划</title>
    <url>/2019/02/02/BlogUpdate2019/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>猴开发博客从上线至今虽已有一段时间，但过去以来都没有过多的更新与维护过。再过几天就是2019年的春节了，这也是正式步入新年的标志。在新的一年里，为了促进个人进步和经验共享，也为了猴开发博客在猪年的进一步完善和发展，我在此列出了一份博客更新计划，主要内容涉及栏目的调整以及博客体制的小变动，也是希望在新的一年里能够与大家共同进步，书写一个满意的新年篇章。</p>
</blockquote>
<p><img src="/2019/02/02/BlogUpdate2019/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h3 id="一、新的栏目"><a href="#一、新的栏目" class="headerlink" title="一、新的栏目"></a><strong>一、新的栏目</strong></h3><p>博客将开设两个新的栏目：<strong>札记</strong>、<strong>周任务清单</strong>，同时 <strong>归档</strong> 栏目将被移除。</p>
<p>计划开设的新栏目将于2019年3月1日前陆续上线。</p>
<h4 id="札记"><a href="#札记" class="headerlink" title="札记"></a>札记</h4><p>在博客内成系列的文章以及以系列形式更新的文章将单独收录在札记板块中，包括且不限于：读书笔记、学习心得、热点资讯的跟踪和个人观点。</p>
<p>将文章以札记的形式进行汇总和更新，一用以促进持续性学习，二便于构建自己的完整知识体系。</p>
<h4 id="周任务清单"><a href="#周任务清单" class="headerlink" title="周任务清单"></a>周任务清单</h4><p>周任务清单栏目将在每周日或次周的周一定期更新，并在每周任意时刻不定期更新。</p>
<p>定期更新内容包括新一周任务计划的发布与上一周任务计划的归档；</p>
<p>不定期更新是更新当前周任务的进展与完成情况。</p>
<p>周任务清单将以单页面瀑布流的形式持续更新，一用以自我督促，二便于自我督促。</p>
<hr>
<h3 id="二、博客投稿"><a href="#二、博客投稿" class="headerlink" title="二、博客投稿"></a><strong>二、博客投稿</strong></h3><p>猴开发博客将于2019年02月05日起接受<strong>原创投稿</strong>，投稿的原创文章经审核后将公开发表在猴开发博客中，优秀文章可在一定期限内置顶显示。</p>
<p>特别的，如果在博客连续投稿且投稿文章质量较好且具主题连续性的，将单独在札记板块为其开设主题札记。</p>
<p>在猴开发博客成功发表的文章所获得的打赏金额归文章原作者所有，博主不收取任何费用。</p>
<p>投稿的基本要求与具体的投稿方法以及你们会有的疑问，<a href="/contribute/">请看这里</a>。</p>
<h3 id="三、其它调整"><a href="#三、其它调整" class="headerlink" title="三、其它调整"></a><strong>三、其它调整</strong></h3><ul>
<li><p>博客由原 <strong>Sunwish’s Blog</strong> 正式更名为 <strong>猴开发博客 / Houkaifa Blog</strong>；</p>
</li>
<li><p>博客主页侧栏中的博主简介内容陆续移至 <strong>关于</strong> 栏目；</p>
</li>
<li><p>移除 <strong>归档</strong> 栏目，归档内容仍可在 <strong>关于</strong> 页面进行访问；</p>
</li>
<li><p>文章标题处显示文章作者。</p>
</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>博客历程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>如何叉着腰喝着茶穿越福城？</title>
    <url>/2019/01/31/ADB-CrossLuckyCity/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>春节快到了，于是新版QQ多了福袋这么个玩意儿，获取福袋的方法很简单就是玩小游戏。当然这篇文章不是记录如何刷福袋的(雾)，而是穿越福城这个小游戏和微信跳一跳很相似，但又有不同之处，所以身为爱折腾人士怎么可能放过此游戏？像这种游戏看着它玩远比你自己玩有意思多了。</p>
</blockquote>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/1.jpg" alt="Title"></p>
<a id="more"></a>
<hr>
<h3 id="一、游戏分析"><a href="#一、游戏分析" class="headerlink" title="一、游戏分析"></a><strong>一、游戏分析</strong></h3><h4 id="1-游戏玩法"><a href="#1-游戏玩法" class="headerlink" title="1.游戏玩法"></a>1.游戏玩法</h4><p>游戏玩法很简单，和微信跳一跳完全没区别，只要按住屏幕，小企鹅前面就会伸出一根梯子，按的时间越长梯子也越长，放开之后梯子就会向下一个格子下落，落到越靠近方块中心得分越高。如果梯子的长度没有达到下一层，或者是超过了下一层，那么不得分，并且游戏判定结束。</p>
<h4 id="2-得分机制"><a href="#2-得分机制" class="headerlink" title="2.得分机制"></a>2.得分机制</h4><p>按住屏幕一定时间后放开，使得梯子落下后边缘尽可能靠近中心，最外层得一分，中间层得两分，中心块得三分，各层之间用颜色来区分。</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/2.jpg" alt="Title"></p>
<p>特别的，如果连续拿到中心块的话，所得分数将是上一次得分累计加三分，即用$k$代表连续拿到中心块的次数，那么第$k$次所获得的分数$C_k$可以表示为：</p>
<script type="math/tex; mode=display">
\begin{equation}
C_k=3k (k=1,2,...)
\end{equation}</script><p>这一机制也就使得，短时间内获得高分的需求将不是尽可能多的击中中心块，而是尽可能多的连击中心块。</p>
<h3 id="二、机机交互"><a href="#二、机机交互" class="headerlink" title="二、机机交互"></a><strong>二、机机交互</strong></h3><p>我们的目的是叉着腰喝着茶穿越福城，所以就需要电脑自动帮我们玩，然而手机肯定是不会自己玩的，我们需要在电脑上编写程序，进而通过程序来获取手机数据并控制手机，这是机器与机器之间的交互，简称机机交互。</p>
<p>机机交互我选择adb大法，可是要求手机是安卓系统，这就苦逼了，家里翻来翻去都没有安卓系统的设备，这可咋办呢？</p>
<p>没关系我们还有模拟器啊，不慌不慌，打开MUMU，开启模拟器的USB调试后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 127.0.0.1:7555</span><br></pre></td></tr></table></figure>
<p>正常连接，这可又苦逼了，使用模拟器竟然进不去这个游戏？？这只企鹅是魔鬼吧，这可咋办呢？好在我又翻来翻去，终于，还是找到了一台CentOS系统的手机，看上去颇具年代感，不过也够用了。</p>
<p>首先进入手机设置，将开发者模式打开，并且打开USB调试功能，随后用数据线将手机与电脑连接起来，在手机上授权所连接的电脑进行调试就可以了。在控制台中可以看到我们的手机设备已经Attached，并且状态正常。</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/3.jpg" alt="ADB连接"></p>
<p>如果显示设备offline，那么请检查：</p>
<ol>
<li>是不是线松了/…（紧一紧插口或者重连）</li>
<li>手机端是否打开了USB调试（若没有则打开重连）</li>
<li>手机端是否对所连接的电脑授权同意了（若没有则重连确认授权）</li>
</ol>
<p>如果以上两条都没问题，那么请尝试：</p>
<ol>
<li>重启ADB服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br><span class="line">adb devices</span><br></pre></td></tr></table></figure>
<ol>
<li>断开连接，重启手机、电脑，重新连接</li>
<li>换用更高版本的ADB</li>
</ol>
<p>连接成功后，我们就可以写点代码测试一下效果了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	system(&quot;adb shell input tap 100 100&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以直接在控制台进行测试，下面是一些基本操作的adb指令：</p>
<ul>
<li><strong>点击屏幕</strong>$(x,y)$</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input tap x y</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>滑动屏幕</strong>$(x_1,y_1) \rightarrow (x_2,y_2)$，<strong>总时长</strong>$t$<strong>毫秒</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input swipe x1 y1 x2 y2 t</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>长按屏幕</strong>$(x,y)$<strong>处</strong>$t$<strong>毫秒</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell input swipe x y x y t</span><br></pre></td></tr></table></figure>
<h3 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a><strong>三、原理分析</strong></h3><h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1.基本原理"></a>1.基本原理</h4><p>游戏本身只有一个输入操作，就是长按屏幕，对应的也就只有一个输入变量，即长按时间。而玩家控制按压时间的长短则是依靠小企鹅和目标块之间的距离来判断的，距离越长所需的按压时间也越长，距离越短所需的按压时间也越短。正如$3Blue1Brown$所说，在解决问题的过程中取名字总是喜闻乐见的，我们就将长按时间取名叫做$HoldTime$，小企鹅与中心块之间的距离叫做$Distance$，按压得到的梯子长度叫做$Length$，直观上看很容易得出结论：</p>
<script type="math/tex; mode=display">
\begin{equation}
HoldTime \propto Length
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
HoldTime \propto Distance
\end{equation}</script><p>但事实真的如此吗？我记录了一些三分情况下的$Distance$与$HoldTime$数据，并做出散点图</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/11.jpg" alt="Title"></p>
<p>发现两者之间并不存在明确的线性关系，甚至好像毫无关系，但无论如何，$Distance$在直观上与$HoldTime$是必然存在线性或近似线性的关系的，因此我选择<strong>认为他们是线性关系</strong>，只是还有其他量影响着我们的长按时间，将本身的线性扭曲了，因此下面关于$Distance$的内容均以线性讨论，校正的内容在$3.2$中进行探讨。</p>
<p>其实说白了，我们需要做的就是找出$Distance$与$HoldTime$之间的函数关系$H(d)$，使得按照$Distance$计算出的按压时长$H(d)$得到的梯长$Length$与$Distance$自身的差值$\delta$尽可能小，即</p>
<script type="math/tex; mode=display">
\begin{equation}
min \delta = min\{|L(H(d))-d|\}
\end{equation}</script><p>但是$Distance$本身并没有绝对标准的数据来源，这个指标$\delta$我们大可直接以可视的得分情况来代替，得三分说明$\delta$足够小，得两分说明$\delta$大小一般，得一分或不得分就说明$\delta$偏大了，我们进而可以引入更高一层的判别指标来对$H(d)$做出更具整体性的评价：</p>
<p>定义计算$n$次$H(d)$，得$m$分的次数为$C_m$，则有$n$轮中心命中概率</p>
<script type="math/tex; mode=display">
\begin{equation}
P(n)=\frac{1}{n}\Sigma_{m=3}^{+\infty}C_m
\end{equation}</script><p>此时问题转化为了：寻找一个函数$H(d)$，使得依照此函数进行游戏满足</p>
<script type="math/tex; mode=display">
\begin{equation}
lim_{n \rightarrow + \infty}\frac{1}{n}\Sigma_{m=3}^{+\infty}C_m=1
\end{equation}</script><h4 id="2-计算原理"><a href="#2-计算原理" class="headerlink" title="2.计算原理"></a>2.计算原理</h4><p>在实际操作的过程中，你会发现需要考虑的量并不仅仅只有$Distance$而已，由于缩放特性的存在，像素世界里距离的定义永远是相对的，同样是$200px$在不同的缩放参数下所表示的距离可能相差很大，例如在本文的封面图中，我们可以测量出小企鹅底部到目标中心点的最小包围矩形宽度$300px$，高度$173px$，距离大致是$245px$，而在下图中，小企鹅到中心点的距离大致是$167px$，可是下图的距离显然比封面图的距离要远，但像素层面的距离却更短，这就是全局缩放所导致的。</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/4.jpg" alt="Title"></p>
<p>为了知晓缩放程度，我们可以选择常量——企鹅自身高度作为参照依据，企鹅在屏幕上显示的高度记作$HeightPlayer$，$HeightPlayer$越小，说明全局缩放程度越大，更准确的说是全局缩小的程度越大。<br>可以选择找出$HeightPlayer$与缩放比例之间的关系，进而矫正$Distance$为$d’$并继续使用原来的函数$H(d’)$计算长按时间，也可以选择直接将$HeightPlayer$也纳为影响按压时间的客观变量，修改得到新的二元函数$H(d,h)$，这里我选择了第二种方式。</p>
<hr>
<blockquote>
<p>如果你想要采用第一种方式的话，即寻找校正函数来修正被缩放的$Distance$，你可能需要记录一些数据来检视$Height$与$HoldTime$之间的数学关系以避免盲目的尝试，虽然我选的第二种方式，但依旧做了一下这方面的测试，下面的内容可供参考。</p>
</blockquote>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/10.jpg" alt="Title"></p>
<p>做出$Height$与$HoldTime$的散点图，可以看到两者之间呈现出二次函数的关系，通过二次函数拟合，得到了可观的$R-squre$与$SSE$，所以如果你想尝试矫正$Distance$，那么你可能需要从形如下式的函数入手</p>
<script type="math/tex; mode=display">
\begin{equation}
D'(d,h)=(h-c_1)^2d+c_2
\end{equation}</script><p>这里不给出所求得的$c_1$与$c_2$的具体数值，因为不同的设备有不同的分辨率，参数的具体值是没有意义的，后文有给出部分计算数据，如果你尝试直接套用的话，可能不会得到理想的效果。</p>
<hr>
<h4 id="3-数据获取原理"><a href="#3-数据获取原理" class="headerlink" title="3.数据获取原理"></a>3.数据获取原理</h4><p>由上面的原理不难知道，为了计算长按时间，我们需要的数据无非就是企鹅高度和距中心点的距离，这两个数据通过简单的图像分析和简单的计算不难得到。<br>首先中心块的颜色集合与企鹅的颜色集合是固定的，通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p /sdcard/screen.png</span><br><span class="line">adb pull /sdcard/screen.png</span><br></pre></td></tr></table></figure>
<p>得到屏幕图像后，逐像素点扫描，检查是否满足中心块/企鹅颜色即可。</p>
<p>这个过程可以用数学模型更清晰的表述出来，下面给出寻找中心块与企鹅，以及企鹅高度计算的数学描述。</p>
<p>假设中心块的颜色集合为三元组</p>
<script type="math/tex; mode=display">
\begin{equation}
RGB_t=\{(r_1,g_1,b_1),(r_2,g_2,b_2),...,(r_m,g_m,b_m)\}
\end{equation}</script><p>企鹅身体的颜色集合为三元组</p>
<script type="math/tex; mode=display">
\begin{equation}
RGB_b=\{(r_1,g_1,b_1),(r_2,g_2,b_2),...,(r_n,g_n,b_n)\}
\end{equation}</script><p>指定扫描区域的红黄蓝三原色数据被分别存放在二维数组$R[i][j]$、$G[i][j]$、$B[i][j]$中，定义函数</p>
<script type="math/tex; mode=display">
\begin{equation}
Exist(r,g,b,A)=\left\{
\begin{array}{rcl}
1 & & {(r,g,b) \in A}\\
0 & & {(r,g,b) \notin A}
\end{array} \right.
\end{equation}</script><ul>
<li>当某点$(x,y)$满足</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
Exist(R[x][y],G[x][y],B[x][y],RGB_t) = 1
\end{equation}</script><p>认为该点落在目标中心块中，在所有满足该式的点集中取$y$最小的那对坐标$(x<em>1,y</em>{min})$即是中心块的顶点，取$y$最大的那对坐标$(x<em>2,y</em>{max})$即是中心块的底点，$(\frac{x<em>1+x_2}{2},\frac{y</em>{min}+y_{max}}{2})$即是中心点坐标；</p>
<ul>
<li>当某点$(x,y)$满足</li>
</ul>
<script type="math/tex; mode=display">
\begin{equation}
Exist(R[x][y],G[x][y],B[x][y],RGB_b) = 1
\end{equation}</script><p>认为该点落在企鹅身体中，在所有满足该式的点集中取$y$最小的那对坐标$(x<em>1,y</em>{min})$即是企鹅的顶点，取$y$最大的那对坐标$(x<em>2,y</em>{max})$即是企鹅的底点，易得企鹅的高度</p>
<script type="math/tex; mode=display">
\begin{equation}
HeightPlayer=y_{max}-y_{min}
\end{equation}</script><p><img src="/2019/01/31/ADB-CrossLuckyCity/12.jpg" alt="Title"></p>
<p>最后提一点，全屏扫描肯定是低效的，为了提高检测效率，在实际编码时最好截取屏幕固定的矩形区域，例如上图这样的区域，再进行扫描以节省时间。</p>
<h3 id="四、算算看吧"><a href="#四、算算看吧" class="headerlink" title="四、算算看吧"></a><strong>四、算算看吧</strong></h3><p>其实很显然$H(d,h)$应该就是简单的线性组合$k_1d+k_2h$，可以直接通过一定一动结合二分法将$k_1$与$k_2$的值手动调出个八九不离十，但我实在是懒…所以直接无脑记录$60$次命中中心情况下的$d$、$h$数据进行多元函数拟合了。但是注意，这样做是有弊端的，为了得到尽可能好的拟合效果，得到较高的均方根方与低$SSE$，往往忍不住用高次拟合，而最终损失的是算法的鲁棒性。<br>最后得到的拟合函数：</p>
<script type="math/tex; mode=display">
\begin{equation}
H(d,h) = p_{00} + p_{10}d + p_{01}h + p_{20}d^2 + p_{11}dh + p_{02}h^2
\end{equation}</script><p>下列系数均略写了$95\%$的置信区间：</p>
<script type="math/tex; mode=display">
\begin {array}{r|r|r|r|r|r}
\hline
p_{00} & p_{10} & p_{01} & p_{20} & p_{11} & p_{02} \\ \hline
1311 & 8.71 & -63.91 & -0.0101 & -0.02503 & 0.5314 \\ \hline
\end {array}</script><p>拟合图像你要是这样看的话没啥用：</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/5.jpg" alt="Title"></p>
<p>让我们来看看侧视图：</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/6.jpg" alt="Title"></p>
<p>从拟合图像的侧视图易知$HoldTime$与$height$并不是简单的线性关系，而是二次函数的关系，这也就成功推翻了自己本小节开头说的话，额…</p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/7.jpg" alt="Title"></p>
<p><img src="/2019/01/31/ADB-CrossLuckyCity/8.jpg" alt="Title"></p>
<p>我，推翻我自己，2333</p>
<h3 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a><strong>五、代码实现</strong></h3><p>正所谓编码半小时，调参一整天，代码部分可以说是整个过程中最简单的了，简单到可略。</p>
<h3 id="六、测试效果"><a href="#六、测试效果" class="headerlink" title="六、测试效果"></a><strong>六、测试效果</strong></h3><p>测试效果：良<br>还是会有偶尔的失误，不过准确率已经比较高了，最高连击在10次左右，毕竟只是通过少量数据拟合得到的效果，现在已知$HoldTime$与$Distance$、$Height$的级次关系，如果通过定式拟合，将得到更好的效果。<br>不管怎么说，你现在已经可以去叉腰喝茶了。</p>
<p><img src="http://m.qpic.cn/psb?/V13O1BPC29uJSy/8FBuCeY7YhImH8ShmlrtsaigGh5KgS33mI3tN3iLxV8!/b/dFIBAAAAAAAA&amp;bo=0AAhAQAAAAACl0M!&amp;rf=viewer_4" alt="Title"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>ADB</tag>
      </tags>
  </entry>
  <entry>
    <title>对数学建模分工、初期准备、相关资源的总结与建议</title>
    <url>/2019/01/05/CUMCMAdvice/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h1><blockquote>
<p>对数学建模分工、初期准备、相关资源的总结与建议。</p>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2019/01/05/CUMCMAdvice/1.jpg" alt="Title"></h2><a id="more"></a>
<h1 id="零、分工概述"><a href="#零、分工概述" class="headerlink" title="零、分工概述"></a>零、分工概述</h1><p>数学建模竞赛一队人数不超过三人，一般为三人合适，国赛一般在每年九月份举行，为期三天，时间紧张，合适的分工是至关重要的。</p>
<p>编程+建模+写作，是标准分工，但这样分工并不代表着负责编程的同学就不管建模，负责建模的同学就不管写作了，这是因为在比赛的过程中三人的任务涉及到交接，因此分工在数模比赛中是相对的，并不是绝对的，个人认为比较好的情况是：</p>
<ul>
<li>负责编程工作的同学熟练编程，掌握建模，了解写作；</li>
<li>负责建模工作的同学熟练建模，掌握写作，了解编程；</li>
<li>负责写作工作的同学熟练写作，掌握建模，了解编程。</li>
</ul>
<p>个人觉得这样的分工比较合理的原因在于：</p>
<ul>
<li>编程与建模的交互相对紧密，编程同学要确保能够理解模型，进而才能实现模型，建模同学也可以给编程工作提供一些建议。</li>
<li>建模与写作的交互相对紧密，建模同学要确保写出来的论文正确表述了你建立的模型，如果不行可以介入修改，再由写作同学整理语言风格。</li>
</ul>
<p><img src="/2019/01/05/CUMCMAdvice/2.jpg" alt="Title"></p>
<h2 id="其中建模是数学建模的核心，负责编程、建模、写作的同学都要学习"><a href="#其中建模是数学建模的核心，负责编程、建模、写作的同学都要学习" class="headerlink" title="其中建模是数学建模的核心，负责编程、建模、写作的同学都要学习"></a>其中建模是数学建模的核心，负责编程、建模、写作的同学都要学习</h2><p>虽然建模由一位队员主要负责，但每个队员对基本的、常用的、常见的模型都要有了解，不然容易出现建模的同学模型建出来了，编程的同学不能理解，导致无法算出结果，或是写作的同学不能理解，不能很好的将模型在论文中体现出来，甚至出现模型的表述错误的情况，这些问题在短短三天的比赛时间内都是致命的。</p>
<p>对于基本的模型与方法，一般都会在暑假期间集中大家在一起学习，这里就不说了。关于建模的书籍，广泛推荐的是司守奎老师的《数学建模算法与应用》以及姜起源老师的《模型与算法》。</p>
<h2 id="编程是数学建模评奖的核心，负责编程的同学要注重模型的实现"><a href="#编程是数学建模评奖的核心，负责编程的同学要注重模型的实现" class="headerlink" title="编程是数学建模评奖的核心，负责编程的同学要注重模型的实现"></a>编程是数学建模评奖的核心，负责编程的同学要注重模型的实现</h2><p>负责编程的同学也叫负责计算，是负责模型的实现与最终结果的输出，在初期的准备过程中，不仅要理解所学习的模型，更要尝试动手实现，实现的过程也是对编程的熟悉与练习，一个好的结果对评奖很重要，如果模型建立的很好，但由于编程的疏忽导致计算结果异常、偏差过大，甚至算不出结果，那参赛的效果也是大打折扣的。</p>
<h2 id="写作是数学建模参赛的核心，负责写作的同学多看历年优秀论文"><a href="#写作是数学建模参赛的核心，负责写作的同学多看历年优秀论文" class="headerlink" title="写作是数学建模参赛的核心，负责写作的同学多看历年优秀论文"></a>写作是数学建模参赛的核心，负责写作的同学多看历年优秀论文</h2><p>数模竞赛最终提交就是一篇论文(如果有需要则附支撑材料)，论文就是卷面，就是评委组审阅的主体。为了熟悉数模论文的套路，最快最直接的方式就是大量阅读往年优秀论文，学习他们的写作手法，并在实践练习中模仿。<br>我认为一篇好的论文要做到以下几点:</p>
<ul>
<li>论文结构清晰，有条有理（通过斟酌论文目录来搭建明确的写作框架）</li>
<li>避免严重的口语化（通过阅读优秀论文来确立合适的语言风格）</li>
<li>文字阐述与数学公式相错排布，尽量做到图文表并茂（写作练习中注重排版与视觉效果，关于图片有机会再说）</li>
<li>摘要很重要，摘要很重要，摘要很重要，摘要是对全文的总结，要言简意赅，不要有任何的废话</li>
</ul>
<p><img src="/2019/01/05/CUMCMAdvice/3.jpg" alt="Title"></p>
<h1 id="一、关于编程"><a href="#一、关于编程" class="headerlink" title="一、关于编程"></a>一、关于编程</h1><h2 id="编程语言的选择"><a href="#编程语言的选择" class="headerlink" title="编程语言的选择"></a>编程语言的选择</h2><p>编程语言建议首选Matlab，也可以选择Python。</p>
<p>选择Matlab的原因主要在于，Matlab作为一门解释型语言、非过程化语言、交互式语言，具有<strong>简单易学易操作易上手</strong>的特性，对硬件的适应性也远超于前三代计算机语言（机器语言、汇编语言、高级语言），同时Matlab一直以其强大的运算效率（矩阵运算）、便捷的代码、丰富的轮子而占为科学计算领域的首选语言，在数模竞赛时间紧张的情况之下，选用Matlab可以说是再合适不过了。</p>
<p>Python作为近几年来大火的语言，也被广泛认为是解释型语言，易学易上手，也有良好的国内生态，因此选用Python也是可以的。负责编程的队员至少熟练掌握其中一个。</p>
<p>这里提供Matlab我在使用的版本，Matlab2017a下载及破解：<a href="https://www.jb51.net/softjc/543170.html" target="_blank" rel="noopener">点我呀点我呀你有本事点我呀</a></p>
<h2 id="如何练习"><a href="#如何练习" class="headerlink" title="如何练习"></a>如何练习</h2><p>如果你之前没有接触过Matlab和Python，那么首先需要入门Matlab或者Python，可以通过以下途径快速地入门一门编程语言：</p>
<ul>
<li>了解这门语言的基本信息（语言的应用场景、是何种类型的编程语言、是否为弱类型语言、平台要求、…）</li>
<li>学习这门语言的基本语法和代码规范（如何定义变量、如何定义函数、如何如何写注释、…）</li>
<li>掌握这门语言的基本交互（如何输入、如何输出、如何引入外部文件、如何引入库…）</li>
<li>掌握三大流程结构在这门语言中的实现方法（顺序、选择、循环）</li>
</ul>
<p>入门一门编程语言之后，为了巩固学习与进一步学习，同时提高自己对模型的实现能力，最好的方式就是勤动手，将平时所学的模型和算法用这门语言进行编码实现，例如启发式优化算法中的遗传算法、模拟退化算法，评价类问题中的主成分分析法、熵权法等，如果能够将这些模型和算法在平时自己实现一遍的话，那么比赛期间所建立的模型，对你来说也就应该没有问题了。如果自己不能实现，那么可以在百度寻找别人实现的代码，看懂别人怎么写，再自己实现。</p>
<h1 id="二、关于建模"><a href="#二、关于建模" class="headerlink" title="二、关于建模"></a>二、关于建模</h1><p>数学建模比赛的本科组赛题大体可以分为离散型与连续型这两种，进一步可以细分为<strong>评价类问题、优化类问题、预测类问题</strong>，每一类问题都有其适合的基础工具和数据处理方法可以辅助你们的模型，或与你们的模型相结合来解决问题。例如在评价类的问题中常常使用到：<strong>主成分分析法、TOPSIS分析法、层次分析法、模糊综合评价法、熵权法、数据包络分析、灰色关联等</strong>，这些都是负责建模的同学需要去了解和掌握的，对模型的建立、充实和实现有很大的帮助。因此负责建模的队员可以去针对自己队伍擅长、适合的题目（离散型或连续型），来针对性地学习这些辅助模型与方法。</p>
<p>但注意，这些方法只能作为模型实现的一部分或是模型的辅助，不能通过拼凑这些方法来建立你们的模型，例如<strong>建立基于灰色关联的灰色预测模型</strong>，又如<strong>基于主成分分析与层次分析的评价模型</strong>，这样的模型不是好模型，因为这些都只是基础的数据处理方法和数据分析办法，不能作为解决题目问题的最终模型。</p>
<h1 id="三、关于写作"><a href="#三、关于写作" class="headerlink" title="三、关于写作"></a>三、关于写作</h1><p>数模论文的基本格式一般是这样的：首先是标题，然后是摘要与关键词，接下来是问题重述，下面是模型假设与符号规定，之后就是你们对问题的具体分析以及你们模型的建立和结果，最后列出参考文献与程序代码。</p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>论文的标题要避免口语化，尽量简明扼要，并突出自己的模型和方法，例如：基于XXX模型的XXX问题（研究）</p>
<h2 id="摘要与关键词"><a href="#摘要与关键词" class="headerlink" title="摘要与关键词"></a>摘要与关键词</h2><p>前面有说到，摘要非常重要，摘要是全文的总述，要包含对问题的分析、体现你们的思考过程、模型建立的过程，不要有任何的废话，也不要写的太短（例如本文的概述），也不要太长（摘要+关键词不能超过一页）。<br>关键词可以包含你们模型的求解算法、模型的实现原理。</p>
<h2 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h2><p>按照你们的理解，重新描述一遍题目的内容、需求、你们的思考过程、初步的想法。</p>
<h2 id="模型假设与符号规定"><a href="#模型假设与符号规定" class="headerlink" title="模型假设与符号规定"></a>模型假设与符号规定</h2><p>模型假设是对理想情况的预设，例如在2015年的A题太阳影子定位模型中可以做出如下假设：</p>
<ul>
<li>假设太阳光为平行光，没有折射</li>
<li>假设海拔高度可以忽略</li>
<li>…</li>
</ul>
<p>符号规定一般以表格的形式呈现，其中列出的符号常常是全文通用的一般性符号，在符号规定中列出的符号，于正文中第一次出现的时候还要做进一步的解释，例如在符号规定中规定了密度（<script type="math/tex">\rho_s</script>）、质量(<script type="math/tex">M_s</script>)和体积(<script type="math/tex">V_s</script>)符号，那么在正文中第一次出现计算密度的公式时，要再次解释这几个符号的具体含义，例如：</p>
<hr>
<p>…</p>
<script type="math/tex; mode=display">
\rho_s=\frac{M_s}{V_s}</script><p>其中<script type="math/tex">\rho_s</script>表示<script type="math/tex">Sun</script>的密度，<script type="math/tex">M_s</script>表示<script type="math/tex">Sun</script>的质量，<script type="math/tex">V_s</script>表示<script type="math/tex">Sun</script>的体积。<br>…</p>
<hr>
<h2 id="问题的分析以及你们的模型"><a href="#问题的分析以及你们的模型" class="headerlink" title="问题的分析以及你们的模型"></a>问题的分析以及你们的模型</h2><p>这一部分可以根据需要自己进行结构的调整，这里例举2015年国赛A题一篇优秀论文的对应结构：</p>
<hr>
<p><strong>标题</strong><br><strong>摘要与关键词</strong><br><strong>一、问题重述</strong><br><strong>二、问题分析</strong><br><strong>三、模型假设与符号约定</strong><br><strong>四、模型的建立与求解</strong><br><strong>（一）问题一的模型建立与求解</strong><br><strong>1.1问题1模型的建立</strong><br><strong>1.2对xxx情况的具体分析</strong><br><strong>1.3问题1模型的求解</strong><br><strong>（二）问题二的模型建立与求解</strong><br><strong>2.1问题2模型的建立</strong><br><strong>2.2问题2模型的求解</strong><br>…<br><strong>五、模型的改进与评价</strong><br><strong>六、参考文献</strong><br><strong>七、附录</strong></p>
<hr>
<p>写作的平台首选Word，次选WPS，如对自己队伍有较高的版面效果要求则可以学习LaTex文学编程，其优点在于渲染出的数学公式和数学符号非常的漂亮，但上手是有一定门槛的。<br>在写论文的过程中，使用Word、WPS排版的时候，要合理使用<strong>样式</strong>功能，最好选择一篇你们队伍认为好看的论文制作相应的论文模板，提前准备好整体架构、文字样式，让你们的论文更清晰更美观，同时也为正式的比赛节省时间。</p>
<p>下面给出LaTex的一些资源：</p>
<p><a href="http://pan.baidu.com/s/1jHfUzWy" target="_blank" rel="noopener">TeXliv 2015 离线安装包 (2cj2)</a></p>
<p><a href="http://texstudio.sourceforge.net/" target="_blank" rel="noopener">LaTex 编辑器 (TeXstudio)：</a></p>
<p><a href="http://www.mohu.org/info/symbols/symbols.htm" target="_blank" rel="noopener">常用数学符号的 LaTeX 表示方法：</a></p>
<p><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">手写识别转 LaTex 符号：</a></p>
<h1 id="四、其他资源"><a href="#四、其他资源" class="headerlink" title="四、其他资源"></a>四、其他资源</h1><p><a href="https://bbs.pinggu.org/" target="_blank" rel="noopener">数据获取渠道：经管之家</a></p>
<p><a href="http://www.drcnet.com.cn/www/int/" target="_blank" rel="noopener">数据获取渠道：国研网</a></p>
<p><a href="http://epub.cnki.net/" target="_blank" rel="noopener">论文参考渠道：中国知网</a></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
        <category>数学建模</category>
      </categories>
  </entry>
  <entry>
    <title>基于HSV肤色提取与连通区域过滤的人脸定位算法（Matlab）</title>
    <url>/2018/12/15/faceDetact/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>本篇记录了利用基于HSV颜色模型的肤色提取与连通区域过滤实现图片的人脸定位，附带知识的介绍略烦多，附带Matlab相关程序代码。</p>
</blockquote>
<hr>
<p>（开幕雷击：本文只是鄙人几年前接触数学建模初期时关于人脸识别题目的一些碎片记录，最终整合起来的效果并不好，不具备实际可用性，因此不要对本文模型效果抱有太大期待。此外几点补充说明见文末。）</p>
<h1 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h1><h2 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h2><ul>
<li><strong>1.1 灰度化</strong><br>　在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般有分量法 最大值法平均值法加权平均法四种方法对彩色图像进行灰度化。<br>$Matlab:$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">I = imread(<span class="string">'img.jpg'</span>);</span><br><span class="line">I2 = rgb2gray(I);</span><br><span class="line">subpolt(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I),title(<span class="string">'原图'</span>);</span><br><span class="line">subpolt(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(I2),title(<span class="string">'灰度化'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/15/faceDetact/1.jpg" alt="图像的灰度化"></p>
<a id="more"></a>
<ul>
<li><strong>1.2 锐化滤波</strong><br>　应用锐化可以快速聚焦模糊边缘，提高图像中某一部位的清晰度或者焦距程度，使图像特定区域的色彩更加<br>鲜明。<br>$Matlab:$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">I = imread(<span class="string">'img.jpg'</span>);</span><br><span class="line">I2 = double(rgb2gray(I));</span><br><span class="line">H = [<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>,<span class="number">1</span> <span class="number">-41</span>,<span class="number">0</span> <span class="number">1</span> <span class="number">0</span>];</span><br><span class="line">J = conv2(I2,H,<span class="string">'same'</span>);</span><br><span class="line">K = I2-J;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(rgb2gray(I)),title(<span class="string">'原图灰度化'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(K,[]),title(<span class="string">'锐化滤波'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/15/faceDetact/2.jpg" alt="锐化滤波"></p>
<ul>
<li><strong>1.3 中值滤波</strong><br>　中值滤波法是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值。<br>　中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个邻域中各点值的中值代替，让周围的像素值接近的真实值，从而消除孤立的噪声点。<br>$Matlab:$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">I = imread(<span class="string">'img.jpg'</span>);</span><br><span class="line">I2 = medfilt2(rgb2gray(I),[<span class="number">9</span> <span class="number">9</span>]); 	<span class="comment">%9×9中值滤波</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(rgb2gray(I)),title(<span class="string">'原图灰度化'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(I2,[]),title(<span class="string">'9×9中值滤波'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/15/faceDetact/3.jpg" alt="中值滤波"></p>
<ul>
<li><strong>1.4 二值化</strong><br>　图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。<br>$Matlab:$</li>
</ul>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">I = imread(<span class="string">'img.jpg'</span>);</span><br><span class="line">I2 = rgb2gray(I);	<span class="comment">%灰度化</span></span><br><span class="line">thresh = graythresh(I2);     <span class="comment">%从原图确定二值化阈值；</span></span><br><span class="line">I3 = im2bw(I2,thresh);	<span class="comment">%二值化</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(I2),title(<span class="string">'原图灰度化'</span>);</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(I3),title(<span class="string">'二值化'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/15/faceDetact/4.jpg" alt="二值化"></p>
<ul>
<li><strong>1.5 形态学操作（腐蚀、膨胀、开操作、闭操作）</strong><br><a href="https://blog.csdn.net/Fishmemory/article/details/53113746?locationNum=6&amp;fps=1" target="_blank" rel="noopener">点我学习详细原理</a></li>
</ul>
<h2 id="几种颜色模型"><a href="#几种颜色模型" class="headerlink" title="几种颜色模型"></a>几种颜色模型</h2><ul>
<li><strong>2.1 RGB模型</strong><br>　最典型、最常用的面向硬件设备的彩色模型是三基色模型，即RGB模型。电视、摄像机和彩色扫描仪都是根据RGB模型工作的。RGB颜色模型建立在笛卡尔坐标系统里，其中三个坐标轴分别代表R、G、B，如图1所示，RGB模型是一个立方体，原点对应黑色，离原点最远的顶点对应白色。RGB是加色，是基于光的叠加的，红光加绿光加蓝光等于白光。应用于显示器这样的设备。<br><img src="/2018/12/15/faceDetact/5.png" alt="RGB模型"><br>　RGB颜色空间的主要缺点是不直观，从R、G、B的值中很难知道该值所代表颜色的认知属性，因此RGB颜色空间不符合人对颜色的感知心理。另外，RGB颜色空间是最不均匀的颜色空间之一，两种颜色之间的知觉差异不能采用该颜色空间中两个颜色点之间的距离来表示。</li>
<li><strong>2.2 YCrCb模型</strong><br>YCbCr模型中，Y是指亮度分量，Cb指蓝色色度分量，而Cr指红色色度分量。人的肉眼对视频的Y分量更敏感，因此在通过对色度分量进行子采样来减少色度分量后，肉眼将察觉不到的图像质量的变化。YCbCr模型常用与肤色检测中。<br>RGB转换YCbCr公式：<script type="math/tex; mode=display">Y=0.299R+0.587G+0.114B</script><script type="math/tex; mode=display">Cb=0.564(B-Y)</script><script type="math/tex; mode=display">Cr=0.713(R-Y)</script> YCbCr转换RGB公式：<script type="math/tex; mode=display">R=Y+1.402Cr</script><script type="math/tex; mode=display">G=Y-0.344Cb-0.714Cr</script><script type="math/tex; mode=display">B=Y+1.772Cb</script></li>
<li><strong>2.3 HSV模型</strong><br>　HSV模型比HSI模型更与人类对颜色的感知接近。H代表色调，S代表饱和度，V代表亮度值。HSV模型的坐标系统可以是圆柱坐标系统，但一般用六棱锥来表示，如图3所示，与HSI模型比较相似。可以通过比较HSI、HSV与RGB空间的转换公式，来比较HSI与HSV的区别。<br>　<img src="/2018/12/15/faceDetact/6.jpg" alt="HSV模型"><br>　RGB空间转换HSV空间：<br>\begin{equation}<br>F=\left{<br>\begin{array}{rcl}<br>\arccos{\frac{(R-G)+(R-B)}{2\sqrt{(R-G)^2+(R-B)(G-B)}}} &amp; &amp; {B \leq G}\<br>2\pi-\arccos{\frac{(R-G)+(R-B)}{2\sqrt{(R-G)^2+(R-B)(G-B)}}} &amp; &amp; {B &gt; G}\<br>\end{array} \right.<br>\end{equation}</li>
</ul>
<p>\begin{equation}<br>S=\frac{\max(R,G,B)-\min(R,G,B)}{\max(R,G,B)}<br>\end{equation}</p>
<p>\begin{equation}<br>V=\frac{\max(R,G,B)}{255}<br>\end{equation}</p>
<h2 id="连通区域"><a href="#连通区域" class="headerlink" title="连通区域"></a>连通区域</h2><p>在图像中，最小的单位是像素，每个像素周围有8个邻接像素，常见的邻接关系有2种：4邻接与8邻接。4邻接一共4个点，即上下左右，如下左图所示。8邻接的点一共有8个，包括了对角线位置的点，如下右图所示。<br><img src="/2018/12/15/faceDetact/8.jpg" alt="连通区域"><br>如果像素点A与B邻接，我们称A与B连通，于是我们不加证明的有如下的结论：<br>　<br>如果A与B连通，B与C连通，则A与C连通。</p>
<p>在视觉上看来，彼此连通的点形成了一个区域，而不连通的点形成了不同的区域。这样的一个所有的点彼此连通点构成的集合，我们称为一个连通区域。<br>　<br>下面这符图中，如果考虑4邻接，则有3个连通区域；如果考虑8邻接，则有2个连通区域。（注：图像是被放大的效果，图像正方形实际只有4个像素）。<br><img src="/2018/12/15/faceDetact/9.png" alt="连通区域"></p>
<hr>
<h1 id="二、图像人脸粗提取"><a href="#二、图像人脸粗提取" class="headerlink" title="二、图像人脸粗提取"></a>二、图像人脸粗提取</h1><h2 id="1-HSV空间的肤色分割"><a href="#1-HSV空间的肤色分割" class="headerlink" title="1) HSV空间的肤色分割"></a>1) HSV空间的肤色分割</h2><p>彩色图像在RGB空间中描述,三基色不仅代表颜色，还代表了亮度，由于周围环境光照的改变。进行处理时，先把图像在RGB空间转换成HSV空间，在HSV空间进行阈值分割。<br>设:</p>
<script type="math/tex; mode=display">I=I\{R,G,B\}</script><p>是一幅彩色人脸图像点阵，经过HSV肤色分割得到分割图</p>
<script type="math/tex; mode=display">I_2=I\{H,S,V\}</script><p><img src="/2018/12/15/faceDetact/10.png" alt="HSV肤色分割"></p>
<p>$Matlab: skin.m$<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 根据当前点的Cb Cr值判断是否为肤色  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">skin</span><span class="params">(Y,Cb,Cr)</span>  </span></span><br><span class="line"><span class="comment">% 参数  </span></span><br><span class="line">a = <span class="number">25.39</span>;  </span><br><span class="line">b = <span class="number">14.03</span>;  </span><br><span class="line">ecx = <span class="number">1.60</span>;  </span><br><span class="line">ecy = <span class="number">2.41</span>;  </span><br><span class="line">sita = <span class="number">2.53</span>;  </span><br><span class="line">cx = <span class="number">109.38</span>;  </span><br><span class="line">cy = <span class="number">152.02</span>;  </span><br><span class="line">xishu = [cos(sita) sin(sita);-sin(sita) cos(sita)];  </span><br><span class="line"><span class="comment">% 如果亮度大于230，则将长短轴同时扩大为原来的1.1倍  </span></span><br><span class="line"><span class="keyword">if</span>(Y &gt; <span class="number">230</span>)  </span><br><span class="line">    a = <span class="number">1.1</span>*a;  </span><br><span class="line">    b = <span class="number">1.1</span>*b;  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% 根据公式进行计算  </span></span><br><span class="line">Cb = double(Cb);  </span><br><span class="line">Cr = double(Cr);  </span><br><span class="line">t = [(Cb-cx);(Cr-cy)];  </span><br><span class="line">temp = xishu*t;  </span><br><span class="line">value = (temp(<span class="number">1</span>) - ecx)^<span class="number">2</span>/a^<span class="number">2</span> + (temp(<span class="number">2</span>) - ecy)^<span class="number">2</span>/b^<span class="number">2</span>;  </span><br><span class="line"><span class="comment">% 大于1则不是肤色，返回0；否则为肤色，返回1  </span></span><br><span class="line"><span class="keyword">if</span> value &gt; <span class="number">1</span>  </span><br><span class="line">    result = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    result = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-边缘强化"><a href="#2-边缘强化" class="headerlink" title="2) 边缘强化"></a>2) 边缘强化</h2><p>在彩色测试图的R、G、B通道中,人脸肤色的像素多数集中在B通道,而且B通道含的背景像素最少,所以单选择在B通道进行边缘强化处理.<br>彩色人脸图像点阵$I$的$B$通道：</p>
<script type="math/tex; mode=display">I_1=I\{0,0,B\}</script><p>用一种高频增强算子</p>
<script type="math/tex; mode=display">H=\left[
\begin{array}{ccc}
0&-1&0\\
-1&2&-1\\
0&-1&0
\end{array}
\right]</script><p>与$B$通道分量$I_1$进行卷积锐化出边界图$I_3$<br><img src="/2018/12/15/faceDetact/11.png" alt="边缘强化"><br>用锐化后的边界图$I_3$和HSV肤色分割图$I_2$逻辑上相与得到边缘强化图$I_4$。</p>
<script type="math/tex; mode=display">
I_4=I_3∧I_2</script><h2 id="4-中值滤波"><a href="#4-中值滤波" class="headerlink" title="4)中值滤波"></a>4)中值滤波</h2><p>中值滤波能够快速滤除一些细小的、零散的区域，对边缘强化图$I_4$进行中值滤波处理能够清除图中细碎的背景得到$I_5$。<br><img src="/2018/12/15/faceDetact/12.png" alt="中值滤波"></p>
<h1 id="三、连通区初步过滤条件"><a href="#三、连通区初步过滤条件" class="headerlink" title="三、连通区初步过滤条件"></a>三、连通区初步过滤条件</h1><p>连通区的相关介绍和连通区的提起在上文已经有所介绍，下图是提取连通区的效果：<br><img src="/2018/12/15/faceDetact/13.png" alt="连通区"><br>脸区域形状上大体与椭圆相似，而中值滤波后的边缘强化图中除了人脸的椭圆区域外，还有一些其它形状的区域，这些其它的形状基本上是非人脸区域。这些区域基本可以分为三角区域、矩形区域、细长的和弯曲的区域和面积相对较小的区域等4种。<br>针对这4种区域，分别采用面积密度、长宽比、致密度和面积滤波等4种几何形状特征的方法进行背景清除。</p>
<h2 id="1-面积密度"><a href="#1-面积密度" class="headerlink" title="1) 面积密度"></a>1) 面积密度</h2><p>区域的面积与其最小外接矩形的面积的比值：<br>\begin{equation}<br>M=\frac{area(i)}{A<em>{MER}^{(i)}}<br>\end{equation}<br>当区域为矩形时，比值(M)最大为1；当区域为圆形区域时，比值为$\frac{\pi}{4}$；当区域为细长的、弯曲的物体时，比例变小。<br>当选取比值(M)= 0.4时，即可除去细长弯曲的区域和细长倾斜的区域。其中<br>\begin{equation}<br>area(i)=\sum</em>{x=1}^{row}\sum<em>{y=1}^{col}l(x,y)<br>\end{equation}<br>\begin{equation}<br>A</em>{MER}=(low_i-top_i)(right_i-left_i)<br>\end{equation}<br>对于二值图而言，1表示物体，0表示背景，面积就是统计每一个连通区域$L(x,y)= 1$的个数。</p>
<h2 id="2-长宽比"><a href="#2-长宽比" class="headerlink" title="2) 长宽比"></a>2) 长宽比</h2><p>利用区域最小外接矩形长和宽的比例清除一些不符合正常的人脸比例的区域。<br>\begin{equation}<br>N=\frac{low_i-top_i}{right_i-left_i}<br>\end{equation}</p>
<h2 id="3-致密度"><a href="#3-致密度" class="headerlink" title="3) 致密度"></a>3) 致密度</h2><p>利用致密度可以除去一些近似矩形和三角形的区域,保留与人脸椭圆有相似性的区域。<br>\begin{equation}<br>N=\frac{c_i^2}{area_i}<br>\end{equation}<br>通过实验资料，r设定阈值小于4或大于16就可以滤除一些矩形和三角区域。</p>
<h2 id="4-面积滤波"><a href="#4-面积滤波" class="headerlink" title="4) 面积滤波"></a>4) 面积滤波</h2><p>采用相对重要性滤波的方法来滤除较小的面积区域。用肤色最大的面积与整幅图的面积相比，然后设定一个阈值(R)，当面积比小于某个值,就把某些面积较小的区域滤除。<br>\begin{equation}<br>S=row \times col<br>\end{equation}<br>\begin{equation}<br>R=\frac{Max(area)}{S}<br>\end{equation}<br>根据测试资料，将阈值R设为0.1，当R≥10%时，把面积小于95的区域滤除；当R≤10%时，把面积小于70的区域滤除。<br>连通区提取效果：<br><img src="/2018/12/15/faceDetact/14.png" alt="连通区提取"><br>应用粗过滤条件后的人脸区域定位效果如图：<br><img src="/2018/12/15/faceDetact/15.png" alt="粗过滤"></p>
<p>$Matab: facedetection.m$<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">facedetection</span><span class="params">(img_name)</span>  </span></span><br><span class="line"><span class="comment">% 读取RGB图像  </span></span><br><span class="line">I = imread(img_name);  </span><br><span class="line"><span class="comment">% 转换为灰度图像  </span></span><br><span class="line">gray = rgb2gray(I);  </span><br><span class="line"><span class="comment">% 将图像转化为YCbCr颜色空间  </span></span><br><span class="line">YCbCr = rgb2ycbcr(I);  </span><br><span class="line"><span class="comment">% 获得图像宽度和高度  </span></span><br><span class="line">heigth = <span class="built_in">size</span>(gray,<span class="number">1</span>);  </span><br><span class="line">width = <span class="built_in">size</span>(gray,<span class="number">2</span>);  </span><br><span class="line"><span class="comment">% 根据肤色模型将图像二值化  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:heigth  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:width  </span><br><span class="line">        Y = YCbCr(<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="number">1</span>);  </span><br><span class="line">        Cb = YCbCr(<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="number">2</span>);  </span><br><span class="line">        Cr = YCbCr(<span class="built_in">i</span>,<span class="built_in">j</span>,<span class="number">3</span>);  </span><br><span class="line">        <span class="keyword">if</span>(Y &lt; <span class="number">80</span>)  </span><br><span class="line">            gray(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">if</span>(skin(Y,Cb,Cr) == <span class="number">1</span>)  </span><br><span class="line">                gray(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="number">255</span>;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                gray(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% 二值图像形态学处理  </span></span><br><span class="line">SE=strel(<span class="string">'arbitrary'</span>,<span class="built_in">eye</span>(<span class="number">5</span>));    </span><br><span class="line"><span class="comment">%gray = bwmorph(gray,'erode');  </span></span><br><span class="line"><span class="comment">% imopen先腐蚀再膨胀  </span></span><br><span class="line">gray = imopen(gray,SE);  </span><br><span class="line"><span class="comment">% imclose先膨胀再腐蚀  </span></span><br><span class="line"><span class="comment">%gray = imclose(gray,SE);  </span></span><br><span class="line">imshow(gray);  </span><br><span class="line"><span class="comment">% 取出图片中所有包含白色区域的最小矩形  </span></span><br><span class="line">[L,num] = bwlabel(gray,<span class="number">8</span>);  </span><br><span class="line">STATS = regionprops(L,<span class="string">'BoundingBox'</span>);  </span><br><span class="line"><span class="comment">% 存放经过筛选以后得到的所有矩形块  </span></span><br><span class="line">n = <span class="number">1</span>;  </span><br><span class="line">result = <span class="built_in">zeros</span>(n,<span class="number">4</span>);  </span><br><span class="line">figure,imshow(I);  </span><br><span class="line">hold on;  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:num  </span><br><span class="line">    box = STATS(<span class="built_in">i</span>).BoundingBox;  </span><br><span class="line">    x = box(<span class="number">1</span>);    <span class="comment">%矩形坐标x  </span></span><br><span class="line">    y = box(<span class="number">2</span>);    <span class="comment">%矩形坐标y  </span></span><br><span class="line">    w = box(<span class="number">3</span>);    <span class="comment">%矩形宽度w  </span></span><br><span class="line">    h = box(<span class="number">4</span>);    <span class="comment">%矩形高度h  </span></span><br><span class="line">    <span class="comment">% 宽度和高度的比例  </span></span><br><span class="line">    ratio = h/w;  </span><br><span class="line">    ux = uint8(x);  </span><br><span class="line">    uy = uint8(y);  </span><br><span class="line">    <span class="keyword">if</span> ux &gt; <span class="number">1</span>  </span><br><span class="line">        ux = ux - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">if</span> uy &gt; <span class="number">1</span>  </span><br><span class="line">        uy = uy - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="comment">% 可能是人脸区域的矩形应满足以下条件：  </span></span><br><span class="line">    <span class="comment">%   1、高度和宽度必须都大于20，且矩形面积大于400  </span></span><br><span class="line">    <span class="comment">%   2、高度和宽度比率应该在范围（0.6,2）内  </span></span><br><span class="line">    <span class="comment">%   3、函数findeye返回值为1  </span></span><br><span class="line">    <span class="keyword">if</span> w &lt; <span class="number">20</span> || h &lt; <span class="number">20</span> || w*h &lt; <span class="number">400</span>  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    <span class="keyword">elseif</span> ratio &lt; <span class="number">2</span> &amp;&amp; ratio &gt; <span class="number">0.6</span> &amp;&amp; findeye(gray,ux,uy,w,h) == <span class="number">1</span>  </span><br><span class="line">        <span class="comment">% 记录可能为人脸的矩形区域  </span></span><br><span class="line">        result(n,:) = [ux uy w h];  </span><br><span class="line">        n = n+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% 对可能是人脸的区域进行标记  </span></span><br><span class="line"><span class="keyword">if</span>  <span class="built_in">size</span>(result,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; result(<span class="number">1</span>,<span class="number">1</span>) &gt; <span class="number">0</span>  </span><br><span class="line">    rectangle(<span class="string">'Position'</span>,[result(<span class="number">1</span>,<span class="number">1</span>),result(<span class="number">1</span>,<span class="number">2</span>),result(<span class="number">1</span>,<span class="number">3</span>),result(<span class="number">1</span>,<span class="number">4</span>)],<span class="string">'EdgeColor'</span>,<span class="string">'r'</span>);  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    <span class="comment">% 如果满足条件的矩形区域大于1则再根据其他信息进行筛选  </span></span><br><span class="line">    <span class="keyword">for</span> m = <span class="number">1</span>:<span class="built_in">size</span>(result,<span class="number">1</span>)  </span><br><span class="line">        m1 = result(m,<span class="number">1</span>);  </span><br><span class="line">        m2 = result(m,<span class="number">2</span>);  </span><br><span class="line">        m3 = result(m,<span class="number">3</span>);  </span><br><span class="line">        m4 = result(m,<span class="number">4</span>);  </span><br><span class="line">        <span class="comment">% 标记最终的人脸区域  </span></span><br><span class="line">        <span class="keyword">if</span> m1 + m3 &lt; width &amp;&amp; m2 + m4 &lt; heigth  </span><br><span class="line">            rectangle(<span class="string">'Position'</span>,[m1,m2,m3,m4],<span class="string">'EdgeColor'</span>,<span class="string">'r'</span>);  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="四、连通区深度过滤"><a href="#四、连通区深度过滤" class="headerlink" title="四、连通区深度过滤"></a>四、连通区深度过滤</h1><p>对于上图可以看出，经过上述的背景消除算法滤除背景时，发现中间人物的手部区域与脸部特征近似，使用简单的粗过滤方法可能难以过滤完全。容易出现将手部误认定为脸部的可能，为了消除手部的干扰，在此定位结果的基础上采用几何匹配算法，将找不到眼睛的区域进行过滤，这样便可消除手部的影响，从而精确的将人脸定位。</p>
<ul>
<li><strong>基于几何匹配算法的眼部搜索</strong></li>
</ul>
<ol>
<li>将一对连通区从图像区域中提取出来(设为X和Y)</li>
<li>规定X在Y的左边；X与Y连线倾角在$[-\frac{\pi}{4},\frac{\pi}{4}]$之间</li>
<li>设评价函数为$E$，计算它们作为一对眼睛的评价函数$E$，如果$E$超过一定的阈值, 那么认为这一对连通区所框选的对象很可能是一对眼睛。<br>定义评价函数：<br>\begin{equation}<br>E=exp{-4.8[0.4(S_1-S_2)^2+0.2(S_1+S_2-1)^2+0.2(\theta_1-\theta)^2+0.2(\theta_2-\theta)^2]}<br>\end{equation}<br>类似的，可以探索嘴部的评价函数，最终有三个连通区提取到了眼嘴特征，定位如下：<br><img src="/2018/12/15/faceDetact/16.png" alt="嘴眼"><br>不难得到经过深度过滤后的人脸定位结果：<br><img src="/2018/12/15/faceDetact/17.png" alt="结果"></li>
</ol>
<p>$Matlab: findeye.m$<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 判断二值图像中是否含有可能是眼睛的块  </span></span><br><span class="line"><span class="comment">%   bImage----二值图像  </span></span><br><span class="line"><span class="comment">%   x---------矩形左上角顶点X坐标  </span></span><br><span class="line"><span class="comment">%   y---------矩形左上角顶点Y坐标  </span></span><br><span class="line"><span class="comment">%   w---------矩形宽度  </span></span><br><span class="line"><span class="comment">%   h---------矩形长度  </span></span><br><span class="line"><span class="comment">% 如果有则返回值eye等于1，否则为0  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eye</span> = <span class="title">findeye</span><span class="params">(bImage,x,y,w,h)</span>  </span></span><br><span class="line"><span class="comment">% 根据矩形相关属性得到二值图像中矩形区域中的数据  </span></span><br><span class="line"><span class="comment">% 存放矩形区域二值图像信息  </span></span><br><span class="line">part = <span class="built_in">zeros</span>(h,w);  </span><br><span class="line"><span class="comment">% 二值化  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = y:(y+h)  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = x:(x+w)  </span><br><span class="line">        <span class="keyword">if</span> bImage(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">0</span>  </span><br><span class="line">            part(<span class="built_in">i</span>-y+<span class="number">1</span>,<span class="built_in">j</span>-x+<span class="number">1</span>) = <span class="number">255</span>;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            part(<span class="built_in">i</span>-y+<span class="number">1</span>,<span class="built_in">j</span>-x+<span class="number">1</span>) = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">[L,num] = bwlabel(part,<span class="number">8</span>);  </span><br><span class="line"><span class="comment">% 如果区域中有两个以上的矩形则认为有眼睛  </span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">2</span>  </span><br><span class="line">    <span class="built_in">eye</span> = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">    <span class="built_in">eye</span> = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h1><p>[1] <a href="https://blog.csdn.net/Fishmemory/article/details/53113746?locationNum=6&amp;fps=1" target="_blank" rel="noopener">形态学-腐蚀、膨胀、开操作、闭操作</a><br>[2] <a href="https://blog.csdn.net/u012507022/article/details/51523385" target="_blank" rel="noopener">图像处理中常用的彩色模型</a><br>[3] <a href="https://blog.csdn.net/cooelf/article/details/26581539" target="_blank" rel="noopener">OpenCV：二值图像连通区域分析与标记算法实现</a></p>
<h1 id="六、深入阅读"><a href="#六、深入阅读" class="headerlink" title="六、深入阅读"></a>六、深入阅读</h1><p>[1] 张朝阳,潘保昌,郑胜林,彭绍湖. 基于消除背景的人脸定位方法. 广东工业大学学报.24（2）：91-106,2007<br>[2] 倪健,董强,管国栋. 基于几何特征的人脸定位算法的改进.《微计算机信息》(测 控 自 动 化).22（5-1）：241-242，2006</p>
<h1 id="七、2021-05-26-补充说明"><a href="#七、2021-05-26-补充说明" class="headerlink" title="七、2021.05.26 补充说明"></a>七、2021.05.26 补充说明</h1><p>对于评论区中反馈的问题此处统一作补充说明，本文只是鄙人几年前<strong>接触数学建模初期时</strong>关于人脸识别题目快餐化学习后的一些碎片记录，<strong>最终整合起来的效果并不好，因此==不要对本文模型效果抱有太大期待==</strong>。</p>
<ol>
<li>本文HSV在肤色分割中起到辅助分割的作用，肤色分割由Cb、Cr和Hue共同完成，若去除hue条件则例图会出现错误识别（见下图）。该模型关于肤色和背景环境色的鲁棒性均较差，本例中的人物图片肤色正、环境色干扰小，故均能正确框选人脸，但换用其它图片不能保证可用性。<br><img src="/2018/12/15/faceDetact/21.png" alt=""></li>
<li>本文眼睛识别是基于连通区配对的，与HSV、YCbCr均无关，识别效果不好，在本模型中仅起到辅助筛选，并不能够很可靠地定位眼睛，有眼睛的部分不一定能正确地标注，一些没有眼睛的区域也可能被错误的标记为有眼睛，因此只能辅助性地筛掉一些无人脸区域，筛除成功率并不高。<br><img src="/2018/12/15/faceDetact/18.png" alt=""></li>
<li>本文文中代码不全，我将把完整代码和示例图片打包上传百度网盘，有需要的朋友请在文末自取。模型入口函数为<code>main_findFace(&#39;imgName&#39;, 0.5)</code>，参数一为图片相对路径，参数二为图片缩放比例。附件图片较大，为了更好的识别效果和速度请合理设置缩放运行。<br><img src="/2018/12/15/faceDetact/20.png" alt=""><br><img src="/2018/12/15/faceDetact/19.png" alt=""></li>
<li>本文不再更新，不再回复评论。</li>
</ol>
<p><strong>Matlab代码及测试图片打包：</strong></p>
<p>链接: <a href="https://pan.baidu.com/s/1m8_cPKAyBaMGtCzjA7cFUQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1m8_cPKAyBaMGtCzjA7cFUQ</a></p>
<p>提取码: 2naa</p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次艰难的 Ubuntu 双系统安装过程及问题的解决</title>
    <url>/2018/12/08/ubuntuInstall/</url>
    <content><![CDATA[<blockquote>
<p>为了进一步学习的需要，这周一准备装上 win10+ubuntu 双系统，但中途出现了各种问题，经反复重装、网上找资料前前后后三天，终于成功安装。虽然之前已在虚拟机中装过了 Kali Linux 和 Ubuntu，但原生体验非常差，因此打算安装双系统。一方面沉浸感更强，体验更好，另一方面，凑一方面。<br>本篇记录了安装流程，以及安装过程中遇到的问题和解决办法。</p>
</blockquote>
<p><img src="/2018/12/08/ubuntuInstall/0.jpg" alt=""></p>
<hr>
<h2 id="环境-win10-GPT-UEFI"><a href="#环境-win10-GPT-UEFI" class="headerlink" title="环境: win10 (GPT + UEFI)"></a>环境: win10 (GPT + UEFI)</h2><hr>
<h2 id="Part-I-准备工作"><a href="#Part-I-准备工作" class="headerlink" title="Part I 准备工作"></a>Part I 准备工作</h2><h3 id="一、制作-U-盘启动盘"><a href="#一、制作-U-盘启动盘" class="headerlink" title="一、制作 U 盘启动盘"></a>一、制作 U 盘启动盘</h3><p>&emsp;&emsp;首先准备 U 盘一个，并下载好你要安装的 Ubuntu 系统镜像文件，在此用官方推荐的 <strong>Rufus</strong> 工具制作 U 盘启动盘。<br>&emsp;&emsp;电脑插上 U 盘之后，Rufus 就会自动检测并给出默认的配置信息，其中磁盘分区模式选择 GPT，目标系统类型为 UEFI（近两年的新电脑一般都是 GPT + UEFI，当然不排除你的电脑是 MBR + LEGACY，如果是的话就对应选择好，参考对应文章安装）</p>
<a id="more"></a>
<blockquote>
<p>注：下图是我已经制作好了 U 盘启动盘后的 Rufus 界面截图，因此分区类型和目标系统类型是灰色的，开始按钮也是禁止状态，由此也可以看出，我制作的 U 盘是 GPT 分区类型，系统类型为 UEFI。</p>
</blockquote>
<p><img src="/2018/12/08/ubuntuInstall/a.jpg" alt=""></p>
<p><strong>切记提前备份 U 盘数据，制作启动盘 U 盘原数据将被全部抹除</strong></p>
<p>开始后会接连弹出好几个警告，一路默认是就好。等待一小会进度条跑满后就制作完成，可以关闭 Refus 了。</p>
<h3 id="二、磁盘空间分配"><a href="#二、磁盘空间分配" class="headerlink" title="二、磁盘空间分配"></a>二、磁盘空间分配</h3><p>&emsp;&emsp;下面为 Ubuntu 系统分配磁盘空间。</p>
<p>&emsp;&emsp;win+x 打开磁盘管理工具，可以看到已有的磁盘信息，选择你想要提取空间的磁盘右键-&gt;压缩卷，设置好你想压缩的大小后点确定。压缩完成后可以看到电脑上多出了一块未分配磁盘，这里我是从机械硬盘分了 120G 出来，这样就完成分配了。<br>&emsp;&emsp;这里分完之后就不要动其他了，后续在安装时我们再做具体的分区。</p>
<blockquote>
<p>注：下图是我已经安装好了双系统之后回到 win 截的图，所以有很多盘并且没有分出来的空卷，你电脑上应该只有 C/D/E/F 这些盘，压缩出来的卷叫做“未分配”。</p>
</blockquote>
<p><img src="/2018/12/08/ubuntuInstall/b.jpg" alt=""></p>
<h3 id="三、BIOS-设置"><a href="#三、BIOS-设置" class="headerlink" title="三、BIOS 设置"></a>三、BIOS 设置</h3><p>&emsp;&emsp;插上之前制作好的 U 盘，下面我们重启电脑，在出现电脑品牌 Logo时按 F2 进入 BIOS 界面（一般是 F2，如果不是的话就试试其他 F 键，还有些电脑是 Delete 键），主要做以下两点设置：</p>
<ol>
<li><p><strong>设置第一启动项为你的 U 盘</strong></p>
<blockquote>
<p>当然你可以参考网上其他 U 盘启动方法，这里我们在 BIOS 的 Boot 页面，找到 Boot Opition，将你的 U 盘调整到第一项即可。  </p>
</blockquote>
</li>
<li><p><strong>关闭 Secure Boot 选项</strong></p>
<blockquote>
<p>在 BIOS 页面的 Advance 页面，找到 Secure Boot，修改为 Disable 即可，不同机器 Secure Boot 所在的页面或许有所区别，找找就好了。这一步关闭安全启动是为了 Ubuntu 系统能正常写入磁盘。  </p>
</blockquote>
</li>
</ol>
<p>&emsp;&emsp;上面两点完成后就可以保存并重启了，下面进入安装工作。</p>
<hr>
<h2 id="Part-II-安装工作"><a href="#Part-II-安装工作" class="headerlink" title="Part II 安装工作"></a>Part II 安装工作</h2><p>&emsp;&emsp;完成上述工作后，正常情况下重启你将进入 Ubuntu 的引导界面，第一项是体验而不安装，第二项是安装 Ubuntu，第三项是 OEM 安装，选第一或第二项都行，这里我们直接选 <strong>Install Ubuntu</strong> 进入安装界面。<br>&emsp;&emsp;前面都是常规的安装流程，可以不连接 wifi，第三方库也不用安装，关键在分区部分，网上已经有大量关于 Ubuntu 分区的介绍和建议，因此这里给出我自己的分配仅做参考：</p>
<ul>
<li>EFI - 逻辑分区 - 512MB</li>
<li>SWAP (交换空间) - 主分区 - 8G</li>
<li>/home - 主分区 - 30G</li>
<li>/usr - 主分区 - 75G</li>
<li>/ - 主分区 - 8G</li>
</ul>
<blockquote>
<p>完成分区后，下方的安装启动引导启的设备 <strong>务必选择 EFI 分区对应的设备！</strong>  </p>
</blockquote>
<p><img src="/2018/12/08/ubuntuInstall/1.png" alt=""></p>
<p>&emsp;&emsp;多看两眼确认后，点击现在安装，之后地点默认 Shanghai 就行了，设置好用户名和密码，下面就是等待完成安装了。完成安装会让你重启，拔掉 U 盘后重启即可。这时注意，我们还要进一次 BIOS，主要做以下两件事：</p>
<ol>
<li><p><strong>将第一启动项设置回之前的</strong></p>
<blockquote>
<p>你不调回来也行，不过还是建议在工作完成后将设置复位。  </p>
</blockquote>
</li>
<li><p><strong>系统启动顺序选择 Ubuntu</strong></p>
<blockquote>
<p>这里你的 BIOS 中可能没有这一项设置，并且重启没有出现 grub 界面直接进入了 win 系统，那么请参考网上其他文章进行 UEFI 启动引导。  </p>
</blockquote>
</li>
</ol>
<p>&emsp;&emsp;如果至此你能正常进入系统，且系统环境一切正常的话，那么恭喜你，顺利完成了 win + ubuntu 双系统安装，下面可以参考 Part IIII 中的推荐文章进行系统美化及进一步配置了；<br>若不然，下文列出了我在安装过程中所遇到的问题及解决办法，供参考。</p>
<hr>
<h2 id="Part-III-中途问题"><a href="#Part-III-中途问题" class="headerlink" title="Part III 中途问题"></a>Part III 中途问题</h2><h3 id="一、INFO-task-xxxxxx-634-blocked-for-more-than-120-seconds"><a href="#一、INFO-task-xxxxxx-634-blocked-for-more-than-120-seconds" class="headerlink" title="一、INFO: task xxxxxx: 634 blocked for more than 120 seconds."></a>一、INFO: task xxxxxx: 634 blocked for more than 120 seconds.</h3><p><img src="/2018/12/08/ubuntuInstall/2.png" alt=""></p>
<p>&emsp;&emsp;装完系统后，点击现在重启，直接卡住不动了，于是按电源键强制关机再开，卡在纯色暗紫屏，再重启及之后，都是如图所示的状态，错误信息大体是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO: task xxxxxx: 634 blocked for more than 120 seconds.</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;网上找了很多文章和帖子，比较一致的观点是：</p>
<blockquote>
<p>默认情况下， Linux会最多使用40%的可用内存作为文件系统缓存。当超过这个阈值后，文件系统会把将缓存中的内存全部写入磁盘， 导致后续的IO请求都是同步的。将缓存写入磁盘时，有一个默认120秒的超时时间。 出现上面的问题的原因是IO子系统的处理速度不够快，不能在120秒将缓存中的数据全部写入磁盘。IO系统响应缓慢，导致越来越多的请求堆积，最终系统内存全部被占用，导致系统失去响应。</p>
</blockquote>
<p><strong>解决办法：</strong></p>
<h4 id="STEP-1-进入-shell"><a href="#STEP-1-进入-shell" class="headerlink" title="STEP 1. 进入 shell"></a>STEP 1. 进入 shell</h4><ol>
<li><p>重启系统，按住 shift 键，来到 grub 界面</p>
</li>
<li><p>选择 <strong>ubuntu 高级选项</strong>，高亮移动到 <strong>recovery mode</strong> 那项</p>
</li>
<li><p>将 linux 那行的 ro 修改为 rw，即可写</p>
<blockquote>
<p>若以 ro 进入系统，文件系统将只是可读状态，无法修改内容<br><img src="/2018/12/08/ubuntuInstall/3.png" alt=""></p>
</blockquote>
</li>
<li><p>之后 Ctrl + X 或 F10 引导进入如下界面。<br><img src="/2018/12/08/ubuntuInstall/4.png" alt=""></p>
</li>
</ol>
<p>移至 <strong>root Drop to root shell prompt</strong> 那一行后按 Tab 键使光标移到 ok，然后回车即以 root 用户进入 ubuntu 系统，在窗口最下面即可输入命令。</p>
<h4 id="STEP-2-临时修改-ratio，缩小文件系统缓存大小："><a href="#STEP-2-临时修改-ratio，缩小文件系统缓存大小：" class="headerlink" title="STEP 2. 临时修改 ratio，缩小文件系统缓存大小："></a>STEP 2. 临时修改 ratio，缩小文件系统缓存大小：</h4><ol>
<li>在 shell 终端输入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep dirty</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/2018/12/08/ubuntuInstall/5.png" alt=""></p>
<blockquote>
<p>可以看到当前的设置为： vm.dirty_background_ratio = 10，vm.dirty_ratio = 20，并导致了我们遇到的错误。</p>
</blockquote>
<ol>
<li>输入下面两条命令将值修改为 10 和 5。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sbin/sysctl -w vm.dirty_ratio=10  </span><br><span class="line">./sbin/sysctl -w vm.dirty_background_ratio=5  `</span><br></pre></td></tr></table></figure>
<ol>
<li>改完后 ctrl+d 继续正常启动</li>
</ol>
<h4 id="STEP-3-永久修改"><a href="#STEP-3-永久修改" class="headerlink" title="STEP 3. 永久修改"></a>STEP 3. 永久修改</h4><p>&emsp;&emsp;终于进系统了，不过这是 recovery mode，并且刚才的修改只是临时操作，重启后还是会出现相同的问题。<br>为了一劳永逸，下面修改内核配置，以后就可以正常进系统了。</p>
<ol>
<li>Ctrl + Alt + T 打开终端</li>
<li>cd 进入 /etc 目录</li>
<li>sudo 编辑 <strong>sysctl.conf</strong> 文件</li>
<li><p>在最后添加下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vm.dirty_background_ratio = 5</span><br><span class="line">vm.dirty_ratio = 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存后重启系统，不再出现此错误了。</p>
</li>
</ol>
<h3 id="二、问题一成功跑过了，紧接着又是卡logo问题："><a href="#二、问题一成功跑过了，紧接着又是卡logo问题：" class="headerlink" title="二、问题一成功跑过了，紧接着又是卡logo问题："></a>二、问题一成功跑过了，紧接着又是卡logo问题：</h3><p><img src="/2018/12/08/ubuntuInstall/6.png" alt=""></p>
<p>原因：</p>
<blockquote>
<p>一般是显卡驱动原因。  </p>
</blockquote>
<p>&emsp;&emsp;解决过程：</p>
<ol>
<li><p>开机，在选择系统时，光标选中Ubuntu然后按下键盘的E键进入编辑模式，选择对Ubuntu进行编辑，找到“linux”，在本段的最后面加上 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acpi_osi=linux nomodeset</span><br></pre></td></tr></table></figure>
</li>
<li><p>附其他代码（显卡品牌）：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">acpi_osi=linux nomodeset (NVIDIA)   </span><br><span class="line">acpi_osi=linux i915.modeset=1 (Intel)   </span><br><span class="line">acpi_osi=linux xforcevesa (AMD)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着按F10保存并启动，就可以进入系统了。  </p>
</li>
<li>但是，这样有一个缺点，每次开始的时候都要重复以上操作，非常浪费时间。所在在进入Ubuntu之后，找到/boot/grub/grub.cfg 打开文件，找到刚刚修改的内容，加上相同的代码，保存就可以了。  </li>
</ol>
<h3 id="三、紧接着分辨率问题（只有800-600这一项分辨率选择）"><a href="#三、紧接着分辨率问题（只有800-600这一项分辨率选择）" class="headerlink" title="三、紧接着分辨率问题（只有800*600这一项分辨率选择）"></a>三、紧接着分辨率问题（只有800*600这一项分辨率选择）</h3><p>&emsp;&emsp;按正常来说，设置当中应该可以设置分辨率，但是发现只有 800x600 的选项，按照网上说的终端敲 xrandr 查看信息，发现直接失败了，应该是显卡驱动的问题。做到这一步已经比较不耐烦了，不想再折腾，因此找到一个简单粗暴的解决方法：</p>
<ol>
<li>sudo 编辑 _etc_default/grub</li>
<li>找到 GRUB_GFXMODE=800x600</li>
<li>修改为你想要的分辨率</li>
<li><strong>去掉前面的注释符号“#”</strong><blockquote>
<p>自己之前因为没注意到前面有个注释符，做完之后分辨率还是老样子，于是又折腾了好久，之后才发现，去掉后完美解决，我晕。  </p>
</blockquote>
</li>
<li><p>立即更新:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grub sudo update-grub</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启，问题解决。</p>
</li>
</ol>
<h3 id="四、接着是登录界面循环进不了系统"><a href="#四、接着是登录界面循环进不了系统" class="headerlink" title="四、接着是登录界面循环进不了系统"></a>四、接着是登录界面循环进不了系统</h3><p>&emsp;&emsp;这个问题直接重装显卡驱动就好，包括开机黑屏也是这样操作，参考博客（注意提前准备好.run驱动文件）：</p>
<blockquote>
<p><a href="https://blog.csdn.net/ssmixi/article/details/73483795" target="_blank" rel="noopener">https://blog.csdn.net/ssmixi/article/details/73483795</a>  </p>
</blockquote>
<h3 id="五、后续（升级问题）"><a href="#五、后续（升级问题）" class="headerlink" title="五、后续（升级问题）"></a>五、后续（升级问题）</h3><p>&emsp;&emsp;由于前期装 Ubuntu18.04 一直装不上（就是问题一的情况，当时没找到解决办法，摊手），后续就改装 Ubuntu 16.04 了，最终装完之后还是想升级到 18.04，可是当系统提示升级，自己同意升级后系统却报内部错误，升级不了，我滴个乖乖，怕不是要我再重装个 18.04？<br>还好还好，在捣鼓了一番之后发现，打开软件更新，会自动检测并让你更新核心组件，更新完成之后重启，便可以正常升级系统了。<br>&emsp;&emsp;经过几个小时的漫长等待，系统升级完成，没有遇到任何错误，至此，w+b双系统安装工作，终于告一段落，撒花。</p>
<h3 id="六、番外篇"><a href="#六、番外篇" class="headerlink" title="六、番外篇"></a>六、番外篇</h3><p>&emsp;&emsp;不知是何种神秘力量所致，1050 Ti 的显卡装完后发现显示掉帧严重，拖动窗口、浏览网页画面也有撕裂问题，并且所有的动画效果都消失了（如最小化窗口没有缩放效果而是直接消失，自动隐藏侧边也没有移入移出效果而是直接显示直接消失），极度影响使用体验，网上也没找到相关问题，尤其是动画效果问题好像压根没人问，是大家都没遇到这个问题，还是说压根就不在乎，我也不清楚，但本人一向对交互体验要求非常高，而这个问题目前还没解决，应该也是由显卡驱动导致的，因此有时间的话会卸掉目前的 nvidia 410，降一级驱动试试水，解决之后再来更新。</p>
<hr>
<h2 id="Part-IIII-参考文章及推荐阅读"><a href="#Part-IIII-参考文章及推荐阅读" class="headerlink" title="Part IIII 参考文章及推荐阅读"></a>Part IIII 参考文章及推荐阅读</h2><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="http://www.cnblogs.com/wshenjin/p/7093505.html" target="_blank" rel="noopener">Linux系统出现hung_task_timeout_secs和blocked for more than 120 seconds的解决方法</a></li>
<li><a href="https://blog.csdn.net/u012160436/article/details/48182009" target="_blank" rel="noopener">ubuntu14.04.2在grub界面中以单用户模式进入系统</a></li>
<li><a href="https://blog.csdn.net/electrocrazy/article/details/79377214" target="_blank" rel="noopener">linux 出错 “INFO: task xxxxxx: 634 blocked for more than 120 seconds.”的3种解决方案</a></li>
<li><a href="https://blog.csdn.net/ssmixi/article/details/73483795" target="_blank" rel="noopener">Ubuntu 16.04 用户登录界面死循环问题的解决</a></li>
<li><a href="https://www.jianshu.com/p/764edaff301e" target="_blank" rel="noopener">Ubuntu16.04+Cuda8.0+Theano深度学习环境搭建一</a></li>
</ul>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="http://www.cnblogs.com/lishanlei/p/9090404.html" target="_blank" rel="noopener">Ubuntu18.04美化主题(mac主题)</a></li>
<li><a href="http://www.cnblogs.com/howdop/p/5398781.html" target="_blank" rel="noopener">Ubuntu常用软件合集</a></li>
</ul>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul>
<li><a href="https://houkaifa.com/2019/08/15/ubuntu-uninstall/" target="_blank" rel="noopener">如何科学卸载 Ubuntu？</a></li>
<li><a href="https://houkaifa.com/2019/08/27/bcdedit-clean-bootmenu/" target="_blank" rel="noopener">Bcdedit 删除 Boot Menu 中的多余启动引导</a></li>
</ul>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>遗憾！</title>
    <url>/2018/11/27/CUMCM-PITY/</url>
    <content><![CDATA[<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>部署本地仓库至 GitHub/Coding</title>
    <url>/2018/11/25/DeployToCoding/</url>
    <content><![CDATA[<h2 id="一、建立本地-Git-仓库"><a href="#一、建立本地-Git-仓库" class="headerlink" title="一、建立本地 Git 仓库"></a>一、建立本地 Git 仓库</h2><ol>
<li><p>初始化本地仓库</p>
<blockquote>
<p><code>git init</code></p>
</blockquote>
</li>
<li><p>上传所有代码到本地仓库</p>
<blockquote>
<p><code>git add .</code><br><code>git commit -m &quot;initial commit&quot;</code></p>
</blockquote>
</li>
</ol>
<h2 id="二、推送至-Github-Coding"><a href="#二、推送至-Github-Coding" class="headerlink" title="二、推送至 Github/Coding"></a>二、推送至 Github/Coding</h2><ol>
<li><p>指向 Coding 的 Git</p>
<blockquote>
<p><code>git remote add origin xxx.git</code><br> xxx 为 github/coding 上的 git 仓库地址</p>
</blockquote>
</li>
<li><p>查看是否指向成功，成功则输出 origin</p>
<blockquote>
<p><code>git remote</code></p>
<p>若出现如下错误则敲下方代码后跳第3步<br>::fatal: remote origin already exists::<br><code>git remote remove origin</code></p>
</blockquote>
</li>
<li><p>本地仓库推送到 Coding 仓库</p>
<blockquote>
<p><code>git push -u origin master</code></p>
</blockquote>
</li>
</ol>
<h2 id="三、部署完成，Enjoy！"><a href="#三、部署完成，Enjoy！" class="headerlink" title="三、部署完成，Enjoy！"></a>三、部署完成，Enjoy！</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
  </entry>
  <entry>
    <title>【项目白皮书】 Easecurve · 专业交互动效开发引擎</title>
    <url>/2018/11/18/Easecurve-White-Paper/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>本篇正在更新中…<br>本篇详细介绍了 <strong>Easecurve 专业交互动效开发引擎</strong> 项目<br>本篇分为上篇和下篇，上篇主要介绍了动效基本概念和当前主流的动效设计软件与动效开发现状。下篇主要介绍了 Easecurve 交互动效开发引擎，及其特点、优势和未来前景。<br>通过阅读本篇，你将：</p>
<ul>
<li>了解动效的是什么、动效的用途和意义、动效开发的前景。</li>
<li>初步了解动效设计与动效开发，明晰动设软件和动效开发引擎的区别。</li>
<li><strong>获取对 Easecurve 项目的整体认知。</strong></li>
</ul>
</blockquote>
<p><img src="/2018/11/18/Easecurve-White-Paper/UI-EasecurveBuilder_InitPage.png" alt="Title"></p>
<hr>
<h2 id="上篇-动效与动设现状"><a href="#上篇-动效与动设现状" class="headerlink" title="上篇 - 动效与动设现状"></a>上篇 - 动效与动设现状</h2><h3 id="一、什么是动效？"><a href="#一、什么是动效？" class="headerlink" title="一、什么是动效？"></a><strong>一、什么是动效？</strong></h3><a id="more"></a>
<h3 id="二、什么是动效设计-amp-动效开发？"><a href="#二、什么是动效设计-amp-动效开发？" class="headerlink" title="二、什么是动效设计 &amp; 动效开发？"></a><strong>二、什么是动效设计 &amp; 动效开发？</strong></h3><h3 id="三、什么是动效设计软件-amp-动效开发引擎？"><a href="#三、什么是动效设计软件-amp-动效开发引擎？" class="headerlink" title="三、什么是动效设计软件 &amp; 动效开发引擎？"></a><strong>三、什么是动效设计软件 &amp; 动效开发引擎？</strong></h3><h3 id="四、目前流行的动效设计软件"><a href="#四、目前流行的动效设计软件" class="headerlink" title="四、目前流行的动效设计软件"></a><strong>四、目前流行的动效设计软件</strong></h3><h3 id="五、目前流行的动设软件的动效成本问题"><a href="#五、目前流行的动设软件的动效成本问题" class="headerlink" title="五、目前流行的动设软件的动效成本问题"></a><strong>五、目前流行的动设软件的动效成本问题</strong></h3><h2 id="下篇-Easecurve-与引擎前景"><a href="#下篇-Easecurve-与引擎前景" class="headerlink" title="下篇 - Easecurve 与引擎前景"></a>下篇 - Easecurve 与引擎前景</h2><h3 id="六、什么是-Easecurve？"><a href="#六、什么是-Easecurve？" class="headerlink" title="六、什么是 Easecurve？"></a><strong>六、什么是 Easecurve？</strong></h3><h3 id="七、Easecurve-与目前流行的动设软件的区别"><a href="#七、Easecurve-与目前流行的动设软件的区别" class="headerlink" title="七、Easecurve 与目前流行的动设软件的区别"></a><strong>七、Easecurve 与目前流行的动设软件的区别</strong></h3><h3 id="八、Easecurve-的动设逻辑与流程"><a href="#八、Easecurve-的动设逻辑与流程" class="headerlink" title="八、Easecurve 的动设逻辑与流程"></a><strong>八、Easecurve 的动设逻辑与流程</strong></h3><h3 id="九、Easecurve-的动效成本问题"><a href="#九、Easecurve-的动效成本问题" class="headerlink" title="九、Easecurve 的动效成本问题"></a><strong>九、Easecurve 的动效成本问题</strong></h3><h3 id="十、Easecurve-的引擎生态蓝图"><a href="#十、Easecurve-的引擎生态蓝图" class="headerlink" title="十、Easecurve 的引擎生态蓝图"></a><strong>十、Easecurve 的引擎生态蓝图</strong></h3><h3 id="十一、Easecurve-的开发现状与已有案例赏析"><a href="#十一、Easecurve-的开发现状与已有案例赏析" class="headerlink" title="十一、Easecurve 的开发现状与已有案例赏析"></a><strong>十一、Easecurve 的开发现状与已有案例赏析</strong></h3><center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
  </entry>
  <entry>
    <title>【Nao-04】 Naoqi Framework &amp; Broker &amp; Proxy &amp; Modules</title>
    <url>/2018/11/08/Robot-Nao-04/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>尚在更新</p>
</blockquote>
<p><img src="/2018/11/08/Robot-Nao-04/1.jpg" alt="Title"></p>
<hr>
<!--
# 敬告：本篇虽短小精悍，却写的乱七八糟，逻辑令人费解且抓狂，若您已经点进全文阅读，请现在立即停止阅读并关闭本页面，不然可能导致您在精神上感到无尽的痛苦与无助，犹如一百二十只油黑的乌鸦对着三十四只短脚的螃蟹呀呀乱叫，这简直是博主几年来所写过的最最最烂的一篇博文，没有底线，没有之一！但不得不面对这篇博文就是出自博主之手这一无比残酷的现实，从头读到尾，无论是章节与章节之间的联系、小节与小节之间的接洽，还是中英弱关系混排造成的概念蒙蔽、阅读障碍，无不令人撕心裂肺、痛哭流涕。这篇博文的诞生简直是对博主贫乏文笔与理性逻辑的毁灭性轰炸，彻底刷新了博主在学术性文章方面的丑陋下限，颠覆了博主对世纪烂文的一贯认知！在此郑重提醒，请各位读者珍爱生命，远离下文！-->
<a id="more"></a>
<h3 id="一、NAOqi-Framework"><a href="#一、NAOqi-Framework" class="headerlink" title="一、NAOqi Framework"></a><strong>一、NAOqi Framework</strong></h3><h4 id="1-什么是-NAOqi-Framework"><a href="#1-什么是-NAOqi-Framework" class="headerlink" title="1. 什么是 NAOqi Framework"></a><strong>1. 什么是 NAOqi Framework</strong></h4><p>&emsp;&emsp;<strong>Naoqi</strong> 是运行在我们的机器人上并对机器人实现控制的主程序，而 <strong>Naoqi Framework</strong> 则是为 <strong>SoftBank Robotics</strong> 机器人所设计的编程框架。通过这个框架，我们可以解决我们对机器人的常见需求，包括：并行性、资源、同步和事件。</p>
<p>&emsp;&emsp;Naoqi Framwork 允许不同模块（运动、音频、视频）之间同构通信、同构编程以及同构信息共享。同时 Naoqi Framework 支持跨平台、跨语言。</p>
<h4 id="2-跨平台："><a href="#2-跨平台：" class="headerlink" title="2. 跨平台："></a><strong>2. 跨平台：</strong></h4><p>&emsp;&emsp;Naoqi Framwork 同时兼容 Windows, Linux 和 Mac，因此我们在 Windows, Linux 和 Mac 环境下都可以利用 Naoqi Framework 进行相关开发。</p>
<ul>
<li>Python：可以轻松地在电脑上运行代码。也可以直接在机器人上运行代码。</li>
<li>C++：和 Python 不同的是，由于 C++ 是一种编译语言，因此如果想要在机器人上运行 C++ 代码的话，需要先要在目标操作系统上完成代码的编译，需要使用交叉编译工具来生成能在机器人操作系统上（Naoqi OS）运行的代码。</li>
</ul>
<blockquote>
<p>要使用 C++ 进行开发的话，请按照 <a href="http://doc.aldebaran.com/2-8/dev/cpp/install_guide.html#cpp-install-guide" target="_blank" rel="noopener">C++ SDK 安装指南</a> 以确保安装了所有所需的工具</p>
</blockquote>
<h4 id="3-跨语言："><a href="#3-跨语言：" class="headerlink" title="3. 跨语言："></a><strong>3. 跨语言：</strong></h4><p>&emsp;&emsp;在机器人上运行的软件既可以用 Python 来开发，也可以用 C++，并且在两种语言上开发方法是完全相同的。</p>
<p><img src="/2018/11/08/Robot-Nao-04/framework_crosslangage.png" alt="framework_crosslangage"></p>
<blockquote>
<p>推荐初学者从 Python 开始学习，因为 Python 更好入门，进而更好更快的完成需求。<br>熟练的 C++ 开发人员应当花更多的时间来开发：<br>&emsp;&emsp;1. Python 中的 behavior<br>&emsp;&emsp;2. C++ 中的 Modules。</p>
</blockquote>
<h4 id="4-分布式："><a href="#4-分布式：" class="headerlink" title="4. 分布式："></a><strong>4. 分布式：</strong></h4><p>&emsp;&emsp;Naoqi Framework 的分布式主要体现在以下两点：</p>
<p>&emsp;&emsp;1. 一个实时的应用程序不仅可以是一个可执行文件，还可以是分布在几个机器人上的多个进程或模块。无论你选择哪一个，调用的方法都是一致的。</p>
<p>&emsp;&emsp;2. 使用一个机器人通过 IP 和端口将可执行文件连接到另一个机器人上时，调用来自其它可执行文件的 API 方法与调用本地的方法是完全一致的。</p>
<p><img src="/2018/11/08/Robot-Nao-04/framework_communication.png" alt="framework_communication"></p>
<blockquote>
<p>在连接时 Naoqi 会自动选择使用快速直连（LPC）还是远程呼叫（RPC）。</p>
</blockquote>
<h4 id="5-如何使用："><a href="#5-如何使用：" class="headerlink" title="5. 如何使用："></a><strong>5. 如何使用：</strong></h4><p>&emsp;&emsp;<strong>Introspection</strong></p>
<p>&emsp;&emsp;Introspection 是机器人 API、能力、监控和被监控功能的基础，通过 Introspection 机器人可以知道自身可用的所有 API 函数，若是卸载一个库文件，那么机器人就会自动删除相应的 API 函数，同时，在 module 中所定义的函数可以通过 BIND_METHOD 来将其添加到 API 中。（BIND_METHOD 定义于 almodule.h）</p>
<p>&emsp;&emsp;如果你通过 BIND_METHOD 绑定了一个函数，尽管这个函数只有三行，你也将受益于以下几点：</p>
<ul>
<li>这个函数既可以在 C++ 中调用，也可以在 Python 中调用。（Naoqi Framework 的跨语言特性）</li>
<li>可以知道这个函数是否被调用了。</li>
<li>不仅可以在本地调用这个函数，还可以通过远程的方式调用该函数。（Naoqi Framework 的分布式特点） </li>
<li>可以在函数中使用 wait, stop, isRunning 函数。</li>
</ul>
<p>&emsp;&emsp;<strong>Naoqi 进程</strong></p>
<p>&emsp;&emsp;在机器上运行的 Naoqi 可执行文件其实相当于一个代理人，当 Naoqi 启动时，它将会加载一个名为  autoload.ini 的首选项文件，并从中读取应当加载哪些库，每一个库都包含了一个或多个模块，这些模块都使用代理的方式来对外开放。</p>
<p><img src="/2018/11/08/Robot-Nao-04/broker-libraries-modules.png" alt="broker-libraries-modules"></p>
<p>&emsp;&emsp;而且这个代理提供了查找功能，这样就方便我们在树或者说是 API 网络上找到对应的方法。</p>
<p>&emsp;&emsp;每当加载一个模块的时候，都会建立一棵方法树来与这个模块进行关联，并且将模块与代理也进行关联。</p>
<p><img src="/2018/11/08/Robot-Nao-04/broker-modules-methods.png" alt="broker-modules-methods"></p>
<h3 id="二、Broker"><a href="#二、Broker" class="headerlink" title="二、Broker"></a><strong>二、Broker</strong></h3><p>Broker 其实就是一个对象，这个对象提供了：</p>
<ul>
<li>目录服务：允许你查找所有的模块和方法。</li>
<li>网络访问：允许附加模块的方法从外部进程调用。</li>
</ul>
<p>在大多数时间里，我们并不需要去关注这个代理，因为它们只是在透明地执行他们的工作，来帮助你写出具有分布式特性的函数。</p>
<h3 id="三、Proxy"><a href="#三、Proxy" class="headerlink" title="三、Proxy"></a><strong>三、Proxy</strong></h3><h1 id="博主已弃文而去（假的）"><a href="#博主已弃文而去（假的）" class="headerlink" title="博主已弃文而去（假的）"></a>博主已弃文而去（假的）</h1><h3 id="四、Modules"><a href="#四、Modules" class="headerlink" title="四、Modules"></a><strong>四、Modules</strong></h3><h1 id="博主已弃文而去（骗你的）"><a href="#博主已弃文而去（骗你的）" class="headerlink" title="博主已弃文而去（骗你的）"></a>博主已弃文而去（骗你的）</h1><center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>NAO</category>
      </categories>
      <tags>
        <tag>NAO</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 值传递和引用传递深入探究</title>
    <url>/2018/11/08/C-ConveyMode/</url>
    <content><![CDATA[<h3 id="一、-函数参数传递机制的基本理论"><a href="#一、-函数参数传递机制的基本理论" class="headerlink" title="一、 函数参数传递机制的基本理论"></a><strong>一、 函数参数传递机制的基本理论</strong></h3><p>&emsp;&emsp;函数参数传递机制问题在本质上是调用函数（过程）和被调用函数（过程）在调用发生时进行通信的方法问题。基本的参数传递机制有两种：值传递和引用传递。以下讨论称调用其他函数的函数为主调函数，被调用的函数为被调函数。</p>
<p>&emsp;&emsp;<strong>值传递（passl-by-value）</strong>过程中，被调函数的形式参数作为被调函数的局部变量处理，即在堆栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。</p>
<p>&emsp;&emsp;<strong>引用传递(pass-by-reference)过程中</strong>，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p>
<h3 id="二、-C-中的函数参数传递机制"><a href="#二、-C-中的函数参数传递机制" class="headerlink" title="二、 C 中的函数参数传递机制"></a><strong>二、 C 中的函数参数传递机制</strong></h3><p>&emsp;&emsp;在 C 语言中，值传递是唯一可用的参数传递机制。但是据笔者所知，由于受指针变量作为函数参数的影响，有许多朋友还认为这种情况是引用传递。这是错误的。请看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int swap(int *x, int *y)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int temp;</span><br><span class="line"></span><br><span class="line">temp = *x; *x = *y; *y = temp;</span><br><span class="line"></span><br><span class="line">return temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int a = 1, b = 2;</span><br><span class="line"></span><br><span class="line">int *p1 = &amp;a;</span><br><span class="line"></span><br><span class="line">int *p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">swap(p1, p2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数 swap 以两个指针变量作为参数，当 main() 调用 swap 时，是以值传递的方式将指针变量 p1、p2 的值（也就是变量 a、b 的地址）放在了 swap 在堆栈中为形式参数 x、y 开辟的内存单元中。</p>
<a id="more"></a>
<p>&emsp;&emsp;<strong>这里我们可以得到以下几点：</strong></p>
<p>　　1． 进程的堆栈存储区是主调函数和被调函数进行通信的主要区域。</p>
<p>　　2． C语言中参数是从右向左进栈的。</p>
<p>　　3． 被调函数使用的堆栈区域结构为：</p>
<p>　　　　局部变量（如temp）</p>
<p>　　　　返回地址</p>
<p>　　　　函数参数</p>
<p>　　　　低地址</p>
<p>　　　　高地址</p>
<p>　　4． 由主调函数在调用后清理堆栈。</p>
<p>　　5． 函数的返回值一般是放在寄存器中的。</p>
<p>&emsp;&emsp;<strong>这里尚需补充说明几点：一是参数进栈的方式</strong>。对于内部类型，由于编译器知道各类型变量使用的内存大小故直接使用 push 指令；对于自定义的类型（如 structure），采用从源地址向目的（堆栈区）地址进行字节传送的方式入栈。<strong>二是函数返回值为什么一般放在寄存器中</strong>，这主要是为了支持中断；如果放在堆栈中有可能因为中断而被覆盖。<strong>三是函数的返回值如果很大</strong>，则从堆栈向存放返回值的地址单元（由主调函数在调用前将此地址压栈提供给被调函数）进行字节传送，以达到返回的目的。对于第二和第三点，《Thinking in C++》一书在 第10章 有比较好的阐述。四是一个显而易见的结论，如果在被调函数中返回局部变量的地址是毫无意义的；因为局部变量存于堆栈中，调用结束后堆栈将被清理，这些地址就变得无效了。</p>
<h3 id="三、-C-中的函数参数传递机制"><a href="#三、-C-中的函数参数传递机制" class="headerlink" title="三、 C++中的函数参数传递机制"></a><strong>三、 C++中的函数参数传递机制</strong></h3><p>&emsp;&emsp;众所周知，在C++中调用函数时有三种参数传递方式：</p>
<p> （1）传值调用；</p>
<p> （2）传址调用（传指针）；</p>
<p> （3）引用传递；</p>
<p>&emsp;&emsp;实际上，还有一种参数传递方式，就是全局变量传递方式。这里的“全局”变量并不见得就是真正的全局的，所有代码都可以直接访问的，只要这个变量的作用域足够这两个函数访问就可以了，比如一个类中的两个成员函数可以使用一个成员变量实现参数传递，或者使用 static 关键字定义，或者使用 namespace 进行限制等，而这里的成员变量在这种意义上就可以称作是“全局”变量（暂时还没有其它比“全局”更好的词来描述）。当然，可以使用一个类外的真正的全局变量来实现参数传递，但有时并没有必要，从工程上讲，作用域越小越好。这种方式有什么优点呢？</p>
<p>&emsp;&emsp;效率高！</p>
<p>&emsp;&emsp;的确，这种效率是所有参数传递方式中效率最高的，比前面三种方式都要高，无论在什么情况下。但这种方式有一个致命的弱点，那就是对多线程的支持不好，如果两个进程同时调用同一个函数，而通过全局变量进行传递参数，该函数就不能够总是得到想要的结果。</p>
<p><strong>下面再分别讨论上面三种函数传递方式。</strong></p>
<h4 id="1-功能上"><a href="#1-功能上" class="headerlink" title="1. 功能上"></a>1. 功能上</h4><p>&emsp;&emsp;按值传递在传递的时候，实参被复制了一份，然后在函数体内使用，<strong>函数体内修改参数变量时修改的是实参的一份拷贝</strong>，而实参本身是没有改变的，所以如果想在调用的函数中修改实参的值，使用值传递是不能达到目的的，这时只能使用引用或指针传递。例如，要实现两个数值交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int a  int b) </span><br><span class="line"></span><br><span class="line"> void main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     int a=1  b=2 </span><br><span class="line"></span><br><span class="line">     swap(a b) </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样，在 main() 函数中的 a, b 值实际上并没有交换，如果想要交换只能使用指针传递或引用传递，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int pa  int pb)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void swap(int&amp;  ra  int&amp;  rb)</span><br></pre></td></tr></table></figure>
<h4 id="2-传递效率上"><a href="#2-传递效率上" class="headerlink" title="2. 传递效率上"></a>2. 传递效率上</h4><p>&emsp;&emsp;<strong>这里所说传递效率，是说调用被调函数的代码将实参传递到被调函数体内的过程</strong>，正如上面代码中，这个过程就是函数 main() 中的 a, b 传递到函数 swap() 中的过程。这个效率不能一概而论。对于内建的 int, char, short, long, float等4字节或以下的数据类型而言，实际上传递时也只需要传递 1－4 个字节，而使用指针传递时在32位cpu中传递的是32位的指针，4 个字节，都是一条指令，这种情况下值传递和指针传递的效率是一样的，而传递double long, long等8字节的数据时，在 32 位 CPU 中，其传值效率比传递指针要慢，因为8个字节需要2次取完。而在 64 位的 CPU 上，传值和传址的效率是一样的。再说引用传递，这个要看编译器具体实现，引用传递最显然的实现方式是使用指针，这种情况下与指针的效率是一样的，而有些情况下编译器是可以优化的，采用直接寻址的方式，这种情况下，效率比传值调用和传址调用都要快，与上面说的采用全局变量方式传递的效率相当。</p>
<p>&emsp;&emsp;再说自定义的数据类型，class  struct 定义的数据类型。这些数据类型在进行传值调用时生成临时对象会执行构造函数，而且当临时对象销毁时会执行析构函数，如果构造函数和析构函数执行的任务比较多，或者传递的对象尺寸比较大，那么传值调用的消耗就比较大。这种情况下，采用传址调用和采用传引用调用的效率大多数下相当，正如上面所说，某些情况下引用传递可能被优化，总体效率稍高于传址调用。</p>
<h4 id="3-执行效率上"><a href="#3-执行效率上" class="headerlink" title="3. 执行效率上"></a>3. 执行效率上</h4><p>&emsp;&emsp;<strong>这里所说的执行效率，是指在被调用的函数体内执行时的效率</strong>。因为传值调用时，当值被传到函数体内，临时对象生成以后，所有的执行任务都是通过直接寻址的方式执行的，而指针和大多数情况下的引用则是以间接寻址的方式执行的，所以实际的执行效率会比传值调用要低。如果函数体内对参数传过来的变量进行操作比较频繁，执行总次数又多的情况下，传址调用和大多数情况下的引用参数传递会造成比较明显的执行效率损失。</p>
<p>&emsp;&emsp;综合 2、3 两种情况，具体的执行效率要结合实际情况，通过比较传递过程的资源消耗和执行函数体消耗之和来选择哪种情况比较合适。<strong>而就引用传递和指针传递的效率上比，引用传递的效率始终不低于指针传递，所以从这种意义上讲，在 C++ 中进行参数传递时优先使用引用传递而不是指针</strong>。</p>
<h4 id="4-类型安全上"><a href="#4-类型安全上" class="headerlink" title="4. 类型安全上"></a>4. 类型安全上</h4><p>&emsp;&emsp;值传递与引用传递在参数传递过程中都执行强类型检查，而指针传递的类型检查较弱，特别地，如果参数被声明为 void ，那么它基本上没有类型检查，只要是指针，编译器就认为是合法的，所以这给bug的产生制造了机会，使程序的健壮性稍差，如果没有必要，就使用值传递和引用传递，最好不用指针传递，更好地利用编译器的类型检查，使得我们有更少的出错机会，以增加代码的健壮性。</p>
<p>&emsp;&emsp;<strong>这里有个特殊情况，就是对于多态的情况</strong>，如果形参是父类，而实参是子类，在进行值传递的时候，临时对象构造时只会构造父类的部分，是一个纯粹的父类对象，而不会构造子类的任何特有的部分，因为办有虚的析构函数，而没有虚的构造函数，这一点是要注意的。如果想在被调函数中通过调用虚函数获得一些子类特有的行为，这是不能实现的。</p>
<h4 id="5-参数检查上"><a href="#5-参数检查上" class="headerlink" title="5. 参数检查上"></a>5. 参数检查上</h4><p>&emsp;&emsp;一个健壮的函数，总会对传递来的参数进行参数检查，保证输入数据的合法性，以防止对数据的破坏并且更好地控制程序按期望的方向运行，在这种情况下使用值传递比使用指针传递要安全得多，因为你不可能传一个不存在的值给值参数或引用参数，而使用指针就可能，很可能传来的是一个非法的地址（没有初始化，指向已经delete掉的对象的指针等）。所以使用值传递和引用传递会使你的代码更健壮，具体是使用引用还是使用，<strong>最简单的一个原则就是看传递的是不是内建的数据类型，对内建的数据类型优先使用值传递，而对于自定义的数据类型，特别是传递较大的对象，那么请使用引用传递。</strong></p>
<h4 id="6-灵活性上"><a href="#6-灵活性上" class="headerlink" title="6. 灵活性上"></a>6. 灵活性上</h4><p>&emsp;&emsp;无疑，指针是最灵活的，因为指针除了可以像值传递和引用传递那样传递一个特定类型的对象外，还可以传递空指针，不传递任何对象。指针的这种优点使它大有用武之地，比如标准库里的 time() 函数，你可以传递一个指针给它，把时间值填到指定的地址，你也可以传递一个空指针而只要返回值。</p>
<h3 id="四、共有技术"><a href="#四、共有技术" class="headerlink" title="四、共有技术"></a><strong>四、共有技术</strong></h3><p>&emsp;&emsp;以上讨论了四种参数传递方式的优缺点，下面再讨论一下在参数传递过程中一些共同的有用的技术。</p>
<h4 id="1-const-关键字"><a href="#1-const-关键字" class="headerlink" title="1. const 关键字"></a>1. const 关键字</h4><p>&emsp;&emsp;当你的参数是作为输入参数时，你总不希望你的输入参数被修改，否则有可能产生逻辑错误，这时可以在声明函数时在参数前加上 const 关键字，防止在实现时意外修改函数输入，对于使用你的代码的程序员也可以告诉他们这个参数是输入，而不加 const 关键字的参数也可能是输出。例如 strlen，你可以这样声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strlen(char str)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;功能上肯定没有什么问题，但是你想告诉使用该函数的人，参数 str 是一个输入参数，它指向的数据是不能被修改的，这也是他们期望的，总不会有人希望在请人给他数钱的时候，里面有张 100 的变成 10 块的了，或者真钞变成假钞了，他们希望有一个保证，说该函数不会破坏你的任何数据，声明按如下方式便可让他们放心：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strlen(const char str)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可不可以给 str 本身也加一个限制呢，如果把地址改了数得的结果不就错了吗？总得给人点儿自由吧，只要它帮你数钱就行了，何必介意他怎么数呢？只要不破坏你的钱就 ok 了，如果给 str 一个限制，就会出现问题了，按照上面的声明，可以这样实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strlen(const char str)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">	int cnt </span><br><span class="line"></span><br><span class="line">	if( !str) return 0 </span><br><span class="line"></span><br><span class="line">      cnt = 0 </span><br><span class="line"></span><br><span class="line">      while( (str++) )&#123;</span><br><span class="line"></span><br><span class="line">         ++cnt </span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return cnt </span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可是，如果你硬要把声明改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strlen(const char const str)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的函数肯定就运行不了了，只能改用其它的实现方式，但这个不是太有必要。只要我们保护好我们的钱就行了，如果它数不对，下次我次不让它数，再换个人就是了。</p>
<p>&emsp;&emsp;对于成员函数，如果我们要显示给客户代码说某个成员函数不会修改该对象的值，只会读取某些内容，也可以在该函数声明中加一个 const.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class    person</span><br><span class="line"></span><br><span class="line">&#123;......</span><br><span class="line"></span><br><span class="line">  public:</span><br><span class="line"></span><br><span class="line">    unsigned char age( void ) const   // 看到const就放心了，这个函数肯定不会修改m_age</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line"></span><br><span class="line">    unsigned char m_age    // 我认为这个类型已经足够长了，如果觉得不改可以改为unsigned long</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-默认值"><a href="#2-默认值" class="headerlink" title="2. 默认值"></a>2. 默认值</h4><p>&emsp;&emsp;个人认为给参数添加一个默认值是一个很方便的特性，非常好用，这样你就可以定义一个具有好几个参数的函数，然后给那些不常用的参数一些默认值，客户代码如果认为那些默认值正是他们想要的，调用函数时只需要填一些必要的实参就行了，非常方便，这样就省去了重载好几个函数的麻烦。可是我不明白 C# 为什么把这个特性给去掉了，可能是为了安全，这样就要求每次调用函数时都要显示地给函数赋实参。所以要注意，这可是个双刃剑，如果想用使刀的招跟对手武斗，很可能伤到自己。</p>
<h4 id="3-参数顺序"><a href="#3-参数顺序" class="headerlink" title="3. 参数顺序"></a>3. 参数顺序</h4><p>&emsp;&emsp;当同个函数名有不同参数时，如果有相同的参数尽量要把参数放在同一位置上，以方便客户端代码。</p>
<p>&emsp;&emsp;C++ 中经常使用的是常量引用，如将 swap2 改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Swap2(const int&amp; x; const int&amp; y)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这时将不能在函数中修改引用地址所指向的内容，具体来说，x 和 y 将不能出现在”＝”的左边。</p>
<p>原文地址：<a href="http://blog.csdn.net/cocohufei/article/details/6143476" target="_blank" rel="noopener">http://blog.csdn.net/cocohufei/article/details/6143476</a></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>【Nao-03】 Naoqi APIs 架构概览 &amp; Hello World！</title>
    <url>/2018/11/05/Robot-Nao-03/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>本篇列出了几类常用的 API 功能模块，介绍了一个重要的 API 函数 ALProxy，并自己创建了一个 Python 指令盒，简单实现了让 Nao 说出 Hello World 的程序代码。</p>
</blockquote>
<p><img src="/2018/11/05/Robot-Nao-03/1.jpg" alt="Title"></p>
<hr>
<h3 id="一、Naoqi-APIs"><a href="#一、Naoqi-APIs" class="headerlink" title="一、Naoqi APIs"></a><strong>一、Naoqi APIs</strong></h3><p><strong>1. API 概览（<a href="http://doc.aldebaran.com/2-8/naoqi/index.html" target="_blank" rel="noopener">官方文档戳我</a>）</strong></p>
<p>&emsp;&emsp;Naoqi 的 API 按功能分类可以大致分为八个部分，分别是：</p>
<ul>
<li>核心类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/core/index.html" target="_blank" rel="noopener">NAOqi Core</a></strong></li>
<li>情感类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/emotion/index.html" target="_blank" rel="noopener">NAOqi Emotion</a></strong></li>
<li>交互类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/interaction/index_interaction.html" target="_blank" rel="noopener">NAOqi Interaction engines</a></strong></li>
<li>运动类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/motion/index.html" target="_blank" rel="noopener">NAOqi Motion</a></strong></li>
<li>音频类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/audio/index.html" target="_blank" rel="noopener">NAOqi Audio</a></strong></li>
<li>视觉类API：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/vision/index.html" target="_blank" rel="noopener">NAOqi Vision</a></strong></li>
<li>人像感知API：:<strong><a href="http://doc.aldebaran.com/2-8/naoqi/lola/lola.html" target="_blank" rel="noopener">NAOqi People Perception</a></strong></li>
<li>传感器与LED灯：<strong><a href="http://doc.aldebaran.com/2-8/naoqi/sensors/index.html" target="_blank" rel="noopener">NAOqi Sensors &amp; LEDs</a></strong></li>
</ul>
<p><strong>2. 重要API: ALProxy</strong></p>
<p>&emsp;&emsp;在 Naoqi 的 Python SDK 中提供了一条重要的 API: ALProxy，在调用 Naoqi 的各个功能模块时通常都要先调用此API，从而获取指定功能模块的代理服务，其返回的应该是指定服务类的一个实例。ALProxy 有两个不同的构造函数，详见下面的函数原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALProxy (name, ip, port)</span><br><span class="line"># name is the name of the module,</span><br><span class="line"># ip is the IP of the broker in which the module is running,</span><br><span class="line"># port is the port of the broker.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALProxy (name)</span><br><span class="line"># name is the name of the module.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ALProxy (name) 作为 ALProxy (name, ip, port) 的重载函数，通常在没有可用的代理实例时才被使用。</p>
</blockquote>
<a id="more"></a>
<h3 id="二、在-Choregraphe-中创建自己的第一个-Python-Box"><a href="#二、在-Choregraphe-中创建自己的第一个-Python-Box" class="headerlink" title="二、在 Choregraphe 中创建自己的第一个 Python Box"></a><strong>二、在 Choregraphe 中创建自己的第一个 Python Box</strong></h3><p>&emsp;&emsp;接下来，我们就要开始着手 Python 程序的编写了，这一系列的学习笔记都将在 Choregraphe 环境中完成代码的编写。首先，我们需要在 Choregraphe 中新建一个盒子，只需在流程图面板右键 -&gt; Create a new box 中选择 Python 即可，填写 Box name 和 Description 并点击确定，其他参数我们暂时不管。<br><img src="/2018/11/05/Robot-Nao-03/gif1.gif" alt="Title"></p>
<p>&emsp;&emsp;这样，我们就造了一个盒子（Box），双击我们刚才造的 Box 即可打开文本编辑器，可以看到其中已经有一些初始代码了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass(GeneratedClass):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        GeneratedClass.__init__(self)</span><br><span class="line"></span><br><span class="line">    def onLoad(self):</span><br><span class="line">        #put initialization code here</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onUnload(self):</span><br><span class="line">        #put clean-up code here</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onInput_onStart(self):</span><br><span class="line">        #self.onStopped() #activate the output of the box</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onInput_onStop(self):</span><br><span class="line">        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped</span><br><span class="line">        self.onStopped() #activate the output of the box</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中 onLoad 函数和 onUnload 函数分别在初始化和清除的时候调用，而 onInput_onStart 函数与 onInput_onStop 函数则是在盒子启动和停止的时候被调用。</p>
<h3 id="三、Hello-World！"><a href="#三、Hello-World！" class="headerlink" title="三、Hello World！"></a><strong>三、Hello World！</strong></h3><p>&emsp;&emsp;好了，下面就让我们通过代码实现，让 Nao 说出那句经典的 Hello World 吧！</p>
<p>&emsp;&emsp;为了让 Nao 开口说话，我们还需要一个分类于 NAOqi Audio 的 API: <a href="http://doc.aldebaran.com/2-8/naoqi/audio/altexttospeech-api.html" target="_blank" rel="noopener">ALTextToSpeech</a>。</p>
<p>&emsp;&emsp;ALTextToSpeech 是一个类，或者说是 Naoqi 的一个功能模块，其中包含 setParameter、setVoice、getVoice 等成员函数，而具有能让 Nao 开口说话这种神奇作用的，就是其中的 say 函数。</p>
<p>&emsp;&emsp;函数原型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALTextToSpeechProxy::say(const std::string&amp; stringToSay)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;say 函数本身非常的简单，只有一个参数即要说的内容，由于 say 函数是 ALTextToSpeech 类中的成员函数，为了调用它我们首先要借助 ALProxy 来获得 ALTextToSpeech 模块的实例(代理)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tts = ALProxy (&quot;ALTextToSpeech&quot;, &quot;localhost&quot;, 7096)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;之后就可以大大方方的调用 say 函数来让 Nao 机器人说出我们想它说出的内容了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tts.say (&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;为了让程序在 Box 被运行时执行，并在运行完所有内容后自动结束，我们将代码写在 OnStart 函数中、self.onStopped() 代码行上方，并取消 self.onStopped() 前的 # 号注释，完整代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass(GeneratedClass):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        GeneratedClass.__init__(self)</span><br><span class="line"></span><br><span class="line">    def onLoad(self):</span><br><span class="line">        #put initialization code here</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onUnload(self):</span><br><span class="line">        #put clean-up code here</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onInput_onStart(self):</span><br><span class="line">        tts = ALProxy(&quot;ALTextToSpeech&quot;, &quot;localhost&quot;, 7096)</span><br><span class="line">        tts.say(&quot;Hello World!&quot;)</span><br><span class="line">        self.onStopped() #activate the output of the box</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def onInput_onStop(self):</span><br><span class="line">        self.onUnload() #it is recommended to reuse the clean-up as the box is stopped</span><br><span class="line">        self.onStopped() #activate the output of the box</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;运行效果：</p>
<p><img src="/2018/11/05/Robot-Nao-03/gif2.gif" alt="Title"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>NAO</category>
      </categories>
      <tags>
        <tag>NAO</tag>
      </tags>
  </entry>
  <entry>
    <title>【Nao-02】 Choregraphe 环境介绍 &amp; 让 Virtual Robot 运行一个盒子</title>
    <url>/2018/11/04/Robot-Nao-02/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>本篇初步介绍了 Choregraphe 开发环境，并演示如何让 Vitual Robot 安装并运行一个已有的指令盒。</p>
</blockquote>
<p><img src="/2018/11/04/Robot-Nao-02/1.jpg" alt="Title"></p>
<hr>
<h3 id="一、Choregraphe-环境概览"><a href="#一、Choregraphe-环境概览" class="headerlink" title="一、Choregraphe 环境概览"></a><strong>一、Choregraphe 环境概览</strong></h3><p>&emsp;&emsp;在 Windows 系统下正确安装 Choregraphe 后，其启动界面如图 2-1 所示。（<a href="https://houkaifa.com/2018/11/01/Robot-Nao-01/" target="_blank" rel="noopener">Choregraphe 下载、安装过程</a>）</p>
<p>&emsp;&emsp;在此将界面按除工具栏外，从顶部开始逆时针旋转分割为八个部分，分别是：<br><img src="/2018/11/04/Robot-Nao-02/2.jpg" alt="Title">图 2-1 Choregraphe 界面</p>
<p>&emsp;&emsp;<strong>1. Quick Bar</strong></p>
<blockquote>
<p>快速工具栏，可以快捷执行新建项目、打开项目、保存项目、撤销与重做、连接与断开连接、上传安装并运行、中止运行与调试操作，并显示当前的 Robot 运行状态。</p>
</blockquote>
<p>&emsp;&emsp;<strong>2. Project Files</strong></p>
<blockquote>
<p>项目文件区，可以选择 behavior，并在 ⑥ 中的 Inspector 中查看相关属性，单击 Properties 按钮可以修改 behavior 的一些特性。</p>
</blockquote>
<p>&emsp;&emsp;<strong>3. Project Objects</strong></p>
<blockquote>
<p>项目目标，显示当前项目中所有的 behavior，即 ⑤ 区域中所显示的内容。 </p>
</blockquote>
<p>&emsp;&emsp;<strong>4. Box Libraries</strong></p>
<blockquote>
<p>盒子库，显示被包含的所有指令盒，默认加载 Choregraphe 自带的所有指令盒，可以通过 ④ 区的工具栏自己新建盒子库、打开盒子库、保存盒子库和显示指令盒过滤器。</p>
</blockquote>
<a id="more"></a>
<p>&emsp;&emsp;<strong>5. Operating Space</strong></p>
<blockquote>
<p>流程图区，在此区域控制机器人的 behavior 逻辑。</p>
</blockquote>
<p>&emsp;&emsp;<strong>6. Inspector &amp; Robot applications</strong></p>
<blockquote>
<p>属性区，可以在选中 ③ 区中的 behavior 与 ④ 区的 Box 时查看、修改相关对象的属性。</p>
<p>机器人应用区，可以查看当前机器人所附加的所有应用（behaviors）。</p>
</blockquote>
<p>&emsp;&emsp;<strong>7. Robot View &amp; Video monitor</strong></p>
<blockquote>
<p>机器人视图区，可以查看机器人的外观与实时动作状态，并可以通过选中关节、部位，来手动调节机器人的姿态。</p>
<p>视频监视区，可以查看机器人当前所看到的视觉图像。</p>
</blockquote>
<p>&emsp;&emsp;<strong>8. Status Bar</strong></p>
<blockquote>
<p>状态条，显示当前机器人的状态参量，如音量、运动模式、是否开启自由生活等、电量等。</p>
</blockquote>
<h3 id="二、使用-Box-Libraries-中的盒子来控制-Vitual-Robot"><a href="#二、使用-Box-Libraries-中的盒子来控制-Vitual-Robot" class="headerlink" title="二、使用 Box Libraries 中的盒子来控制 Vitual Robot"></a><strong>二、使用 Box Libraries 中的盒子来控制 Vitual Robot</strong></h3><p><strong>1. 添加一个 Box 并完成一个完整的 Behavior</strong></p>
<p>&emsp;&emsp;在 Choregraphe 的环境概览中，我们了解了 ④ Box Libraries，现在我们尝试使用一个已有的 Box 来控制我们的虚拟机器人。</p>
<p>&emsp;&emsp;首先在 Box Libraries 中找到一个我们中意的 Box，然后用鼠标左键按住这个 Box，拖动到 ⑤ Operating Space 中，这样我们就将一个 Box 添加到了当前编辑的 behavior。</p>
<p>&emsp;&emsp;为了使得这个 behavior 按照我们想要的的逻辑来运行 Box，我们需要按住 ⑤ 区左上角处的右三角按钮 <img src="/2018/11/04/Robot-Nao-02/elem3.jpg" alt="Title">（On Start），拖动到我们所添加的 Box 的对应右三角处 <img src="/2018/11/04/Robot-Nao-02/elem1.jpg" alt="Title">（On Start），这样连出的一条逻辑线表示在这个 Behavior 被运行时，首先执行我们放入的这个 Box。</p>
<p>&emsp;&emsp;随后按住这个 Box 右上角的 <img src="/2018/11/04/Robot-Nao-02/elem2.jpg" alt="Title"> 按钮，拖拽至 ⑤ 区右上角的 <img src="/2018/11/04/Robot-Nao-02/elem4.jpg" alt="Title"> 处，这样连出的一条逻辑线表示在我们这个 Box 执行完成后，整个 Behavior 就执行结束了。完整的操作过程见图 2-2。<br><img src="/2018/11/04/Robot-Nao-02/gif1.gif" alt="Title">图 2-2 添加一个 Box 并完成 Behavior 逻辑线连接</p>
<p><strong>2. 安装 Behavior 到 Vitual Robot 并运行</strong></p>
<p>&emsp;&emsp;接下来，为了让机器人运行我们所想的 Behavior，只需要点击 ① 区中的 <img src="/2018/11/04/Robot-Nao-02/elem5.jpg" alt="Title">（Upload to the robot and Play）或按下键盘上的 F5 即可。</p>
<p>&emsp;&emsp;查看过程中要想停止运行，点击 ⑤ 区中的 <img src="/2018/11/04/Robot-Nao-02/elem6.jpg" alt="Title">（Stop）或使用组合按钮 Shift + F5 即可。运行效果见图 2-3。<br><img src="/2018/11/04/Robot-Nao-02/gif2.gif" alt="Title">图 2-3 调试与停止调试</p>
<h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a><strong>三、补充</strong></h3><p>&emsp;&emsp;0x01 Choregraphe 的界面布局是可以动态调整的，方法是用鼠标左键按住需要调整位置的功能模块的标题栏并拖拽，拖拽到合适位置后再松开鼠标左键。各个功能模块是可以通过关闭按钮来隐藏的，被隐藏的模块可以在顶部工具栏的 View 选项中找回显示，也可以在 View 中保存当前的界面布局、加载已有的界面布局文件（.lyt）、恢复默认布局。<br><img src="/2018/11/04/Robot-Nao-02/gif3.gif" alt="Title">图 2-4 调整界面布局</p>
<p>&emsp;&emsp;0x02 在调试的过程当中有可能出现无法 Stop 的情况，需要断开连接后重连机器人。</p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>NAO</category>
      </categories>
      <tags>
        <tag>NAO</tag>
      </tags>
  </entry>
  <entry>
    <title>【Nao-01】 Windows+Naoqi+Python+Choregraphe 开发环境的搭建</title>
    <url>/2018/11/01/Robot-Nao-01/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>本篇介绍 Windows 系统中 Choregraphe 与 Python 的下载与安装，并给出了几个常见问题的解决办法。</p>
</blockquote>
<p><img src="/2018/11/01/Robot-Nao-01/1.jpg" alt="Choregraphe suit"></p>
<hr>
<h3 id="一、安装Choregraphe"><a href="#一、安装Choregraphe" class="headerlink" title="一、安装Choregraphe"></a><strong>一、安装Choregraphe</strong></h3><p>&emsp;&emsp;<strong>1.注册 SoftBank 帐号并登录</strong></p>
<p>&emsp;&emsp;<strong>2.访问 <a href="https://community.ald.softbankrobotics.com/" target="_blank" rel="noopener">SoftBank Community</a>，点击网页右上角的 Resource 进入资源下载页面</strong></p>
<p>&emsp;&emsp;<strong>3.下载 Choregraphe 并安装</strong></p>
<p><img src="/2018/11/01/Robot-Nao-01/2.jpg" alt="Choregraphe suit"></p>
<a id="more"></a>
<h3 id="二、安装Python"><a href="#二、安装Python" class="headerlink" title="二、安装Python"></a><strong>二、安装Python</strong></h3><p>&emsp;&emsp;<strong>1.访问 Python 官网下载 Python2.7，<a href="https://www.python.org/getit/" target="_blank" rel="noopener">下载地址戳我</a></strong></p>
<p>&emsp;&emsp;<strong>2.安装 Python2.7，并通过控制台py指令检查是否安装成功</strong></p>
<p>&emsp;&emsp;<strong>3.若未安装成功，检查系统环境变量是否配置正确</strong></p>
<p><img src="/2018/11/01/Robot-Nao-01/3.jpg" alt="Choregraphe suit"></p>
<blockquote>
<p>注意:截至最新版本的 Choregraphe 2.8.3.54，目前仅支持 Python2.7，不支持 Python3.0.</p>
</blockquote>
<h3 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a><strong>三、常见问题</strong></h3><p><strong>1.Choregraphe 无法连接至 127.0.0.1</strong></p>
<p>&emsp;&emsp;解决方案①：检查安装路径是否包含中文，是的话去除中文，否的话见解决方案②。</p>
<p>&emsp;&emsp;解决方案②：检查管理员用户名是否包含中文，是的话修改用户名，去除中文。</p>
<p><strong>2.Choregraphe 无法连接至 Naoqi</strong></p>
<p>&emsp;&emsp;解决方案①：等待几分钟，尝试重新连接。</p>
<p>&emsp;&emsp;解决方案②：打开任务管理器，结束 naoqi-bin 进程，打开 Choregraphe 安装目录，找到 naoqi-bin.exe，右键以管理员身份运行，等待 naoqi-bin.exe 完成加载，跳转至 Choregraphe 再次尝试连接。</p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>NAO</category>
      </categories>
      <tags>
        <tag>NAO</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数学建模的算法与方法与资源的总结与收集</title>
    <url>/2018/09/20/MCM-Methods-Induce/</url>
    <content><![CDATA[<h3 id="emsp-前言"><a href="#emsp-前言" class="headerlink" title="&emsp;前言"></a>&emsp;<strong>前言</strong></h3><blockquote>
<p>2018.09.16 20:00，首次参加的数学建模国赛落下帷幕，在国赛中所收获感受与经验，远超之前参加的华中数模竞赛、电工杯数模竞赛。在此分类总结数模备赛期间与实赛过程中所学到、用到、对将来实际问题可能提供帮助的算法与相关问题的解决方法，以作回顾与加深。本篇各章节、各小结均无先后顺序，本篇不定期更新。</p>
</blockquote>
<h4 id="emsp-emsp-一、数据预处理"><a href="#emsp-emsp-一、数据预处理" class="headerlink" title="&emsp;&emsp;一、数据预处理"></a>&emsp;&emsp;<strong>一、数据预处理</strong></h4><p><strong>数据清洗</strong></p>
<p><strong>数据标准化</strong></p>
<p>待更新</p>
<p><strong>数据归一化</strong></p>
<p>待更新</p>
<p><strong>插值与拟合</strong></p>
<p>待更新</p>
<p><strong>Q型/R型聚类</strong></p>
<p>待更新</p>
<a id="more"></a>
<h4 id="emsp-emsp-二、评价类问题"><a href="#emsp-emsp-二、评价类问题" class="headerlink" title="&emsp;&emsp;二、评价类问题"></a>&emsp;&emsp;<strong>二、评价类问题</strong></h4><p><strong>主成分分析</strong></p>
<p>待更新</p>
<p><strong>TOPSIS分析</strong></p>
<p>待更新</p>
<p><strong>层次分析</strong></p>
<p>待更新</p>
<p><strong>模糊综合评价</strong></p>
<p>待更新</p>
<p><strong>熵权法</strong></p>
<p>待更新</p>
<p><strong>数据包络分析</strong></p>
<p>待更新</p>
<p><strong>灰色关联</strong></p>
<p>待更新</p>
<h4 id="emsp-emsp-三、优化类问题"><a href="#emsp-emsp-三、优化类问题" class="headerlink" title="&emsp;&emsp;三、优化类问题"></a>&emsp;&emsp;<strong>三、优化类问题</strong></h4><h4 id="emsp-emsp-四、预测类问题"><a href="#emsp-emsp-四、预测类问题" class="headerlink" title="&emsp;&emsp;四、预测类问题"></a>&emsp;&emsp;<strong>四、预测类问题</strong></h4><h4 id="emsp-emsp-五、数据可视化"><a href="#emsp-emsp-五、数据可视化" class="headerlink" title="&emsp;&emsp;五、数据可视化"></a>&emsp;&emsp;<strong>五、数据可视化</strong></h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>海量数据下的快速定位，HashTable 算法详解及其应用</title>
    <url>/2018/07/30/HashTable/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h3><blockquote>
<p>在今天这个大数据的时代，我们当中的大部分人或许并没有海量的请求需要应对，但相信你总会遇到有大量数据需要处理的时候。为了在后期能够更加高效地对这些数据进行管理和操作，相信你一定不会愿意将宝贵的时间浪费在数据的搜索、查询和定位上。或许你应该掌握更加合理的数据处理办法，来提高你的程序及项目的运作效率。</p>
</blockquote>
<h3 id="一、什么是哈希表？"><a href="#一、什么是哈希表？" class="headerlink" title="一、什么是哈希表？"></a><strong>一、什么是哈希表？</strong></h3><p><strong>0x01 什么是哈希表？</strong><br>&emsp;&emsp;哈希表是一种数据结构，它可以提供快速的插入操作和查找操作。<br>&emsp;&emsp;第一次接触哈希表时，它的优点多得让人难以置信。不论哈希表中有多少数据，查找、插入和删除（有时包括侧除）<strong>只需要接近常量的时间——0。</strong>对于常规的搜索定位方式来说，在巨量的数据中找到目标数据可能需要几十毫秒、几百毫秒甚至是按秒算，但在哈希表中查找不过是一瞬间的事。<br>&emsp;&emsp;为了更好地理解哈希表算法的基本原理，此处假定一个场景：Sun开发了一款即时通讯软件W，而Sun需要在W发布之前想好如何应对发布后越来越多用户的帐号操作请求（以搜索好友为例，为方便说明，简单假设数据均在程序数组内，不考虑数据库等外部因素）。于是Sun设想现在W已拥有100万活跃用户，数组A内存放了这些用户的数据。而此时某用户想要查询W号为66666的用户信息，如果你是Sun，你将如何在100万W号中找到66666，并返回其信息？</p>
<p><strong>0x02 一般方法下的寻找过程？</strong><br>&emsp;&emsp;在正式说到哈希之前，我们先来看一下没有相关经验的新人可能会使用的笨办法——直接遍历。<br>&emsp;&emsp;在遍历的过程中，程序首先查看A[1]内的W号，若不是66666则向下查看A[2]，直到找到A[x]内的W号为66666，返回A[x]。<br><img src="/2018/07/30/HashTable/1.png" alt="图1"><br>（注：本文中默认数据均从下标为1开始存储）<br>&emsp;&emsp;若足够幸运以至于A[1]就是66666，那么一步就完成了检索。若不凑巧A[100000]才是用户66666呢？那要花费多少时间和资源？这种方法虽然简单却有明显的缺陷，而这一类请求在今后是将高频出现的，有时候许多用户同时向服务器发起请求，显然不会得到理想的效果。<br><a id="more"></a><br><strong>0x03 哈希表算法如何瞬间定位？</strong><br>&emsp;&emsp;哈希表算法的高效率得益于数据存放的结构。让我们先来看一看一条数据是如何被放进哈希表当中的。<br><img src="/2018/07/30/HashTable/2.png" alt="图2"><br>&emsp;&emsp;从上图可以看出，<strong>数据在哈希表中所存放的位置adr，是与数据本身具有函数映射关系的（即散列函数），</strong>也就是说我们依据某种规则，使得数据与其存放的地址之内能够相互转化，这样就无需盲目地从第一个找到最后一个，而是直接得到目标地址了！</p>
<h3 id="二、初探哈希表算法"><a href="#二、初探哈希表算法" class="headerlink" title="二、初探哈希表算法"></a><strong>二、初探哈希表算法</strong></h3><p><strong>0x01 简单的例子及哈希表算法的弊端</strong><br>&emsp;&emsp;举个例子，数组A={1, 3, 6, 13}，哈希表为数组B，散列函数H(x)=2x，那么根据上图流程：<br>&emsp;&emsp;&emsp;&emsp;· A[1]在哈希表中的位置为1<em>2=2，<br>&emsp;&emsp;&emsp;&emsp;· A[2]在哈希表中的位置为3</em>2=6，<br>&emsp;&emsp;&emsp;&emsp;· A[3]在哈希表中的位置为6<em>2=12，<br>&emsp;&emsp;&emsp;&emsp;· A[4]在哈希表中的位置为13</em>2=26。<br>&emsp;&emsp;最终得到的哈希表：<br>&emsp;&emsp;&emsp;&emsp;· B[2] = 1<br>&emsp;&emsp;&emsp;&emsp;· B[6] = 3<br>&emsp;&emsp;&emsp;&emsp;· B[12] = 6<br>&emsp;&emsp;&emsp;&emsp;· B[26] = 13<br>&emsp;&emsp;其余的B[x]均为零。<br>&emsp;&emsp;那么当我们想要找13这个数据在哈希表中的位置时，我们不需要一个一个地试过去，而是直接得到地址adr=H(13)=26，即B[26]内存放了数据13。<br><img src="/2018/07/30/HashTable/3.png" alt="图3"><br>&emsp;&emsp;但由此我们就发现了空间的浪费，原本只有4个数据，而为了哈希表正常运作我们必须至少提供26个位置，也就是说有22个位置根本没有用到。<strong>可以说，哈希表算法就在是用空间换时间。</strong>为了得到更好的效果，我们必须牺牲许多在一般方法中不必要的空间，但在这个硬件越来越强大的时代，用空间换时间这一做法是绝对值得的。</p>
<p><strong>0x02 寻求合适的散列函数</strong><br>&emsp;&emsp;虽然哈希表算法有不可避免的空间浪费，<strong>但设定一个合适的散列函数可以大大地降低空间的浪费率。</strong>以上面的数组A为例，散列函数选为H(x)=2x时，哈希表空间的最大利用率为<br> <center>$\frac{4}{26}$=0.154</center><br>&emsp;&emsp; 可以说是非常低了。但如果我们以H’(x)=x%11（注：x除以11所得的余数）作为散列函数呢？我们将得到A[1]在B内的地址为1%11=1，以此类推，最终：<br>&emsp;&emsp;&emsp;&emsp;· B[1] = 1<br>&emsp;&emsp;&emsp;&emsp;· B[3] = 3<br>&emsp;&emsp;&emsp;&emsp;· B[6] = 6<br>&emsp;&emsp;&emsp;&emsp;· B[2] = 13<br>&emsp;&emsp;此时最小的哈希表只需要6个位置，其空间利用率变成了</p>
<center>$\frac{4}{6}$=0.667</center>
&emsp;&emsp;这要比H(x)=2x高出4倍多。这一通过求余数得到映射地址的方法即是我们处理数字数据的主要方法，这一方法被称作**除留余数法**。为了限制篇幅，在本篇中仅深入介绍这一种。
&emsp;&emsp;现在让我们改变原来的数组，使得A={273, 131, 207, ...}，会出现什么问题呢？
&emsp;&emsp;根据之前的除留余数法，我们得到：
&emsp;&emsp;&emsp;&emsp;· A[1]在哈希表中的位置为273%11=9，
&emsp;&emsp;&emsp;&emsp;· A[2]在哈希表中的位置为131%11=10，
&emsp;&emsp;&emsp;&emsp;· A[3]在哈希表中的位置为207%11=9，
&emsp;&emsp;&emsp;&emsp;· ...
&emsp;&emsp;计算得到A[3]的地址为9时，我们就发现了问题，9这个地址内已经存放了A[1]，即B[9]=273，那么A[3]应该怎么处理？
![图4](4.png)
**0x03 冲突处理 I (开放寻址法)**
&emsp;&emsp;在0x02中出现了地址被占用的情况，这种情况被称作**冲突（碰撞）**。我们有多种途径可以解决哈希表中的冲突问题，首先我们可以选择远离2的整数幂的素数作为求余数来初步降低碰撞概率（本文使用的是11）。
&emsp;&emsp;至于实际遇到了碰撞的处理办法，为了限制篇幅，在此仅介绍**线性探测(Linear Probing)**和**伪随机探测再散列**两种办法。
&emsp;&emsp;**(1) 线性探测 **
&emsp;&emsp;线性探测处理冲突可以说是简单明了，即对发生冲突的地址进行线性加一递增的处理。例如adr=H'(A[3])=9，但B[adr]!=0，即发生了冲突，于是我们将adr++，发现B[adr+1]内也有数据131了，于是继续递增，发现B[adr+2]内是空的，于是将A[3]存放进B[adr+2]即B[11]内，冲突得到了解决。
&emsp;&emsp;这种方法虽然简单，但是却容易导致**同类哈希聚焦(Primary Clustering)**。现在我们反过来查找207在哈希表中的位置，我们第一次得到的地址是9，但发现B[9]内并不是207，于是看B[10]，发现B[10]内也不是207而是131，直到第三次才在B[11]内找到了207。如此下来若是大量的数据%11恰好都是9，那么哈希表算法就沦落得无异于普通的遍历了。
&emsp;&emsp;**(2) 伪随机探测再散列**
&emsp;&emsp;伪随机探测再散列的方法并无定态，本例中使用
<center>**Hn=H'(adr+k%10+n)+1**</center>
&emsp;&emsp;作为处理函数。在线性探测中我们将1作为探测值，即newAdr=adr+1，而在此处的探测值为k%10+n，由于n不是定值（一般取作冲突次数），因此称为伪随机探测。随后对探测后得到的adr+k%10+n再次散列即H'(x)=x%11，最后再加一得到新地址。伪随机探测再散列相较于线性探测的优点在于**能够将数据分散得更开，即更能够做到随机分配，不会出现数据扎堆在表中某一块位置的情况，**但仍然无法完全避免糟糕的数据所造成的哈希聚焦。
![图5](5.png)
## 待更新：
**0x04 冲突处理 II (链表法)**
**0x05 动态扩容**
### **三、哈希表算法的代码实现**
### **四、总结**

<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>贝塞尔曲线运动n阶追踪方程的数学原理及其匀速化方法和应用</title>
    <url>/2018/07/30/BezierCurve/</url>
    <content><![CDATA[<h3 id="emsp-前言"><a href="#emsp-前言" class="headerlink" title="&emsp;前言"></a>&emsp;<strong>前言</strong></h3><blockquote>
<p>首先声明一下本文讨论的终极目标——通过贝塞尔曲线实现可调控的数值缓动，也就是贝塞尔插值。之所以以数值为目的是因为它相较于实现某一个具体的案例而言，意义更为广泛，例如可以实现可控性很强的缓动动效，在本文的末尾会附上具体的贝塞尔运动案例分析与一些应用层面的介绍。文章的前一部分即推导部分会以较多的数学形式来加以表述，而中间关于贝塞尔运动的匀速化会则尽量用通俗易懂的语言来说明，最后附上一些相关代码以及应用和总结。</p>
</blockquote>
<p>&emsp;&emsp;其实这方面已经有几个月没有再接触了，之所以写这篇文章，是为了回顾与加深之前在这方面学习研究的印象，文章内容仅是个人的理解与一些思考和感悟，并不一定是绝对正确的，因此要是文章内容有什么错误或歧义，还得请各位点醒指出，必当虚心学习，不胜感激。<br><img src="/2018/07/30/BezierCurve/1.jpg" alt="Bezier"></p>
<script type="math/tex; mode=display">法国数学家Pierre Bézier</script><h3 id="emsp-一、关于贝塞尔曲线-amp-贝塞尔运动"><a href="#emsp-一、关于贝塞尔曲线-amp-贝塞尔运动" class="headerlink" title="&emsp;一、关于贝塞尔曲线 &amp; 贝塞尔运动"></a>&emsp;<strong>一、关于贝塞尔曲线 &amp; 贝塞尔运动</strong></h3><h4 id="emsp-emsp-1-简介"><a href="#emsp-emsp-1-简介" class="headerlink" title="&emsp;&emsp;1.简介"></a>&emsp;&emsp;<strong>1.简介</strong></h4><p>&emsp;&emsp;贝塞尔曲线的介绍在网上到处都能找到，这里就不长篇大论地引入了。简而言之，贝塞尔曲线就是这样的一条曲线，<strong>它是依据四个位置任意的点坐标绘制出的一条光滑曲线。</strong>而贝塞尔追踪方程则是以点运动的形式描述了贝塞尔曲线的形成过程，将曲线描述为了一条随连续时间而形成的<strong>点迹</strong>。<br><a id="more"></a></p>
<h4 id="emsp-emsp-2-作用"><a href="#emsp-emsp-2-作用" class="headerlink" title="&emsp;&emsp;2.作用"></a>&emsp;&emsp;<strong>2.作用</strong></h4><p>由于用计算机画图大部分时间是操作鼠标来掌握线条的路径，与手绘的感觉和效果有很大的差别。即使是一位精明的画师能轻松绘出各种图形，拿到鼠标想随心所欲的画图也不是一件容易的事。这一点是计算机万万不能代替手工的工作，所以到目前为止人们只能颇感无奈。使用贝塞尔工具画图很大程度上弥补了这一缺憾。贝塞尔曲线是计算机图形图像造型的基本工具，是图形造型运用得最多的基本线条之一。<br><img src="/2018/07/30/BezierCurve/2.jpg" alt=""><br>&emsp;&emsp;它通过控制曲线上的四个点（起始点、终止点以及两个相互分离的中间点）来创造、编辑图形。其中起重要作用的是位于曲线中央的控制线。这条线是虚拟的，中间与贝塞尔曲线交叉，两端是控制端点。移动两端的端点时贝塞尔曲线改变曲线的曲率（弯曲的程度）；移动中间点（也就是移动虚拟的控制线）时，贝塞尔曲线在起始点和终止点锁定的情况下做均匀移动。注意，贝塞尔曲线上的所有控制点、节点均可编辑。这种“智能化”的矢量线条为艺术家提供了一种理想的图形编辑与创造的工具。</p>
<h4 id="emsp-emsp-2-贝塞尔运动"><a href="#emsp-emsp-2-贝塞尔运动" class="headerlink" title="&emsp;&emsp;2.贝塞尔运动"></a>&emsp;&emsp;<strong>2.贝塞尔运动</strong></h4><p>&emsp;&emsp;简单地说，贝塞尔运动就是按照贝塞尔曲线所描述的规律来完成一段运动。后文有详细案例，此处就先提上这么一句。</p>
<h3 id="emsp-二、贝塞尔追踪方程的数学推导"><a href="#emsp-二、贝塞尔追踪方程的数学推导" class="headerlink" title="&emsp;二、贝塞尔追踪方程的数学推导"></a>&emsp;<strong>二、贝塞尔追踪方程的数学推导</strong></h3><h4 id="emsp-emsp-1-一阶推导"><a href="#emsp-emsp-1-一阶推导" class="headerlink" title="&emsp;&emsp;1.一阶推导"></a>&emsp;&emsp;<strong>1.一阶推导</strong></h4><p>&emsp;&emsp;虽然说是依据四个点而绘制出的曲线，但实际上最少2个点就可以构成一条贝塞尔曲线，这样的贝塞尔曲线又叫一阶的贝塞尔曲线，也是无控制点的贝塞尔曲线。<br>&emsp;&emsp;前面说到追踪方程描述了点迹，一般地我们将迹点运动的总时间记为1，并把这两个端点分别记作 P<sub>0</sub> 和 P<sub>1</sub> ，运动的迹点记作 M<sub>0</sub> ，就有 t 时刻对应 M<sub>0</sub> 的位置为 P<sub>0</sub> + (P<sub>1</sub> - P<sub>0</sub>)t，将其写成方程形式：</p>
<script type="math/tex; mode=display">
\begin {aligned}
B_{1}(t)&=P_0+(P_1-P_0)t \\
&=(1-t)P_0+tP_1
\end {aligned}</script><p><img src="/2018/07/30/BezierCurve/3.gif" alt="一阶贝塞尔曲线"></p>
<h4 id="emsp-emsp-2-二阶推导"><a href="#emsp-emsp-2-二阶推导" class="headerlink" title="&emsp;&emsp;2.二阶推导"></a>&emsp;&emsp;<strong>2.二阶推导</strong></h4><p>&emsp;&emsp;二阶在一阶的基础上增加一个点 P<sub>2</sub> ，此时不能够直接得出迹点的位置。 P<sub>0</sub> 和 P<sub>1</sub> 做一次一阶得到 M<sub>0</sub> 的位置，P<sub>1</sub> 和 P<sub>2</sub> 做一次一阶得到了 M<sub>1</sub> 的位置，此时出现了两个临时迹点 M<sub>0</sub> 和 M<sub>1</sub> ，需要再对 M<sub>0</sub> 和 M<sub>1</sub> 求一次一阶来得到真实迹点 M<sup>/</sup><sub>0</sub> 。即：</p>
<script type="math/tex; mode=display">
\begin {aligned}
B_{2}(t)&=M_{0}+(M_{1}-M_{0})t \\
&=P_0+(P_1-P_0)+[P_1+(P_2-P_1)t-P_0-(P_1-P_0)t]t \\
&=P_0+2(P_1-P_0)t+(P_0-2P_1+P_2)t^2 \\
&=(1-t)^2P_0+2t(1-t)P_1+t^2P_2
\end {aligned}</script><p><img src="/2018/07/30/BezierCurve/4.gif" alt="二阶贝塞尔曲线"></p>
<h4 id="emsp-emsp-3-三阶推导"><a href="#emsp-emsp-3-三阶推导" class="headerlink" title="&emsp;&emsp;3.三阶推导"></a>&emsp;&emsp;<strong>3.三阶推导</strong></h4><p>&emsp;&emsp;仿照一阶到二阶的升阶过程，不难得到三阶推导过程：</p>
<script type="math/tex; mode=display">
\begin {aligned}
B_{2}(t)&=M^\prime_0+(M^\prime_{1}-M^\prime_{0})t \\
&=M_0+(M_1-M_0)+[M_1+(M_2-M_1)t-M_0-(M_1-M_0)t]t \\
&=M_0+2(M_1-M_0)t+(M_0-2M_1+M_2)t^2 \\
&=P_0+(P_1-P_0)t+2[P_1+(P_2-P_1)t-P_0-(P_1-P_0)t]t+\{P_0+(P_1-P_0)t-2[P_1+(P_2-P_1)t]+P_2+(P_3-P_2)t\}t^2 \\
&=(1-t)^3P_0+3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 \\
\end {aligned}</script><p><img src="/2018/07/30/BezierCurve/5.gif" alt="二阶贝塞尔曲线"></p>
<h4 id="emsp-emsp-4-n阶"><a href="#emsp-emsp-4-n阶" class="headerlink" title="&emsp;&emsp;4.n阶"></a>&emsp;&emsp;<strong>4.n阶</strong></h4><p>&emsp;&emsp;综合上式列表，不难总结出一般性的规律。</p>
<script type="math/tex; mode=display">
\begin {array}{r|r}
(n) & B_n(t) \\ \hline
1 &  B_1(t) = (1-t)P_0+tP_1 \\
2 &  B_2(t) = (1-t)^2P_0+2t(1-t)P_1+t^2P_2 \\
3 &  B_3(t) = (1-t)^3P_0+3t(1-t)^2P_1+3^2(1-t)P_2+t^3P_3
...&  ...
\end {array}</script><script type="math/tex; mode=display">
\begin {aligned}
B_{n}(t)&=(1-t)^nP_0+ \sum\limits_{i=1}^{n-1}C_n^it^i(1-t)^{n-i}P_i+t^nP_n(n\geq2,n\in Z) 
\end {aligned}</script><p><img src="/2018/07/30/BezierCurve/6.gif" alt="n阶贝塞尔曲线"></p>
<h3 id="emsp-三、匀速化处理"><a href="#emsp-三、匀速化处理" class="headerlink" title="&emsp;三、匀速化处理"></a>&emsp;<strong>三、匀速化处理</strong></h3><p>&emsp;&emsp;前面介绍了贝塞尔曲线的数学表述形式，利用之我们可以根据任意个点的坐标画出曲线的直观路径，也可以用一组点来很好地拟合某一给定的曲线。现在，除了画来看之外，我们要用它来做点别的事情。什么事情？请看下图。<br><img src="/2018/07/30/BezierCurve/7.gif" alt="线性运动"><br>&emsp;&emsp;可以看到，上图小球的运动是非常死板的，其位置的变动与时间成线性关系。如果我们用图像描述上述运动，考虑到时间是均匀变化的，小球的位置也是均匀变化的，因此图像对应的是一条线段。而每一时刻 t 对应线段上的点处的导数值就是此时刻的瞬时速率，因为直线的斜率是固定的，所以小球起始和末了都是同一个速度，导致运动开始的很突兀，结束的也很突兀。<br><img src="/2018/07/30/BezierCurve/8.jpg" alt="这里写图片描述"><br>&emsp;&emsp;由此不难想到，如果我们想要使小球具有更加平滑的运动效果的话，只要对曲线稍加变形，让其更加符合让我们的动态审美。例如将上图的直线变形为下图。<br><img src="/2018/07/30/BezierCurve/9.jpg" alt="这里写图片描述"><br>&emsp;&emsp;这样小球的速度就能够平缓地增大到一定数值进行运动，最后也是平滑地停止下来了。<br><img src="/2018/07/30/BezierCurve/10.gif" alt="这里写图片描述"><br>&emsp;&emsp;<strong>但是请注意，上图平滑的运动效果仅仅是我们想象出来的</strong>，因为最开始 position-t 图像是根据运动而画出来的，之后我们人为地修改了曲线，但并没有让原来的小球按照我们改过的曲线来运动。<br>&emsp;&emsp;<strong>那么问题来了，如何让我们的小球按照我们绘制的曲线来运动呢？</strong>请继续往下看。</p>
<h4 id="emsp-emsp-1-什么是匀速化-amp-为什么要匀速化"><a href="#emsp-emsp-1-什么是匀速化-amp-为什么要匀速化" class="headerlink" title="&emsp;&emsp;1.什么是匀速化 &amp; 为什么要匀速化"></a>&emsp;&emsp;<strong>1.什么是匀速化 &amp; 为什么要匀速化</strong></h4><p>&emsp;&emsp;有些朋友看到这里可能按捺不住了，这难道还不简单吗？你刚才不是推导出了 n 阶的迹点追踪方程吗？均匀地传入 t 参数然后算出对应地position值赋给小球的位置不就完事了吗？<br>&emsp;&emsp;然而实时并没有想象的那么轻松，回过头来看看我们之前推导出来的方程：</p>
<script type="math/tex; mode=display">
\begin {aligned}
B_{n}(t)&=(1-t)^nP_0+ \sum\limits_{i=1}^{n-1}C_n^it^i(1-t)^{n-i}P_i+t^nP_n(n\geq2,n\in Z)
\end {aligned}</script><p>&emsp;&emsp;我们注意到，追踪方程的右侧并不是单纯的横坐标或是纵坐标，而是直接代以点的形式来表述。这表明了在实际计算的时候，需要按照需要的轴来代入点的坐标进行计算，例如需要计算以 P<sub>0</sub>、P<sub>1</sub>、P<sub>2</sub> 三个点确立的二阶贝塞尔曲线在 t=0.5 时的迹点的横坐标时，使用 P<sub>0</sub>.x、P<sub>1</sub>.x、P<sub>2</sub>.x 代入B<sub>2</sub>(t)的表达式即可计算输出对应的横坐标，纵坐标同理计算。<br>&emsp;&emsp;也就是说代入均匀的时间 t ，输出的并不是我们想要的纵坐标，因为贝塞尔曲线描述的图像是在 y-x 图像下的，而我们的之前修改的运动图是 position-t 图，也就是 y-t 图，两者虽然看上去长的一一样，但不在同一个坐标系下，所具有的意义也就相去甚远。而按照这种不完全的映射关得到的所谓的 y-t 运动图像，我们称之为非匀速贝塞尔运动。<br>&emsp;&emsp;那么究竟是什么原因导致了非匀速，或者说哪一步我们理解上容易出问题进而导致了错误的效果？究其因还是轴的偷换。下面我们不说具体的轴的名称了，就说横轴和纵轴。我们想要的结果是，横轴上的数匀速前进，向上投射到曲线上的某点，再映射到纵轴得到 position 坐标。<br><img src="/2018/07/30/BezierCurve/11.gif" alt="这里写图片描述"><br>&emsp;&emsp;可是贝塞尔曲线所在坐标系的横坐标是 x，并非 t！因此将匀速的 t 代入 B<sub>n</sub>(t) 是不能实现我们要的效果的，我们需要代入匀速的 x。由于当 t 匀速时， x 本身是由 B<sub>n</sub>(t) 算得的非匀速值，而通过匀速 t 对应非匀速的 x 求出其在匀速状态下应当对应的 t，就是匀速化的过程。</p>
<h4 id="emsp-emsp-2-两种匀速化的办法"><a href="#emsp-emsp-2-两种匀速化的办法" class="headerlink" title="&emsp;&emsp;2.两种匀速化的办法"></a>&emsp;&emsp;<strong>2.两种匀速化的办法</strong></h4><p>&emsp;&emsp;实际操作的时候，我们将匀速变化的时间也就是正常流动的时间记为 t，虽说是匀速的时间但我们心里明白这个 t 对我们的需求来说是“非匀速”的，将 t 当作 y-x 系下的 x 坐标代入 B<sub>n</sub>(t)，反解出其对应的真实的 r_t (即 real-t) 是多少，进而把 r_t 代回 B<sub>n</sub>(t) 最终得到了我们要的 y 值，即 position 值。但想要反解 t 也不是那么轻松，毕竟 B<sub>n</sub>(t) 的表达式有那么复杂。因此在这里匀速化的核心问题就是如何根据 P.x 反解 t。</p>
<h4 id="emsp-emsp-3-方法一：利用辛普森积分法匀速化"><a href="#emsp-emsp-3-方法一：利用辛普森积分法匀速化" class="headerlink" title="&emsp;&emsp;3.方法一：利用辛普森积分法匀速化"></a>&emsp;&emsp;<strong>3.方法一：利用辛普森积分法匀速化</strong></h4><p>&emsp;&emsp;此方法以画曲为直为思路，算出贝塞尔曲线的近似长度，将其放倒为一条线段。水平轴的数值匀速变大，即可看作是迹点在线上匀速运动，又时间取做单位1，自然不难求出点运动的速度v，而后与正常传入的 t 相乘得到匀速运动的距离L。最后用二分法或黄金分割法求出一个 t’ 时刻使得与 t’ 对应的 0~x 范围内的曲线长度L’与 L 近似相等，此时所求得的 t 即是我们要找的realTime。<br>&emsp;&emsp;此处给出了思路，下面附上求三阶贝塞尔曲线近似长度的算法，剩下的算法请感兴趣的读者自行完成。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 求 0~t 段的贝塞尔曲线长度</span><br><span class="line">double beze_length(Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	int TOTAL_SIMPSON_STEP;</span><br><span class="line">	int stepCounts;</span><br><span class="line">	int halfCounts;</span><br><span class="line">	int i;</span><br><span class="line">	double sum1, sum2, dStep;</span><br><span class="line">	</span><br><span class="line">	TOTAL_SIMPSON_STEP = 100000;</span><br><span class="line">	stepCounts = TOTAL_SIMPSON_STEP*t;</span><br><span class="line"></span><br><span class="line">	if(stepCounts == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(stepCounts%2 == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		stepCounts++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	halfCounts = stepCounts/2;</span><br><span class="line">	dStep = t / stepCounts;</span><br><span class="line"></span><br><span class="line">	while(i&lt;halfCounts)</span><br><span class="line">	&#123;</span><br><span class="line">		sum1 += beze_speed (p, (2 * i + 1) * dStep);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	i=1;</span><br><span class="line">	while(i&lt;halfCounts)</span><br><span class="line">	&#123;</span><br><span class="line">		sum2 += beze_speed (p, 2 * i * dStep);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	return ((beze_speed (p, 0) + beze_speed (p, 1) + 2 * sum2 + 4 * sum1) * dStep / 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double beze_speed_x (Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	// 三阶</span><br><span class="line">	return -3 * p [0].x * pow (1 - t, 2) + 3 * p [1].x * pow (1 - t, 2) - 6 * p [1].x * (1 － t) * t ＋ 6 * p [2].x * (1 - t) * t - 3 * p [2].x * pow (t, 2) + 3 * p [3].x * pow (t, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double beze_speed_y (Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	// 三阶</span><br><span class="line">	return -3 * p [0].y * pow (1 - t, 2) + 3 * p [1].y * pow (1 - t, 2) - 6 * p [1].y * (1 － t) * t ＋ 6 * p [2].y * (1 - t) * t - 3 * p [2].y * pow (t, 2) + 3 * p [3].y * pow (t, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//	求合速度</span><br><span class="line">double beze_speed (Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	double vx = beze_speed_x (p, t);</span><br><span class="line">	double vy = beze_speed_y (p, t);</span><br><span class="line">	return sqrt(pow (vx, 2) + pow (vy, 2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="emsp-emsp-4-方法二：编程逼值实现匀速化"><a href="#emsp-emsp-4-方法二：编程逼值实现匀速化" class="headerlink" title="&emsp;&emsp;4.方法二：编程逼值实现匀速化"></a>&emsp;&emsp;<strong>4.方法二：编程逼值实现匀速化</strong></h4><p>&emsp;&emsp;此方法就是简单地不断二分来求 B<sub>3</sub>(t) 的反函数值，与方法一相比较而言更为简单也更易于理解，下面附上完整代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">struct Coordinate</span><br><span class="line">&#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 声明函数</span><br><span class="line">int b3(Coordinate p[], double t);</span><br><span class="line">double t2rt(Coordinate p[], double t);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	// 定义四个贝塞尔点</span><br><span class="line">	Coordinate p[4]=&#123;&#123;100, 611&#125;, &#123;300, 411&#125; ,&#123;400, 311&#125; ,&#123;500, 411&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">	// 输出 t=0.5 对应的匀速 rt</span><br><span class="line">	printf(&quot;%lf\n&quot;, t2rt(p, 0.5));</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int b3(Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	// 三阶贝塞尔运算</span><br><span class="line">	int retn;</span><br><span class="line">	retn = pow(1-t, 3) * p[0].x + 3*t*pow(1-t, 2) * p[1].x + 3*pow(t, 2) * (1-t)*p[2].x + pow(t, 3)*p[3].x;</span><br><span class="line">	return retn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double t2rt(Coordinate p[], double t)</span><br><span class="line">&#123;</span><br><span class="line">	// 定义真实时间与差时变量</span><br><span class="line">	double realTime, deltaTime;</span><br><span class="line">	</span><br><span class="line">	// 曲线上的 x 坐标</span><br><span class="line">	int bezierX;</span><br><span class="line">	</span><br><span class="line">	// 计算 t 对应曲线上匀速的 x 坐标</span><br><span class="line">	int x = 100 + (p[3].x - p[0].x)*t;</span><br><span class="line">	</span><br><span class="line">	realTime = 1;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		// 半分</span><br><span class="line">		if(deltaTime&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			realTime -= (double)realTime/2;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			realTime += (double)realTime/2;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 计算本此 &quot;rt&quot; 对应的曲线上的 x 坐标</span><br><span class="line">		bezierX = b3(p, realTime);</span><br><span class="line">		</span><br><span class="line">		// 计算差时</span><br><span class="line">		deltaTime = bezierX - x;</span><br><span class="line">	&#125;</span><br><span class="line">	// 差时逼近为0时跳出循环</span><br><span class="line">	while(deltaTime != 0);</span><br><span class="line"></span><br><span class="line">	return realTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;以上就是两种将贝塞尔曲线运动匀速化的方法，下面我们来看两个简单的应用。</p>
<h3 id="emsp-四、匀速化后的应用"><a href="#emsp-四、匀速化后的应用" class="headerlink" title="&emsp;四、匀速化后的应用"></a>&emsp;<strong>四、匀速化后的应用</strong></h3><p>&emsp;&emsp;<strong>1.高自由度的缓动动效</strong><br>&emsp;&emsp;在将贝塞尔曲线应用于运动之前，一些动画的过度效果往往比较生硬和死板（如上面提到的线性运动）。而贝塞尔曲线运动则可以得到很好的视觉效果。一些网站提供了<a href="http://easings.net/zh-cn" target="_blank" rel="noopener">缓动函数表</a>，使用这些已经封装好公开使用的缓动函数可以方便快捷地将一些流畅的动画效果引入到自己的项目当中实现一些简单的缓动动效。<br>&emsp;&emsp;但是其所提供的缓动函数毕竟有限，在此之外的效果想要实现可能就麻烦了，例如博主曾经在其他地方推导介绍过利用</p>
<script type="math/tex; mode=display">
\begin {aligned}
k(t)&=\frac{1}{2}[sin(\pi t- \frac{\pi}{2})+1] \\\
\end {aligned}</script><p>来简单地正弦软化线性数据，而应用本文所讲述的贝塞尔曲线运动则可以实现高自由度的可调整缓动效果，借此可实现动画效果与程序本体的逻辑分离，提高交互动效的开发自由度，也更加便于后期更新和维护。<br>（具体实例待更新）<br>&emsp;&emsp;<strong>2.物理效果的模拟</strong><br>&emsp;&emsp;考虑到某一物体(图形)在任意轴方向上的运动都可以通过贝塞尔曲线来方便地调节与控制，自然可以将其应用与物理效果的模拟上。例如令一小圆在水平方向上随时间匀速运动，而竖直方向上其y坐标的值按照二次形状的匀速化贝塞尔曲线来增大，这样就模拟了平抛运动，而通过自由地调节贝塞尔曲线的形状，可以非常轻松地模拟其他更加复杂的物理效果。<br>（具体实例待更新）</p>
<h3 id="emsp-五、总结"><a href="#emsp-五、总结" class="headerlink" title="&emsp;五、总结"></a>&emsp;<strong>五、总结</strong></h3><p>待更新</p>
<script type="math/tex; mode=display">--- END ---</script><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>沿途简记</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>C++DLL在E中的调用（C+E模式）</title>
    <url>/2018/07/30/C-DLL-E/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><blockquote>
<p>考虑到使用E语言设计程序界面比较简单与方便，同时又有一些比较完善的 DirectUI 引擎的支持，故在一些实际的小项目中可以考虑用C/C++写核心，E写界面，两者取长补短，提高开发效率。本文分享如何在VS2017中用使用C++编写DLL文件并在E中进行调用。</p>
</blockquote>
<p><img src="/2018/07/30/C-DLL-E/1.jpg" alt="使用E做的界面"><br>（在E中借助自绘引擎做的界面）</p>
<h3 id="一、编写DLL"><a href="#一、编写DLL" class="headerlink" title="一、编写DLL"></a><strong>一、编写DLL</strong></h3><p> <strong>1.</strong> 打开VS2017，文件-&gt;新建-&gt;项目-Visual C++-&gt;空项目，这里命名为demo。</p>
<p> <strong>2.</strong> 在 资源管理器-&gt;源文件 中新建一个名为 demo.cpp 的 C++ 源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;demo.h&quot;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//返回整形的函数</span><br><span class="line">int testInt() </span><br><span class="line">&#123;</span><br><span class="line">	return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回字符串的函数</span><br><span class="line">char *testString() </span><br><span class="line">&#123;</span><br><span class="line">	static char sample[100] = &#123; 0 &#125;;</span><br><span class="line">	strcpy_s(sample, &quot;demo&quot;);</span><br><span class="line">	return sample;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有参数的函数</span><br><span class="line">int add(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>3.</strong> 在 资源管理器-&gt;源文件 中新建一个 demo.def 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LIBRARY demo</span><br><span class="line">EXPORTS</span><br><span class="line">testInt</span><br><span class="line">add</span><br><span class="line">testString</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong> 在 资源管理器-&gt;头文件 中新建一个 demo.h 头文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma once</span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) int testInt();</span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) int add(int a, int b);</span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) char * testString();</span><br></pre></td></tr></table></figure>
<p><strong>5.</strong> 为了得到尽可能小的体积，在 Release 模式下调试项目，报错显示不是有效的 Win32 应用程序，不用管，找到工程目录下 Release 文件夹中生成的 demo.exe，修改其后缀为 .dll 得到 DLL 文件。</p>
<h3 id="二、调用DLL"><a href="#二、调用DLL" class="headerlink" title="二、调用DLL"></a><strong>二、调用DLL</strong></h3><p><strong>1.</strong> 新建E程序，添加外部DLL引用：</p>
<p><img src="/2018/07/30/C-DLL-E/2.jpg" alt="E中添加外部DLL引用"></p>
<p><strong>2.</strong> 这里注意，因为C++与E默认的约定模式不同，如果命令有参数的话，“在库中对应命令名”一栏前面要加上一个@符号，否则会出现堆栈错误。</p>
<p><img src="/2018/07/30/C-DLL-E/3.jpg" alt="调用有参数的命令没有加@导致的堆栈错误"></p>
<p><strong>3.</strong> 调用相关代码，此处添加在窗口创建完毕的事件子程序中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.版本 2</span><br><span class="line"></span><br><span class="line">信息框 (到文本 (testInt ()) ＋ #换行符 ＋ testString () ＋ #换行符 ＋ 到文本 (add (100, 200)), 0, , )</span><br><span class="line">结束 ()</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong> 将 demo.dll 放在e程序的同级目录下，或者使用 置DLL装载目录 () 命令将下一次默认调用目录转到dll文件所在目录，随后 F5 调试程序。运行结果如下图：</p>
<p><img src="/2018/07/30/C-DLL-E/4.jpg" alt="运行结果"></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>经验心得</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Sun的逆向之路（三）——暴破15年阿里移动安全挑战赛第一题</title>
    <url>/2018/07/30/sun-s-reverse-3/</url>
    <content><![CDATA[<p><img src="/2018/07/30/sun-s-reverse-3/1.jpg" alt="这里写图片描述"></p>
<h3 id="emsp-0x01-观察题目"><a href="#emsp-0x01-观察题目" class="headerlink" title="&emsp;0x01 观察题目"></a>&emsp;<strong>0x01 观察题目</strong></h3><p>&emsp;&emsp;用模拟器运行程序，看到题目营造了一个情景让我们破解应用的登录系统，先随便输入一串数字，提示我们密码不对，请继续破解。<br><a id="more"></a><br><img src="/2018/07/30/sun-s-reverse-3/2.jpg" alt="这里写图片描述"></p>
<h3 id="emsp-0x02-静态暴破"><a href="#emsp-0x02-静态暴破" class="headerlink" title="&emsp;0x02 静态暴破"></a>&emsp;<strong>0x02 静态暴破</strong></h3><p>&emsp;&emsp;首先将AliCrackme_1.apk用apktool进行反编译。<br><img src="/2018/07/30/sun-s-reverse-3/3.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;反编译成功后得到输出文件夹：<br><img src="/2018/07/30/sun-s-reverse-3/4.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;在eclipse中新建Java Project，将反编译文件夹设为工程目录，我们来看一看工程结构。<br><img src="/2018/07/30/sun-s-reverse-3/5.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;接下来查找一下“密码”，发现没有做编码，定位到了string.xml文件中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=&quot;abc_action_mode_done&quot;&gt;Done&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_action_bar_home_description&quot;&gt;Navigate home&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_action_bar_up_description&quot;&gt;Navigate up&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_action_menu_overflow_description&quot;&gt;More options&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_searchview_description_search&quot;&gt;Search&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_searchview_description_query&quot;&gt;Search query&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_searchview_description_clear&quot;&gt;Clear query&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_searchview_description_submit&quot;&gt;Submit query&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_searchview_description_voice&quot;&gt;Voice search&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_activitychooserview_choose_application&quot;&gt;Choose an app&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_activity_chooser_view_see_all&quot;&gt;See all&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_shareactionprovider_share_with_application&quot;&gt;Share with %s&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;abc_shareactionprovider_share_with&quot;&gt;Share with&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;app_name&quot;&gt;UFO&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;dialog_title&quot;&gt;提示&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;dialog_error_tips&quot;&gt;密码不对，请继续破解&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;dialog_good_tips&quot;&gt;恭喜！！！破解成功！！！&lt;/string&gt;</span><br><span class="line">    &lt;string name=&quot;dialog_ok&quot;&gt;确定&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对应string name是”dialog_error_tips”，顺便记录一下破解成功的string name，根据已有的线索追踪引用dialog_error_tips的位置，不难定位到public.xml文件。</p>
<p><img src="/2018/07/30/sun-s-reverse-3/6.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;可以看到其id为0x7f0a0011，而顺带记录下0x7f0a0012。顺藤摸瓜，看看哪里引用了0x7f0a0011，发现在MainActivity$1与R$String这两个文件中该字符串有出没，但显然后者没有有效信息，于是进入第一个smali文件，找到id所在位置，对应代码块如下：<br><img src="/2018/07/30/sun-s-reverse-3/7.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;发现下面一大片位于:cond_0中，而整个:cond_0位于onClick函数内，这应该就是按钮的点击事件的处理函数，先看看在这里:cond_0中都做了哪些操作。<br>&emsp;&emsp;首先new-instance新创建了一个实例，随后const v6作为中间变量，不断调用AlertDialog$Builder中的setMessage函数构造Dialog的各部分字符串，在.line 67处显示了对话框，也就是我们看到的密码不正确的提示框。再往下翻，紧接着goto :goto_0，发现goto_0处就直接return-void了。<br>&emsp;&emsp;分析完了:cond_0内的逻辑，来看看哪些地方跳到了这儿。大致浏览一番，定位到了如下代码块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if-eqz v4, :cond_0</span><br><span class="line">const-string v6, &quot;&quot;</span><br><span class="line">invoke-virtual &#123;v4, v6&#125;, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z</span><br><span class="line">move-result v6</span><br><span class="line">if-nez v6, :cond_0</span><br><span class="line">invoke-virtual &#123;v4, v2&#125;, Ljava/lang/String;-&gt;equals(Ljava/lang/Object;)Z</span><br><span class="line">move-result v6</span><br><span class="line">if-eqz v6, :cond_0</span><br><span class="line">.line 55</span><br><span class="line">iget-object v6, p0, Lcom/example/simpleencryption/MainActivity$1;-&gt;this$0:Lcom/example/simpleencryption/MainActivity;</span><br><span class="line">invoke-static &#123;v6&#125;, Lcom/example/simpleencryption/MainActivity;-&gt;access$1(Lcom/example/simpleencryption/MainActivity;)V</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先判断v4是否等于零，是的话跳转到:cond_0，后面连续几个判断都跳到了:cond_0，说明v4，v6的值代表了输入的密码是否正确，这里我们直接黑掉这几个判断，代码顺利执行到.line 55，这里access$1函数引起了我们的关注，于是进入MainActivity中找到access$1，函数代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method static synthetic access$1(Lcom/example/simpleencryption/MainActivity;)V</span><br><span class="line">    .locals 0</span><br><span class="line">    .prologue</span><br><span class="line">    .line 73</span><br><span class="line">    invoke-direct &#123;p0&#125;, Lcom/example/simpleencryption/MainActivity;-&gt;showDialog()V</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;函数内部又调用了showDiglog，找到showDiglog函数，发现与onClick函数的:cond_0逻辑神似，也是构造对话框，意外发现了一串熟悉的id: 0x7f0a0012</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method private showDialog()V</span><br><span class="line">    .locals 3</span><br><span class="line">    .prologue</span><br><span class="line">    .line 74</span><br><span class="line">    new-instance v0, Landroid/app/AlertDialog$Builder;</span><br><span class="line">    invoke-direct &#123;v0, p0&#125;, Landroid/app/AlertDialog$Builder;-&gt;&lt;init&gt;(Landroid/content/Context;)V</span><br><span class="line">    .line 75</span><br><span class="line">    .local v0, &quot;builder&quot;:Landroid/app/AlertDialog$Builder;</span><br><span class="line">    const v1, 0x7f0a0012</span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/app/AlertDialog$Builder;-&gt;setMessage(I)Landroid/app/AlertDialog$Builder;</span><br><span class="line">    .line 76</span><br><span class="line">    const v1, 0x7f0a0010</span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/app/AlertDialog$Builder;-&gt;setTitle(I)Landroid/app/AlertDialog$Builder;</span><br><span class="line">    .line 77</span><br><span class="line">    const v1, 0x7f0a0013</span><br><span class="line">    .line 78</span><br><span class="line">    new-instance v2, Lcom/example/simpleencryption/MainActivity$2;</span><br><span class="line">    invoke-direct &#123;v2, p0&#125;, Lcom/example/simpleencryption/MainActivity$2;-&gt;&lt;init&gt;(Lcom/example/simpleencryption/MainActivity;)V</span><br><span class="line">    .line 77</span><br><span class="line">    invoke-virtual &#123;v0, v1, v2&#125;, Landroid/app/AlertDialog$Builder;-&gt;setPositiveButton(ILandroid/content/DialogInterface$OnClickListener;)Landroid/app/AlertDialog$Builder;</span><br><span class="line">    .line 84</span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/app/AlertDialog$Builder;-&gt;show()Landroid/app/AlertDialog;</span><br><span class="line">    .line 85</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;很明显我们找到了提示成功信息的地方。最后回编译apk文件，打上签名在模拟器上安装应用，随便输入密码，点击确认，可以看到已经破解成功了。<br><img src="/2018/07/30/sun-s-reverse-3/8.jpg" alt="这里写图片描述"></p>
<h3 id="emsp-0x03-总结"><a href="#emsp-0x03-总结" class="headerlink" title="&emsp;0x03 总结"></a>&emsp;<strong>0x03 总结</strong></h3><p>&emsp;&emsp;<strong>考虑到暴破相对来说有点低级了，下一篇将尝试从动态调试的角度重新审视此题，并真正意义上的破解出该题的正确密码。</strong></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>逆向破解</category>
      </categories>
      <tags>
        <tag>APK</tag>
      </tags>
  </entry>
  <entry>
    <title>Sun的逆向之路（二）——FiF口语训练的刷分剖析</title>
    <url>/2018/07/30/sun-s-reverse-2/</url>
    <content><![CDATA[<p>&emsp;&emsp;闲来无事看了看FiF口语中一些Task的排行榜，翻着翻着意外发现了一个101分的榜首，按理来说满分才只有100分，因此猜想这个分数一定是被动过手脚的，于是来了兴致，从POST请求与APK反编译两个角度分别尝试破解FiF。</p>
<hr>
<h3 id="方案一：APK反编译"><a href="#方案一：APK反编译" class="headerlink" title="方案一：APK反编译"></a><strong>方案一：APK反编译</strong></h3><p>&emsp;&emsp;将FiF的apk文件拖入AndroidKiller，发现加载失败，于是拖入jadx，发现原来上了奇虎的加固壳，考虑到只是把玩娱乐，脱壳会大大增加复杂性，于是暂时放弃反编译的想法。</p>
<h3 id="方案二：POST请求拦截"><a href="#方案二：POST请求拦截" class="headerlink" title="方案二：POST请求拦截"></a><strong>方案二：POST请求拦截</strong></h3><h3 id="emsp-0x01-配置Fiddler"><a href="#emsp-0x01-配置Fiddler" class="headerlink" title="&emsp;0x01 配置Fiddler"></a>&emsp;<strong>0x01 配置Fiddler</strong></h3><p>&emsp;&emsp;因为自从用了新电脑就没有抓过包了，因此还是要做一些配置的。Java Jdk和环境变量的配置工作在此掠过了，但考虑到这次Fiddler的配置过程还有点不同寻常，所以这里做一下记录。<br>&emsp;&emsp;运行Fiddler提示8888端口被占用了，询问是否随机取端口。考虑到不使用8888可能后面会造成一些不必要的麻烦，于是打开cmd输入netstat -ano|findstr “8888”，发现原来端口被PID为20348的应用占用了，打开任务管理器的详细信息选卡，发现是Matlab，于是结束进程。<br><a id="more"></a><br><img src="/2018/07/30/sun-s-reverse-2/1.jpg" alt="这里写图片描述"></p>
<p>&emsp;&emsp;随后重启Fiddler，发现没有端口占用提示了。再次查看8888端口的状态，可以看到这个端口已经成功被Fiddler监听。接下来在手机浏览器访问“IP:8888”，安装Fiddler证书即可，IP可通过控制台ipconfig指令查看。至此环境配置结束。</p>
<p><img src="/2018/07/30/sun-s-reverse-2/2.jpg" alt="这里写图片描述"></p>
<h3 id="emsp-0x02-POST请求拦截"><a href="#emsp-0x02-POST请求拦截" class="headerlink" title="&emsp;0x02 POST请求拦截"></a>&emsp;<strong>0x02 POST请求拦截</strong></h3><p>&emsp;&emsp;手机端对应设置好HTTP代理后，打开FiF，发现Fiddler这边的请求很杂乱，这是因为电脑和手机上所有的网络请求都被显示了，于是配置过滤器，只显示抓取Host为m.oral.fifedu.com的请求，同时通过命令bpc:m.oral.fifedu.com来设置请求断点。随便进入一个Task，这里我进的是四级口语模拟题2的Task1。随便读两句。<br><img src="/2018/07/30/sun-s-reverse-2/3.png" alt="这里写图片描述"><br>&emsp;&emsp;随后提交，在Fiddler上可以看到请求已经被拦截下来了，<br><img src="/2018/07/30/sun-s-reverse-2/4.png" alt="这里写图片描述"><br>&emsp;&emsp;对应在右侧的WebForms中可以看到对应的jasonobject：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    &quot;recordPath&quot; : &quot;2811000026000000971\/cc253a5178c44088b736bcb9386f324e\/e7ba561752f34de683f6435e47ced8f6\/t\/0_0.mp3&quot;,</span><br><span class="line">    &quot;score&quot; : &quot;0&quot;,</span><br><span class="line">    &quot;ansDetail&quot; : &quot;word#0&quot;,</span><br><span class="line">    &quot;learn_time&quot; : &quot;2&quot;,</span><br><span class="line">    &quot;questionId&quot; : &quot;e7ba561752f34de683f6435e47ced8f6#0#0&quot;,</span><br><span class="line">    &quot;accuracy&quot; : &quot;0&quot;,</span><br><span class="line">    &quot;fluency&quot; : &quot;0&quot;,</span><br><span class="line">    &quot;complete&quot; : &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;显然score代表的就是分数，我们将其修改为101，在Fiddler中单击Run To Completion放行修改过的请求，手机端对应有了相应，提示挑战失败，但我们返回列表并刷新，发现实际上数据已经上传成功并在排行榜上显示了。至此FiF口语的刷分就顺利实现了。<br><img src="/2018/07/30/sun-s-reverse-2/5.jpg" alt="这里写图片描述"></p>
<h3 id="emsp-0x03-小结"><a href="#emsp-0x03-小结" class="headerlink" title="&emsp;0x03 小结"></a>&emsp;<strong>0x03 小结</strong></h3><p>&emsp;&emsp;<strong>FiF口语虽然对应用加壳处理了，但是却忘记了对网络请求进行安全加固，导致了刷分的可行性。希望FiF口语官方对请求参数进行加密或组合加密，或利用sign值算法验证请求的合法性，尽快更新应用并修复此漏洞。</strong></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>逆向破解</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>Sun的逆向之路（一）——元气骑士的内购破解</title>
    <url>/2018/07/30/sun-s-reverse-1/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近代码码多了于是打算翻翻有什么游戏可玩，无意之中翻到了之前玩的元气骑士，想到还有许多人物都没有解锁，但是又不想攒金币因为太慢了，况且还有一些角色是要RMB才能买的，通过PKiP发现无加固壳，于是一怒之下打算破解其内购。</p>
<hr>
<h3 id="0x01-找寻突破口"><a href="#0x01-找寻突破口" class="headerlink" title="0x01 找寻突破口"></a><strong>0x01 找寻突破口</strong></h3><p>&emsp;&emsp;打开元气骑士进入购买人物的场景，点击购买，因为钻石不够所以点进去发现跳转到了购买钻石的页面。1块钱可以兑换800钻石，于是点购买跳转到了爱贝支付。返回取消购买回到了游戏入口界面，提示购买失败。</p>
<h3 id="0x02-初步尝试破解"><a href="#0x02-初步尝试破解" class="headerlink" title="0x02 初步尝试破解"></a><strong>0x02 初步尝试破解</strong></h3><p>&emsp;&emsp;于是用MT2拿到apk的dex文件，搜索“失败”，发现iapppay下的IAppPayOrderChecker和MainActivit$3$1格外瞩目。进入IAppPayOrderChecker发现没有相关内容，于是转到MainActivity$3$1中。在OnPayResult函数中发现如下代码块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.line 113</span><br><span class="line">iget-object v1, p0, Lcom/chillyroomsdk/iapppay/MainActivity$3$1;-&gt;this$1:Lcom/chillyroomsdk/iapppay/MainActivity$3;</span><br><span class="line">iget-object v2, p0, Lcom/chillyroomsdk/iapppay/MainActivity$3$1;-&gt;val$orderId:Ljava/lang/String;</span><br><span class="line">iget-object v3, p0, Lcom/chillyroomsdk/iapppay/MainActivity$3$1;-&gt;val$extra:Ljava/lang/String;</span><br><span class="line">invoke-virtual &#123;v1, v2, v3&#125;, Lcom/chillyroomsdk/iapppay/MainActivity$3;-&gt;onPayFail(Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line">.line 116</span><br><span class="line">:goto_18</span><br><span class="line">const-string v1, &quot;Unity&quot;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中的OnPayFail值得注意，既然有OnPayFail那么就应该有OnPaySuccess，我们继续往下翻的确找到了OnPaySuccess，同时在OnPaySuccess上方看到 :pswitch_45，将其记录下来。翻到底部找到了一个pswitch结构：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> .line 96</span><br><span class="line">:pswitch_data_86</span><br><span class="line">.packed-switch 0x0</span><br><span class="line">    :pswitch_45</span><br><span class="line">    :pswitch_4</span><br><span class="line">    :pswitch_7c</span><br><span class="line">.end packed-switch</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意到:pswitch<em>45下方还有:pswitch_4和:pswitch_7c，我们找到pswitch_4所在的位置发现正好跳转到了OnPayFail所在的位置。这时我们大概清楚了代码逻辑，即不同的情况分别跳转到不同的:pswitch</em>代码块。我们将另外两个pswitch的跳转编号全部修改为45。到这里，购买成功的破解就完成了。</p>
<h3 id="0x03-深入订单校验"><a href="#0x03-深入订单校验" class="headerlink" title="0x03 深入订单校验"></a><strong>0x03 深入订单校验</strong></h3><p>&emsp;&emsp;但是进入游戏发现仍然购买失败。提示的是：支付成功但验签失败。<br><img src="/2018/07/30/sun-s-reverse-1/1.png" alt=""><br>&emsp;&emsp;看来元气骑士的内购验证还是比较严密的。回到dex文件，发现该字符串仍旧位于MainActivity$3$1，由:cond_6e跳转而来，发现原来在OnPaySuccess的上一步还做了一个支付判断（if-eqz v0, :cond_6e），如果订单状态校验不吻合就跳转到:cond_6e。将这条代码注释掉，重新进入游戏购买，发现还是失败了，提示订单支付失败。若发生丢单请勿重复支付，并联系客服。<br><img src="/2018/07/30/sun-s-reverse-1/2.png" alt=""><br>&emsp;&emsp;这时冷静下来，猜想除了 MainActivity 内的 OnPayResult 判断外，应该还有其他的订单检验方法，重新审视了一下com类，不出所料，在最开始被忽视的 <strong>IAppPayOrderChecker</strong> 中发现了对应字符串，代码块对应 :cond_f5，往上一翻发现多处if-eqz跳转到了此处！二话不说对所有转到 :cond_f5 的判断语句进行注释，中途还发现一个 :cond_133 跳转到验证失败于是也一并注释了。<br>至此不出意外应该已经成功完成了内购破解。</p>
<h3 id="0x04-破除apk签名验证"><a href="#0x04-破除apk签名验证" class="headerlink" title="0x04 破除apk签名验证"></a><strong>0x04 破除apk签名验证</strong></h3><p>有意思的是，虽然内购破解应该已经顺利完成了，但是重编译并自己手动打上签名安装后发现直接无法进入游戏了，提示我们请下载正版游戏并跳转到了元气骑士的官方网站。猜想是联网验证于是断掉无线局域网重进游戏，发现依旧无法进入游戏并直接闪退了，看来游戏做了联网+本地的双重验证。<br>回到dex++，最终在 UnityExtendAcitivity 中的起始位置发现了名为 GetKeyHash 函数，代码片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method public static GetKeyHash()Ljava/lang/String;</span><br><span class="line">   .registers 7</span><br><span class="line">   .prologue</span><br><span class="line">   const/4 v3, 0x0</span><br><span class="line">   .line 26</span><br><span class="line">   :try_start_1</span><br><span class="line">   sget-object v4, Lcom/unity3d/player/UnityPlayer;-&gt;currentActivity:Landroid/app/Activity;</span><br><span class="line">   invoke-virtual &#123;v4&#125;, Landroid/app/Activity;-&gt;getPackageManager()Landroid/content/pm/PackageManager;</span><br><span class="line">   move-result-object v4</span><br></pre></td></tr></table></figure>
<p>在.prologue与const/4 v3, 0x0之间直接插入return-void拦截此函数的执行，最后保存修改过的dex文件，更新apk包并打上应用签名，重新安装apk文件，没有出现异常，可以进入游戏了，随便购买一个人物，进入订单页面，返回取消订单，可以看到支付成功，除了人物之外，钻石也可以随意购买了。<br><img src="/2018/07/30/sun-s-reverse-1/3.png" alt="支付成功"></p>
<h3 id="0x05-附件与声明"><a href="#0x05-附件与声明" class="headerlink" title="0x05 附件与声明"></a><strong>0x05 附件与声明</strong></h3><blockquote>
<p>破解后的游戏下载地址：<a href="https://pan.baidu.com/s/1pL1JzsR" target="_blank" rel="noopener">https://pan.baidu.com/s/1pL1JzsR</a> 密码: 7dvq<br>本文及附件内容仅限于技术学习，同时希望相应公司尽快修复相关漏洞。</p>
</blockquote>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>逆向破解</category>
      </categories>
      <tags>
        <tag>APK</tag>
      </tags>
  </entry>
  <entry>
    <title>Sunwish&#39;s Blog 开通啦</title>
    <url>/2018/07/20/My-First-Post/</url>
    <content><![CDATA[<p>说实话，其实一直以来都想搭建一个自己的博客的…</p>
<p>至于原因很简单啊，因为有一个自己的博客的话就可以没事吹吹水啊，写些心得体会啊，记录一些有趣和有意义的事情啊记录一些乱七八糟的事情啊什么的…</p>
<p>反正是自己的 Space，想怎么瞎折腾都行，不像在别人的网站上写点东西，处处受限制，发个文章还得等审核</p>
<p>不过现在就不一样啦哈哈哈，我的地盘我做主，想想还是一件很美好的事情诶。<br><img src="/2018/07/20/My-First-Post/1.JPG" alt=""></p>
<p>不过虽说搭一个自己的博客是一直以来都想做的事情，可惜无奈之前一直一直实在是太太太太忙(lǎn)了，哪来的闲情折腾这个啊！</p>
<p>然后就一拖再拖，一拖再拖，拖了又拖…到后来压根就忘了这壶 :)</p>
<p>不过好在偶尔还是会想要写点东西的，先前都写在 CSDN 了，有些还写在了QQ日志…！%#@$</p>
<p>说白了就是写哪儿都感到不自在，于是突然回想起来那啥我好像曾经还想搭个博客来着啥！</p>
<p><img src="/2018/07/20/My-First-Post/2.GIF" alt=""></p>
<p>于是这就重新燃起了我搭建博客的热血 —_—！</p>
<p>直到今天…，终于忙(lǎn)里偷闲(qín)啊，总算是把自己的博客给搭起来了，于是乎这就成为了我博客的第一篇文章~~</p>
<a id="more"></a>
<p>其实这个博客的话前两天就已经捣鼓的差不多了，只是最近一直在忙数模，所以各种配置什么的都没鸟，于是 Blog 一直都处于毛坯状态，也没有真正 deploy，只是丢在本地没事的时候就开开 server 去 localhost 自我欣赏一下啊哈哈</p>
<p><img src="/2018/07/20/My-First-Post/3.JPG" alt=""></p>
<p>所以说虽然现在是 2018.7.20 22点39分，如果要论博客小屋的生日的话，那到应该往前推两天，也就是 7.18 才对</p>
<p>今天的话稍微闲一点，所以就把 Blog Theme 和各种 Personal Config 给调教了一番，然后写下这篇开博之作，算是标志着 Sunwish’s Blog 的正式开通吧！</p>
<p>万事开头难啊，发表这篇博客后，我就会陆陆续续把以前写在 CSDN 博客的文章给搬运过来，而后就正式开始博客的更新工作了！</p>
<p>PS：关于域名的问题，我从很久以前就开始想了，奈何我起名困难啊！！！不然也不会这么耿直地叫 Sunwish’s Blog 了！！！</p>
<p>想着还有一个 houkaifa.com 的域名搁着吹风，于是就拿来用了</p>
<p>等我什么时候想好了合适的博客域名，或者是猴开发崛起了需要使用这个域名，再更换博客地址</p>
<p>不过如果不出意外的话短期到中期都是 houkaifa.com 这个域名了 :)</p>
<p>最后为自己的新博客打call~~</p>
<p><img src="/2018/07/20/My-First-Post/4.gif" alt=""></p>
<center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>博客历程</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>【个人项目】 Easecurve 2.0 · 缓动引擎</title>
    <url>/2016/12/24/Easecurve/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p>Easecurve 缓动引擎是一款采用多区段拟合技术，基于.ecr缓动结构文件来完成数据回调并执行高度自定义化缓动效果的多元化程序缓动动效开发引擎。Easecurve 相较于其他的缓动支持，具有高效多态、拓展性强、可维护性强、精度可调、可跨语言等特点。</p>
</blockquote>
<p><img src="/2016/12/24/Easecurve/UI-EasecurveBuilder_InitPage.png" alt="启动界面"> Easecurve 2.0 启动界面</p>
<a id="more"></a>
<hr>
<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h3><h4 id="1-关于-Easecurve-缓动引擎"><a href="#1-关于-Easecurve-缓动引擎" class="headerlink" title="1. 关于 Easecurve 缓动引擎"></a><strong>1. 关于 Easecurve 缓动引擎</strong></h4><p>&emsp;&emsp;Easecurve 缓动引擎是一款采用多区段拟合技术，基于.ecr缓动结构文件来完成数据回调并执行高度自定义化缓动效果的多元化程序缓动动效开发引擎。Easecurve 相较于其他的缓动支持，具有高效多态、拓展性强、可维护性强、精度可调、可跨语言等特点。</p>
<p>&emsp;&emsp;本引擎(包)由 EasecurveBuilder 与 EasecurveInterface 两大部分组成，并提供一定量的.ecproject模板文件及相应的接入例程，旨在帮助广大开发者们更快更好地入门到缓动开发中。</p>
<p>&emsp;&emsp;使用 EasecurveBuilder，您可以快速高效地对.ecr缓动文件进行可视化的开发与调整，实现缓动视觉与程序本体的逻辑分离，大大提高动效设计的效率，保护了接入源程序的独立性与迭代更新的轻便性。</p>
<p>&emsp;&emsp;使用 EasecurveInterface，您可以简明快速地将.ecr缓动结构文件所提供的模板动效接入到您的目标程序当中，也可以单纯自由地取得任意相对地时刻下缓动结构文件中的回调数据，这有效地规避了 ECI 接口自身的局限性，以便您更加自由地利用模板数据设计独一无二的缓动动效。<br><img src="/2016/12/24/Easecurve/StartPage.jpg" alt="StartPage">Easecurve 2.0 起始页</p>
<h4 id="2-Easecurve-2-0-的优势"><a href="#2-Easecurve-2-0-的优势" class="headerlink" title="2. Easecurve 2.0 的优势"></a><strong>2. Easecurve 2.0 的优势</strong></h4><p>&emsp;&emsp;1. 提供可视化的缓动开发工具，告别复杂而繁琐的抽象化设计过程，使得缓动更加轻松自由。</p>
<p>&emsp;&emsp;2. 接入代码与实际缓动效果相互分离，具备极强的后期可维护性，更换缓动效果无需更新源程序，甚至无需更新任何代码。</p>
<p>&emsp;&emsp;3. 具有庞大的缓动模板库，支持对所有缓动模板进行二次开发，提供多段曲线拼接支持。</p>
<p>&emsp;&emsp;4. 支持多轴多级缓动，兼备对定位移动与循环运动两种形式的动效支持，不局限于短时性缓动，适用于交互动效开发。</p>
<p>&emsp;&emsp;5. 统一采用窗口句柄作为缓动标识，使得任意组件和窗口的缓动得到支持，为开发者的二次封装和跨语言移植工作提供便利。</p>
<p>&emsp;&emsp;6. 支持空白缓动，即缓动数据的实时回调，规避了接口自身的局限性，使得基于拟合数据的动效形态变得丰富多彩。</p>
<p>&emsp;&emsp;7. 得力于全新的 ECP 缓动模式，使得基于一个文件的多组件缓动成为可能，也为全局变动的自封装支持提供了便利。</p>
<p>&emsp;&emsp;8. 引入 EXML，进一步增大了前端设计师与后端工程师的合作强度。</p>
<h4 id="3-版权声明"><a href="#3-版权声明" class="headerlink" title="3. 版权声明"></a><strong>3. 版权声明</strong></h4><p>&emsp;&emsp;未经版权所有者明确授权，禁止发行本文档及其被实质上修改的版本。</p>
<p>&emsp;&emsp;未经版权所有者事先授权，禁止将此作品及其衍生作品以标准（纸质）书籍形式发布。</p>
<p>&emsp;&emsp;如果有兴趣再发行或再版文档的全部或部分内容，不论修改过与否，或有任何问题，请联系版权所有者（<a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1bymoLuivKa9laSk_7a6uA" target="_blank" rel="noopener">iSuwish@qq.com</a>）。</p>
<h3 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a><strong>二、入门</strong></h3><h4 id="1-引擎获取"><a href="#1-引擎获取" class="headerlink" title="1. 引擎获取"></a><strong>1. 引擎获取</strong></h4><p>&emsp;&emsp;Easecurve 2.0 是一款公开使用的，基于多种语言开发的优秀缓动动效引擎。</p>
<p>&emsp;&emsp;您可以通过以下渠道获取纯净原版的 Easecurve 2.0 缓动引擎：</p>
<ul>
<li>通过访问 Easecurve 官方网站：<a href="http://easecurve.com/" target="_blank" rel="noopener">Easecurve.com</a> 获取下载。</li>
<li>通过加入 Easecurve 官方交流群： 540459921 获取下载。</li>
<li>通过与作者Sunwish（<a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1bymoLuivKa9laSk_7a6uA" target="_blank" rel="noopener">iSuwish@qq.com</a>）进行亲密的PY交♂易，获取纯净特别版。</li>
</ul>
<blockquote>
<p>如果您是普通用户，开发的软件不用于商业用途，则无需向作者进行授权申请。</p>
<p><strong>如果您是商业用户或开发的软件用于商业用途，则需要另外向作者申请授权才可以在该软件中合法使用。</strong></p>
<p>作者保留对在商业用途中使用本产品而未经授权的开发者及其软件追究责任的权利。</p>
</blockquote>
<p><img src="/2016/12/24/Easecurve/workspace.jpg" alt="workspace">在 Easecurve 2.0 中编辑缓动曲线</p>
<h4 id="2-环境要求"><a href="#2-环境要求" class="headerlink" title="2. 环境要求"></a><strong>2. 环境要求</strong></h4><p>&emsp;&emsp;系统要求：Windows、Linux</p>
<h4 id="3-整体架构"><a href="#3-整体架构" class="headerlink" title="3. 整体架构"></a><strong>3. 整体架构</strong></h4><p>Easecurve 缓动引擎由 ECB (EasecurveBuilder) 、 ECI (EasecurveInterface) 两部分组成，与其密切相关的有 ECR (EasecurveResource) 、 ECP (EasecurvePackage) 、 EXML (EasecurveXML) 三大结构文件。本小节仅对其做基本的介绍，如有详细了解结构文件的需求，请跳转至 <a href="https://www.kancloud.cn/sunwish/easecurve/282432" target="_blank" rel="noopener">标准封装</a> 章节</p>
<p><strong>ECB (EasecurveBuilder)</strong></p>
<p>EasecurveBuilder（ECB）是 Easecurve 提供的能够对.ecr缓动结构文件进行曲线化设计的新型开发工具。使用 EasecurveBuilder，您可以快速高效地对.ecr缓动文件进行可视化的开发与调整，实现缓动视觉与程序本体的逻辑分离，大大提高动效设计的效率，保护了接入源程序的独立性与迭代更新的轻便性。</p>
<p><strong>ECI (EasecurveInterface)</strong></p>
<p>EasecurveInterface（ECI）是 Easecurve 提供的能够快速地将经由 EasecurveBuilder 设计的缓动曲线文件接入应用到实际需求场景下的强大接口。使用 EasecurveInterface，您可以简明快速地将.ecr缓动结构文件所提供的模板动效接入到您的目标程序当中，也可以单纯自由地取得任意相对时刻下缓动结构文件中的回调数据，这有效地规避了 ECI 接口自身的局限性，以便您更加自由地利用模板数据设计独一无二的缓动动效。</p>
<p><strong>ECR (EasecurveResource)</strong></p>
<p>EasecurveResource（ECR）是经由 EasecurveBuilder 渲染生成的标准的缓动结构文件，其内包含了利用 ECI 完成一个标准缓动所必须的全部数据，有且不限于曲线段数、段占比、时间映射。因为 ECR 文件当中存储了大量的数据，因此较高的精度通常需要以文件体积的增大作为代价。</p>
<p><strong>ECP (EasecurvePackage)</strong></p>
<p>EasecurvePackage（ECP）是经由 EasecurveBuilder 渲染生成的标准的缓动结构包文件，其内包含了利用 ECI 完成一个标准包缓动所必须的全部数据，有且不限于曲线段数、段占比、时间映射。因为 ECP 文件当中存储了大量的数据，因此较高的精度通常需要以文件体积的增大作为代价。</p>
<p><strong>EXML (EasecurveXML)</strong></p>
<p>EasecurveXML（EXML）是 Easecurve 提供的一种强大的缓动模式文件，通过EXML与ECI的有机结合能够帮助开发者快速高效地实现程序中的大规模缓动（全局变动）。在 EasecurveBuilder 中可借助布局文件可视化地对EXML文件进行开发与修整， EXML文件短小精悍，具有可调控、易维护、独立性强等优点。</p>
<p><strong>ECProject（EasecurveProject）</strong></p>
<p>EasecurveProject（ECProject） 是缓动曲线设计软件 EasecurveBuilder 的专用格式，可以保存 EasecurveBuilder 的曲线路径、缓动设置等数据。用 ECProject 格式保存缓动曲线文件时只保留必要的设置数据及关键点信息，属于有损保存，所以当缓动需求十分复杂、精度要求十分高时也能够保持极小的体积与磁盘占用。使用 EasecurveBuilder 完成曲线的设计后最好存储一个 ECProject 的文件备份，直到确认不需要在 EasecurveBuilder 中再次编辑该曲线。</p>
<p><img src="/2016/12/24/Easecurve/ecpFileStruct.jpg" alt="ecpFileStruct">.ecp文件架构</p>
<h3 id="三、完整文档"><a href="#三、完整文档" class="headerlink" title="三、完整文档"></a><strong>三、完整文档</strong></h3><p>&emsp;&emsp;<a href="https://www.kancloud.cn/sunwish/easecurve/282419" target="_blank" rel="noopener">戳我看完整文档</a></p>
<h4 id="博主是个念旧的人，在看案例欣赏前先强制回味下老版本-Easecurve-1-0"><a href="#博主是个念旧的人，在看案例欣赏前先强制回味下老版本-Easecurve-1-0" class="headerlink" title="博主是个念旧的人，在看案例欣赏前先强制回味下老版本 Easecurve 1.0"></a>博主是个念旧的人，在看案例欣赏前先强制回味下老版本 Easecurve 1.0</h4><p><img src="/2016/12/24/Easecurve/OLDeasecurve.gif" alt="OLDeasecurve">老版本 Easecurve 1.0 低low界面</p>
<h3 id="四、案例欣赏"><a href="#四、案例欣赏" class="headerlink" title="四、案例欣赏"></a><strong>四、案例欣赏</strong></h3><h4 id="1-采用-Easecurve-2-0-开发的实际项目登录界面（迅析统计-·-一步到位）"><a href="#1-采用-Easecurve-2-0-开发的实际项目登录界面（迅析统计-·-一步到位）" class="headerlink" title="1. 采用 Easecurve 2.0 开发的实际项目登录界面（迅析统计 · 一步到位）"></a><strong>1. 采用 Easecurve 2.0 开发的实际项目登录界面（<a href="http://sinser.applinzi.com/" target="_blank" rel="noopener">迅析统计 · 一步到位</a>）</strong></h4><p><img src="/2016/12/24/Easecurve/2.gif" alt="迅析登录界面"></p>
<h4 id="2-采用-Easecurve-2-0-开发的实际项目更新提示框（dpRun，现已转型为Alterful）"><a href="#2-采用-Easecurve-2-0-开发的实际项目更新提示框（dpRun，现已转型为Alterful）" class="headerlink" title="2. 采用 Easecurve 2.0 开发的实际项目更新提示框（dpRun，现已转型为Alterful）"></a><strong>2. 采用 Easecurve 2.0 开发的实际项目更新提示框（dpRun，现已转型为<a href="http://alterful.com/" target="_blank" rel="noopener">Alterful</a>）</strong></h4><p><img src="/2016/12/24/Easecurve/7.gif" alt="dpRun更新提示"></p>
<h4 id="3-基于-Easecurve-全局变动与差时技术开发的界面动效"><a href="#3-基于-Easecurve-全局变动与差时技术开发的界面动效" class="headerlink" title="3. 基于 Easecurve 全局变动与差时技术开发的界面动效"></a><strong>3. 基于 Easecurve 全局变动与差时技术开发的界面动效</strong></h4><p><img src="/2016/12/24/Easecurve/1.gif" alt="全局变动与差时动效"></p>
<h4 id="4-基于-Easecurve-ECI-回调开发的图像转场动效"><a href="#4-基于-Easecurve-ECI-回调开发的图像转场动效" class="headerlink" title="4. 基于 Easecurve + ECI 回调开发的图像转场动效"></a><strong>4. 基于 Easecurve + ECI 回调开发的图像转场动效</strong></h4><p><img src="/2016/12/24/Easecurve/3.gif" alt="图像转场动效"></p>
<h4 id="5-基于-Easecurve-缓动回调的渐显隐效果"><a href="#5-基于-Easecurve-缓动回调的渐显隐效果" class="headerlink" title="5. 基于 Easecurve 缓动回调的渐显隐效果"></a><strong>5. 基于 Easecurve 缓动回调的渐显隐效果</strong></h4><p><img src="/2016/12/24/Easecurve/4.gif" alt="渐显隐效果"></p>
<h4 id="6-基于-Easecurve-与原创算法开发的仿QQ登录界面低多边形动效"><a href="#6-基于-Easecurve-与原创算法开发的仿QQ登录界面低多边形动效" class="headerlink" title="6. 基于 Easecurve 与原创算法开发的仿QQ登录界面低多边形动效"></a><strong>6. 基于 Easecurve 与原创算法开发的仿QQ登录界面低多边形动效</strong></h4><p><img src="/2016/12/24/Easecurve/8.gif" alt="低多边形动效"></p>
<h4 id="7-基于-Easecurve-ECI-的矩阵变换动效"><a href="#7-基于-Easecurve-ECI-的矩阵变换动效" class="headerlink" title="7. 基于 Easecurve + ECI 的矩阵变换动效"></a><strong>7. 基于 Easecurve + ECI 的矩阵变换动效</strong></h4><p><img src="/2016/12/24/Easecurve/5.gif" alt="观察任意向量变换">观察任意向量变换</p>
<p><img src="/2016/12/24/Easecurve/6.gif" alt="伸缩变换及张成空间的降维">伸缩变换及张成空间的降维</p>
<h3 id="五、引擎现状"><a href="#五、引擎现状" class="headerlink" title="五、引擎现状"></a><strong>五、引擎现状</strong></h3><h4 id="emsp-emsp-由于-Easecurve-开发团队（猴开发）开发人员不足（只有本菜鸡一人）、开发经费不足（开发经费为零）、开发信仰缺失（单干历时近两年已经无聊死）、开发时间欠缺（目前忙的一批），本引擎已饿死在摇篮中（不过诈尸可以有），若有人看中（能看见就不错了，摊手）本项目，有勇气接盘，或有意愿加入-Easecurve-开发，或是有意向资助博主红票子继续开发、愿意充值信仰的，请速速联系博主！博主保证卷款就走，不胜感激！"><a href="#emsp-emsp-由于-Easecurve-开发团队（猴开发）开发人员不足（只有本菜鸡一人）、开发经费不足（开发经费为零）、开发信仰缺失（单干历时近两年已经无聊死）、开发时间欠缺（目前忙的一批），本引擎已饿死在摇篮中（不过诈尸可以有），若有人看中（能看见就不错了，摊手）本项目，有勇气接盘，或有意愿加入-Easecurve-开发，或是有意向资助博主红票子继续开发、愿意充值信仰的，请速速联系博主！博主保证卷款就走，不胜感激！" class="headerlink" title="&emsp;&emsp;由于 Easecurve 开发团队（猴开发）开发人员不足（只有本菜鸡一人）、开发经费不足（开发经费为零）、开发信仰缺失（单干历时近两年已经无聊死）、开发时间欠缺（目前忙的一批），本引擎已饿死在摇篮中（不过诈尸可以有），若有人看中（能看见就不错了，摊手）本项目，有勇气接盘，或有意愿加入 Easecurve 开发，或是有意向资助博主红票子继续开发、愿意充值信仰的，请速速联系博主！博主保证卷款就走，不胜感激！"></a>&emsp;&emsp;由于 Easecurve 开发团队（<a href="https://jq.qq.com/?_wv=1027&amp;k=5OeUSU5" target="_blank" rel="noopener">猴开发</a>）开发人员不足（只有本菜鸡一人）、开发经费不足（开发经费为零）、开发信仰缺失（单干历时近两年已经无聊死）、开发时间欠缺（目前忙的一批），<strong>本引擎已饿死在摇篮中</strong>（不过诈尸可以有），若有人看中（能看见就不错了，摊手）本项目，有勇气接盘，或有意愿加入 Easecurve 开发，或是有意向资助博主红票子继续开发、愿意充值信仰的，请速速<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=770168287&amp;site=qq&amp;menu=yes" target="_blank" rel="noopener">联系博主</a>！博主保证卷款就走，不胜感激！</h4><center>--- END ---</center><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
  </entry>
</search>
